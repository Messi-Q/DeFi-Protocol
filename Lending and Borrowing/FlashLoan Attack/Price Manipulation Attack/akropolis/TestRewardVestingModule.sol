// SPDX-License-Identifier: AGPL V3.0
pragma solidity ^0.6.12;

import "@ozUpgradesV3/contracts/access/OwnableUpgradeable.sol";

import "@ozUpgradesV3/contracts/token/ERC20/IERC20Upgradeable.sol";
import "@ozUpgradesV3/contracts/token/ERC20/SafeERC20Upgradeable.sol";
import "@ozUpgradesV3/contracts/math/SafeMathUpgradeable.sol";

contract TestRewardVestingModule is OwnableUpgradeable {
    event RewardTokenRegistered(address indexed protocol, address token);
    event EpochRewardAdded(address indexed protocol, address indexed token, uint256 epoch, uint256 amount);
    event RewardClaimed(address indexed protocol, address indexed token, uint256 claimPeriodStart, uint256 claimPeriodEnd, uint256 claimAmount);

    using SafeERC20Upgradeable for IERC20Upgradeable;
    using SafeMathUpgradeable for uint256;

    struct Epoch {
        uint256 end; // Timestamp of Epoch end
        uint256 amount; // Amount of reward token for this protocol on this epoch
    }

    struct RewardInfo {
        Epoch[] epochs;
        uint256 lastClaim; // Timestamp of last claim
    }

    struct ProtocolRewards {
        address[] tokens;
        mapping(address => RewardInfo) rewardInfo;
    }

    address public rewardManager;
    address public pool;

    mapping(address => ProtocolRewards) internal rewards;
    uint256 public defaultEpochLength;

    modifier onlyRewardManager() {
        require(_msgSender() == rewardManager, "Only reward manager");
        _;
    }

    function initialize(address _pool) public initializer {
        __Ownable_init();
        pool = _pool;
        rewardManager = _msgSender();
        defaultEpochLength = 7 * 24 * 60 * 60;
    }

    function getRewardInfo(address protocol, address token) public view returns (uint256 lastClaim, uint256 epochCount) {
        ProtocolRewards storage r = rewards[protocol];
        RewardInfo storage ri = r.rewardInfo[token];
        return (ri.lastClaim, ri.epochs.length);
    }

    function registerRewardToken(
        address protocol,
        address token,
        uint256 firstEpochStart
    ) public onlyRewardManager {
        if (firstEpochStart == 0) firstEpochStart = block.timestamp;
        //Push zero epoch
        ProtocolRewards storage r = rewards[protocol];
        RewardInfo storage ri = r.rewardInfo[token];
        require(ri.epochs.length == 0, "RewardVesting: token already registered for this protocol");
        r.tokens.push(token);
        ri.epochs.push(Epoch({end: firstEpochStart, amount: 0}));
        emit RewardTokenRegistered(protocol, token);
    }

    function setDefaultEpochLength(uint256 _defaultEpochLength) public onlyRewardManager {
        defaultEpochLength = _defaultEpochLength;
    }

    function getEpochInfo(
        address protocol,
        address token,
        uint256 epoch
    )
        public
        view
        returns (
            uint256 epochStart,
            uint256 epochEnd,
            uint256 rewardAmount
        )
    {
        ProtocolRewards storage r = rewards[protocol];
        RewardInfo storage ri = r.rewardInfo[token];
        require(ri.epochs.length > 0, "RewardVesting: protocol or token not registered");
        require(epoch < ri.epochs.length, "RewardVesting: epoch number too high");
        if (epoch == 0) {
            epochStart = 0;
        } else {
            epochStart = ri.epochs[epoch - 1].end;
        }
        epochEnd = ri.epochs[epoch].end;
        rewardAmount = ri.epochs[epoch].amount;
        return (epochStart, epochEnd, rewardAmount);
    }

    function getLastCreatedEpoch(address protocol, address token) public view returns (uint256) {
        ProtocolRewards storage r = rewards[protocol];
        RewardInfo storage ri = r.rewardInfo[token];
        require(ri.epochs.length > 0, "RewardVesting: protocol or token not registered");
        return ri.epochs.length - 1;
    }

    function claimRewards() public {
        address protocol = _msgSender();
        ProtocolRewards storage r = rewards[protocol];
        //require(r.tokens.length > 0, "RewardVesting: call only from registered protocols allowed");
        if (r.tokens.length == 0) return; //This allows claims from protocols which are not yet registered without reverting
        for (uint256 i = 0; i < r.tokens.length; i++) {
            _claimRewards(protocol, r.tokens[i]);
        }
    }

    function claimRewards(address protocol, address token) public {
        _claimRewards(protocol, token);
    }

    function _claimRewards(address protocol, address token) internal {
        ProtocolRewards storage r = rewards[protocol];
        RewardInfo storage ri = r.rewardInfo[token];
        uint256 epochsLength = ri.epochs.length;
        require(epochsLength > 0, "RewardVesting: protocol or token not registered");

        Epoch storage lastEpoch = ri.epochs[epochsLength - 1];
        uint256 previousClaim = ri.lastClaim;
        if (previousClaim == lastEpoch.end) return; // Nothing to claim yet

        if (lastEpoch.end < block.timestamp) {
            ri.lastClaim = lastEpoch.end;
        } else {
            ri.lastClaim = block.timestamp;
        }

        uint256 claimAmount;
        Epoch storage ep = ri.epochs[0];
        uint256 i;
        // Searching for last claimable epoch
        for (i = epochsLength - 1; i > 0; i--) {
            ep = ri.epochs[i];
            if (ep.end < block.timestamp) {
                // We've found last fully-finished epoch
                if (i < epochsLength - 1) {
                    // We have already started current epoch
                    i++; //    Go back to currently-running epoch
                    ep = ri.epochs[i];
                }
                break;
            }
        }
        if (ep.end > block.timestamp) {
            //Half-claim
            uint256 epStart = ri.epochs[i - 1].end;
            uint256 claimStart = (previousClaim > epStart) ? previousClaim : epStart;
            uint256 epochClaim = ep.amount.mul(block.timestamp.sub(claimStart)).div(ep.end.sub(epStart));
            claimAmount = claimAmount.add(epochClaim);
            i--;
        }
        //Claim rest
        for (i; i > 0; i--) {
            ep = ri.epochs[i];
            uint256 epStart = ri.epochs[i - 1].end;
            if (ep.end > previousClaim) {
                if (previousClaim > epStart) {
                    uint256 epochClaim = ep.amount.mul(ep.end.sub(previousClaim)).div(ep.end.sub(epStart));
                    claimAmount = claimAmount.add(epochClaim);
                } else {
                    claimAmount = claimAmount.add(ep.amount);
                }
            } else {
                break;
            }
        }
        IERC20Upgradeable(token).safeTransfer(protocol, claimAmount);
        emit RewardClaimed(protocol, token, previousClaim, ri.lastClaim, claimAmount);
    }

    function createEpoch(
        address protocol,
        address token,
        uint256 epochEnd,
        uint256 amount
    ) public onlyRewardManager {
        ProtocolRewards storage r = rewards[protocol];
        RewardInfo storage ri = r.rewardInfo[token];
        uint256 epochsLength = ri.epochs.length;
        require(epochsLength > 0, "RewardVesting: protocol or token not registered");
        uint256 prevEpochEnd = ri.epochs[epochsLength - 1].end;
        require(epochEnd > prevEpochEnd, "RewardVesting: new epoch should end after previous");
        ri.epochs.push(Epoch({end: epochEnd, amount: 0}));
        _addReward(protocol, token, epochsLength, amount);
    }

    function addReward(
        address protocol,
        address token,
        uint256 epoch,
        uint256 amount
    ) public onlyRewardManager {
        _addReward(protocol, token, epoch, amount);
    }

    function addRewards(
        address[] calldata protocols,
        address[] calldata tokens,
        uint256[] calldata epochs,
        uint256[] calldata amounts
    ) external onlyRewardManager {
        require(
            (protocols.length == tokens.length) && (protocols.length == epochs.length) && (protocols.length == amounts.length),
            "RewardVesting: array lengths do not match"
        );
        for (uint256 i = 0; i < protocols.length; i++) {
            _addReward(protocols[i], tokens[i], epochs[i], amounts[i]);
        }
    }

    /**
     * @notice Add reward to existing epoch or crete a new one
     * @param protocol Protocol for reward
     * @param token Reward token
     * @param epoch Epoch number - can be 0 to create new Epoch
     * @param amount Amount of Reward token to deposit
     */
    function _addReward(
        address protocol,
        address token,
        uint256 epoch,
        uint256 amount
    ) internal {
        ProtocolRewards storage r = rewards[protocol];
        RewardInfo storage ri = r.rewardInfo[token];
        uint256 epochsLength = ri.epochs.length;
        require(epochsLength > 0, "RewardVesting: protocol or token not registered");
        if (epoch == 0) epoch = epochsLength; // creating a new epoch
        if (epoch == epochsLength) {
            uint256 epochEnd = ri.epochs[epochsLength - 1].end.add(defaultEpochLength);
            if (epochEnd < block.timestamp) epochEnd = block.timestamp; //This generally should not happen, but just in case - we generate only one epoch since previous end
            ri.epochs.push(Epoch({end: epochEnd, amount: amount}));
        } else {
            require(epochsLength > epoch, "RewardVesting: epoch is too high");
            Epoch storage ep = ri.epochs[epoch];
            require(ep.end > block.timestamp, "RewardVesting: epoch already finished");
            ep.amount = ep.amount.add(amount);
        }
        emit EpochRewardAdded(protocol, token, epoch, amount);
        IERC20Upgradeable(token).safeTransferFrom(_msgSender(), address(this), amount);
    }
}
