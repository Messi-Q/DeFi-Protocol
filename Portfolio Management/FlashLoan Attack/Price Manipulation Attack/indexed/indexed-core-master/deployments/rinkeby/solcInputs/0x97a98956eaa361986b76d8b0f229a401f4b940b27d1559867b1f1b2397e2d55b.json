{
  "language": "Solidity",
  "sources": {
    "contracts/balancer/BConst.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\n\n\n/************************************************************************************************\nOriginally from https://github.com/balancer-labs/balancer-core/blob/master/contracts/BConst.sol\n\nThis source code has been modified from the original, which was copied from the github repository\nat commit hash f4ed5d65362a8d6cec21662fb6eae233b0babc1f.\n\nSubject to the GPL-3.0 license\n*************************************************************************************************/\n\n\ncontract BConst {\n  uint256 public constant VERSION_NUMBER = 0;\n\n/* ---  Weight Updates  --- */\n\n  // Minimum time passed between each weight update for a token.\n  uint256 internal constant WEIGHT_UPDATE_DELAY = 1 hours;\n\n  // Maximum percent by which a weight can adjust at a time\n  // relative to the current weight.\n  // The number of iterations needed to move from weight A to weight B is the floor of:\n  // (A > B): (ln(A) - ln(B)) / ln(1.01)\n  // (B > A): (ln(A) - ln(B)) / ln(0.99)\n  uint256 internal constant WEIGHT_CHANGE_PCT = BONE/100;\n\n  uint256 internal constant BONE = 10**18;\n\n  uint256 internal constant MIN_BOUND_TOKENS = 2;\n  uint256 internal constant MAX_BOUND_TOKENS = 10;\n\n  // Minimum swap fee.\n  uint256 internal constant MIN_FEE = BONE / 10**6;\n  // Maximum swap or exit fee.\n  uint256 internal constant MAX_FEE = BONE / 10;\n  // Actual exit fee.\n  uint256 internal constant EXIT_FEE = 0;\n\n  // Default total of all desired weights. Can differ by up to BONE.\n  uint256 internal constant DEFAULT_TOTAL_WEIGHT = BONE * 25;\n  // Minimum weight for any token (1/100).\n  uint256 internal constant MIN_WEIGHT = BONE / 4;\n  uint256 internal constant MAX_WEIGHT = BONE * 25;\n  // Maximum total weight.\n  uint256 internal constant MAX_TOTAL_WEIGHT = BONE * 26;\n  // Minimum balance for a token (only applied at initialization)\n  uint256 internal constant MIN_BALANCE = BONE / 10**12;\n  // Initial pool tokens\n  uint256 internal constant INIT_POOL_SUPPLY = BONE * 100;\n\n  uint256 internal constant MIN_BPOW_BASE = 1 wei;\n  uint256 internal constant MAX_BPOW_BASE = (2 * BONE) - 1 wei;\n  uint256 internal constant BPOW_PRECISION = BONE / 10**10;\n\n  // Maximum ratio of input tokens to balance for swaps.\n  uint256 internal constant MAX_IN_RATIO = BONE / 2;\n  // Maximum ratio of output tokens to balance for swaps.\n  uint256 internal constant MAX_OUT_RATIO = (BONE / 3) + 1 wei;\n}\n"
    },
    "contracts/balancer/BMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\n\nimport \"./BNum.sol\";\n\n\n/************************************************************************************************\nOriginally from https://github.com/balancer-labs/balancer-core/blob/master/contracts/BMath.sol\n\nThis source code has been modified from the original, which was copied from the github repository\nat commit hash f4ed5d65362a8d6cec21662fb6eae233b0babc1f.\n\nSubject to the GPL-3.0 license\n*************************************************************************************************/\n\n\ncontract BMath is BConst, BNum {\n  /**********************************************************************************************\n    // calcSpotPrice                                                                             //\n    // sP = spotPrice                                                                            //\n    // bI = tokenBalanceIn                ( bI / wI )         1                                  //\n    // bO = tokenBalanceOut         sP =  -----------  *  ----------                             //\n    // wI = tokenWeightIn                 ( bO / wO )     ( 1 - sF )                             //\n    // wO = tokenWeightOut                                                                       //\n    // sF = swapFee                                                                              //\n    **********************************************************************************************/\n  function calcSpotPrice(\n    uint256 tokenBalanceIn,\n    uint256 tokenWeightIn,\n    uint256 tokenBalanceOut,\n    uint256 tokenWeightOut,\n    uint256 swapFee\n  ) internal pure returns (uint256 spotPrice) {\n    uint256 numer = bdiv(tokenBalanceIn, tokenWeightIn);\n    uint256 denom = bdiv(tokenBalanceOut, tokenWeightOut);\n    uint256 ratio = bdiv(numer, denom);\n    uint256 scale = bdiv(BONE, bsub(BONE, swapFee));\n    return (spotPrice = bmul(ratio, scale));\n  }\n\n  /**********************************************************************************************\n    // calcOutGivenIn                                                                            //\n    // aO = tokenAmountOut                                                                       //\n    // bO = tokenBalanceOut                                                                      //\n    // bI = tokenBalanceIn              /      /            bI             \\    (wI / wO) \\      //\n    // aI = tokenAmountIn    aO = bO * |  1 - | --------------------------  | ^            |     //\n    // wI = tokenWeightIn               \\      \\ ( bI + ( aI * ( 1 - sF )) /              /      //\n    // wO = tokenWeightOut                                                                       //\n    // sF = swapFee                                                                              //\n    **********************************************************************************************/\n  function calcOutGivenIn(\n    uint256 tokenBalanceIn,\n    uint256 tokenWeightIn,\n    uint256 tokenBalanceOut,\n    uint256 tokenWeightOut,\n    uint256 tokenAmountIn,\n    uint256 swapFee\n  ) internal pure returns (uint256 tokenAmountOut) {\n    uint256 weightRatio = bdiv(tokenWeightIn, tokenWeightOut);\n    uint256 adjustedIn = bsub(BONE, swapFee);\n    adjustedIn = bmul(tokenAmountIn, adjustedIn);\n    uint256 y = bdiv(tokenBalanceIn, badd(tokenBalanceIn, adjustedIn));\n    uint256 foo = bpow(y, weightRatio);\n    uint256 bar = bsub(BONE, foo);\n    tokenAmountOut = bmul(tokenBalanceOut, bar);\n    return tokenAmountOut;\n  }\n\n  /**********************************************************************************************\n    // calcInGivenOut                                                                            //\n    // aI = tokenAmountIn                                                                        //\n    // bO = tokenBalanceOut               /  /     bO      \\    (wO / wI)      \\                 //\n    // bI = tokenBalanceIn          bI * |  | ------------  | ^            - 1  |                //\n    // aO = tokenAmountOut    aI =        \\  \\ ( bO - aO ) /                   /                 //\n    // wI = tokenWeightIn           --------------------------------------------                 //\n    // wO = tokenWeightOut                          ( 1 - sF )                                   //\n    // sF = swapFee                                                                              //\n    **********************************************************************************************/\n  function calcInGivenOut(\n    uint256 tokenBalanceIn,\n    uint256 tokenWeightIn,\n    uint256 tokenBalanceOut,\n    uint256 tokenWeightOut,\n    uint256 tokenAmountOut,\n    uint256 swapFee\n  ) internal pure returns (uint256 tokenAmountIn) {\n    uint256 weightRatio = bdiv(tokenWeightOut, tokenWeightIn);\n    uint256 diff = bsub(tokenBalanceOut, tokenAmountOut);\n    uint256 y = bdiv(tokenBalanceOut, diff);\n    uint256 foo = bpow(y, weightRatio);\n    foo = bsub(foo, BONE);\n    tokenAmountIn = bsub(BONE, swapFee);\n    tokenAmountIn = bdiv(bmul(tokenBalanceIn, foo), tokenAmountIn);\n    return tokenAmountIn;\n  }\n\n  /**********************************************************************************************\n    // calcPoolOutGivenSingleIn                                                                  //\n    // pAo = poolAmountOut         /                                              \\              //\n    // tAi = tokenAmountIn        ///      /     //    wI \\      \\\\       \\     wI \\             //\n    // wI = tokenWeightIn        //| tAi *| 1 - || 1 - --  | * sF || + tBi \\    --  \\            //\n    // tW = totalWeight     pAo=||  \\      \\     \\\\    tW /      //         | ^ tW   | * pS - pS //\n    // tBi = tokenBalanceIn      \\\\  ------------------------------------- /        /            //\n    // pS = poolSupply            \\\\                    tBi               /        /             //\n    // sF = swapFee                \\                                              /              //\n    **********************************************************************************************/\n  function calcPoolOutGivenSingleIn(\n    uint256 tokenBalanceIn,\n    uint256 tokenWeightIn,\n    uint256 poolSupply,\n    uint256 totalWeight,\n    uint256 tokenAmountIn,\n    uint256 swapFee\n  ) internal pure returns (uint256 poolAmountOut) {\n    // Charge the trading fee for the proportion of tokenAi\n    ///  which is implicitly traded to the other pool tokens.\n    // That proportion is (1- weightTokenIn)\n    // tokenAiAfterFee = tAi * (1 - (1-weightTi) * poolFee);\n    uint256 normalizedWeight = bdiv(tokenWeightIn, totalWeight);\n    uint256 zaz = bmul(bsub(BONE, normalizedWeight), swapFee);\n    uint256 tokenAmountInAfterFee = bmul(tokenAmountIn, bsub(BONE, zaz));\n\n    uint256 newTokenBalanceIn = badd(tokenBalanceIn, tokenAmountInAfterFee);\n    uint256 tokenInRatio = bdiv(newTokenBalanceIn, tokenBalanceIn);\n\n    // uint newPoolSupply = (ratioTi ^ weightTi) * poolSupply;\n    uint256 poolRatio = bpow(tokenInRatio, normalizedWeight);\n    uint256 newPoolSupply = bmul(poolRatio, poolSupply);\n    poolAmountOut = bsub(newPoolSupply, poolSupply);\n    return poolAmountOut;\n  }\n\n  /**********************************************************************************************\n    // calcSingleInGivenPoolOut                                                                  //\n    // tAi = tokenAmountIn              //(pS + pAo)\\     /    1    \\\\                           //\n    // pS = poolSupply                 || ---------  | ^ | --------- || * bI - bI                //\n    // pAo = poolAmountOut              \\\\    pS    /     \\(wI / tW)//                           //\n    // bI = balanceIn          tAi =  --------------------------------------------               //\n    // wI = weightIn                              /      wI  \\                                   //\n    // tW = totalWeight                          |  1 - ----  |  * sF                            //\n    // sF = swapFee                               \\      tW  /                                   //\n    **********************************************************************************************/\n  function calcSingleInGivenPoolOut(\n    uint256 tokenBalanceIn,\n    uint256 tokenWeightIn,\n    uint256 poolSupply,\n    uint256 totalWeight,\n    uint256 poolAmountOut,\n    uint256 swapFee\n  ) internal pure returns (uint256 tokenAmountIn) {\n    uint256 normalizedWeight = bdiv(tokenWeightIn, totalWeight);\n    uint256 newPoolSupply = badd(poolSupply, poolAmountOut);\n    uint256 poolRatio = bdiv(newPoolSupply, poolSupply);\n\n    //uint newBalTi = poolRatio^(1/weightTi) * balTi;\n    uint256 boo = bdiv(BONE, normalizedWeight);\n    uint256 tokenInRatio = bpow(poolRatio, boo);\n    uint256 newTokenBalanceIn = bmul(tokenInRatio, tokenBalanceIn);\n    uint256 tokenAmountInAfterFee = bsub(newTokenBalanceIn, tokenBalanceIn);\n    // Do reverse order of fees charged in joinswap_ExternAmountIn, this way\n    //     ``` pAo == joinswap_ExternAmountIn(Ti, joinswap_PoolAmountOut(pAo, Ti)) ```\n    //uint tAi = tAiAfterFee / (1 - (1-weightTi) * swapFee) ;\n    uint256 zar = bmul(bsub(BONE, normalizedWeight), swapFee);\n    tokenAmountIn = bdiv(tokenAmountInAfterFee, bsub(BONE, zar));\n    return tokenAmountIn;\n  }\n\n  /**********************************************************************************************\n    // calcSingleOutGivenPoolIn                                                                  //\n    // tAo = tokenAmountOut            /      /                                             \\\\   //\n    // bO = tokenBalanceOut           /      // pS - (pAi * (1 - eF)) \\     /    1    \\      \\\\  //\n    // pAi = poolAmountIn            | bO - || ----------------------- | ^ | --------- | * b0 || //\n    // ps = poolSupply                \\      \\\\          pS           /     \\(wO / tW)/      //  //\n    // wI = tokenWeightIn      tAo =   \\      \\                                             //   //\n    // tW = totalWeight                    /     /      wO \\       \\                             //\n    // sF = swapFee                    *  | 1 - |  1 - ---- | * sF  |                            //\n    // eF = exitFee                        \\     \\      tW /       /                             //\n    **********************************************************************************************/\n  function calcSingleOutGivenPoolIn(\n    uint256 tokenBalanceOut,\n    uint256 tokenWeightOut,\n    uint256 poolSupply,\n    uint256 totalWeight,\n    uint256 poolAmountIn,\n    uint256 swapFee\n  ) internal pure returns (uint256 tokenAmountOut) {\n    uint256 normalizedWeight = bdiv(tokenWeightOut, totalWeight);\n    // charge exit fee on the pool token side\n    // pAiAfterExitFee = pAi*(1-exitFee)\n    uint256 poolAmountInAfterExitFee = bmul(poolAmountIn, bsub(BONE, EXIT_FEE));\n    uint256 newPoolSupply = bsub(poolSupply, poolAmountInAfterExitFee);\n    uint256 poolRatio = bdiv(newPoolSupply, poolSupply);\n\n    // newBalTo = poolRatio^(1/weightTo) * balTo;\n    uint256 tokenOutRatio = bpow(poolRatio, bdiv(BONE, normalizedWeight));\n    uint256 newTokenBalanceOut = bmul(tokenOutRatio, tokenBalanceOut);\n\n    uint256 tokenAmountOutBeforeSwapFee = bsub(\n      tokenBalanceOut,\n      newTokenBalanceOut\n    );\n\n    // charge swap fee on the output token side\n    //uint tAo = tAoBeforeSwapFee * (1 - (1-weightTo) * swapFee)\n    uint256 zaz = bmul(bsub(BONE, normalizedWeight), swapFee);\n    tokenAmountOut = bmul(tokenAmountOutBeforeSwapFee, bsub(BONE, zaz));\n    return tokenAmountOut;\n  }\n\n  /**********************************************************************************************\n    // calcPoolInGivenSingleOut                                                                  //\n    // pAi = poolAmountIn               // /               tAo             \\\\     / wO \\     \\   //\n    // bO = tokenBalanceOut            // | bO - -------------------------- |\\   | ---- |     \\  //\n    // tAo = tokenAmountOut      pS - ||   \\     1 - ((1 - (tO / tW)) * sF)/  | ^ \\ tW /  * pS | //\n    // ps = poolSupply                 \\\\ -----------------------------------/                /  //\n    // wO = tokenWeightOut  pAi =       \\\\               bO                 /                /   //\n    // tW = totalWeight           -------------------------------------------------------------  //\n    // sF = swapFee                                        ( 1 - eF )                            //\n    // eF = exitFee                                                                              //\n    **********************************************************************************************/\n  function calcPoolInGivenSingleOut(\n    uint256 tokenBalanceOut,\n    uint256 tokenWeightOut,\n    uint256 poolSupply,\n    uint256 totalWeight,\n    uint256 tokenAmountOut,\n    uint256 swapFee\n  ) internal pure returns (uint256 poolAmountIn) {\n    // charge swap fee on the output token side\n    uint256 normalizedWeight = bdiv(tokenWeightOut, totalWeight);\n    //uint tAoBeforeSwapFee = tAo / (1 - (1-weightTo) * swapFee) ;\n    uint256 zoo = bsub(BONE, normalizedWeight);\n    uint256 zar = bmul(zoo, swapFee);\n    uint256 tokenAmountOutBeforeSwapFee = bdiv(tokenAmountOut, bsub(BONE, zar));\n\n    uint256 newTokenBalanceOut = bsub(\n      tokenBalanceOut,\n      tokenAmountOutBeforeSwapFee\n    );\n    uint256 tokenOutRatio = bdiv(newTokenBalanceOut, tokenBalanceOut);\n\n    //uint newPoolSupply = (ratioTo ^ weightTo) * poolSupply;\n    uint256 poolRatio = bpow(tokenOutRatio, normalizedWeight);\n    uint256 newPoolSupply = bmul(poolRatio, poolSupply);\n    uint256 poolAmountInAfterExitFee = bsub(poolSupply, newPoolSupply);\n\n    // charge exit fee on the pool token side\n    // pAi = pAiAfterExitFee/(1-exitFee)\n    poolAmountIn = bdiv(poolAmountInAfterExitFee, bsub(BONE, EXIT_FEE));\n    return poolAmountIn;\n  }\n}\n"
    },
    "contracts/balancer/BNum.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\n\nimport \"./BConst.sol\";\n\n\n/************************************************************************************************\nOriginally from https://github.com/balancer-labs/balancer-core/blob/master/contracts/BNum.sol\n\nThis source code has been modified from the original, which was copied from the github repository\nat commit hash f4ed5d65362a8d6cec21662fb6eae233b0babc1f.\n\nSubject to the GPL-3.0 license\n*************************************************************************************************/\n\n\ncontract BNum is BConst {\n  function btoi(uint256 a) internal pure returns (uint256) {\n    return a / BONE;\n  }\n\n  function bfloor(uint256 a) internal pure returns (uint256) {\n    return btoi(a) * BONE;\n  }\n\n  function badd(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a, \"ERR_ADD_OVERFLOW\");\n    return c;\n  }\n\n  function bsub(uint256 a, uint256 b) internal pure returns (uint256) {\n    (uint256 c, bool flag) = bsubSign(a, b);\n    require(!flag, \"ERR_SUB_UNDERFLOW\");\n    return c;\n  }\n\n  function bsubSign(uint256 a, uint256 b)\n    internal\n    pure\n    returns (uint256, bool)\n  {\n    if (a >= b) {\n      return (a - b, false);\n    } else {\n      return (b - a, true);\n    }\n  }\n\n  function bmul(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c0 = a * b;\n    require(a == 0 || c0 / a == b, \"ERR_MUL_OVERFLOW\");\n    uint256 c1 = c0 + (BONE / 2);\n    require(c1 >= c0, \"ERR_MUL_OVERFLOW\");\n    uint256 c2 = c1 / BONE;\n    return c2;\n  }\n\n  function bdiv(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b != 0, \"ERR_DIV_ZERO\");\n    uint256 c0 = a * BONE;\n    require(a == 0 || c0 / a == BONE, \"ERR_DIV_INTERNAL\"); // bmul overflow\n    uint256 c1 = c0 + (b / 2);\n    require(c1 >= c0, \"ERR_DIV_INTERNAL\"); //  badd require\n    uint256 c2 = c1 / b;\n    return c2;\n  }\n\n  // DSMath.wpow\n  function bpowi(uint256 a, uint256 n) internal pure returns (uint256) {\n    uint256 z = n % 2 != 0 ? a : BONE;\n\n    for (n /= 2; n != 0; n /= 2) {\n      a = bmul(a, a);\n\n      if (n % 2 != 0) {\n        z = bmul(z, a);\n      }\n    }\n    return z;\n  }\n\n  // Compute b^(e.w) by splitting it into (b^e)*(b^0.w).\n  // Use `bpowi` for `b^e` and `bpowK` for k iterations\n  // of approximation of b^0.w\n  function bpow(uint256 base, uint256 exp) internal pure returns (uint256) {\n    require(base >= MIN_BPOW_BASE, \"ERR_BPOW_BASE_TOO_LOW\");\n    require(base <= MAX_BPOW_BASE, \"ERR_BPOW_BASE_TOO_HIGH\");\n\n    uint256 whole = bfloor(exp);\n    uint256 remain = bsub(exp, whole);\n\n    uint256 wholePow = bpowi(base, btoi(whole));\n\n    if (remain == 0) {\n      return wholePow;\n    }\n\n    uint256 partialResult = bpowApprox(base, remain, BPOW_PRECISION);\n    return bmul(wholePow, partialResult);\n  }\n\n  function bpowApprox(\n    uint256 base,\n    uint256 exp,\n    uint256 precision\n  ) internal pure returns (uint256) {\n    // term 0:\n    uint256 a = exp;\n    (uint256 x, bool xneg) = bsubSign(base, BONE);\n    uint256 term = BONE;\n    uint256 sum = term;\n    bool negative = false;\n\n    // term(k) = numer / denom\n    //         = (product(a - i - 1, i=1-->k) * x^k) / (k!)\n    // each iteration, multiply previous term by (a-(k-1)) * x / k\n    // continue until term is less than precision\n    for (uint256 i = 1; term >= precision; i++) {\n      uint256 bigK = i * BONE;\n      (uint256 c, bool cneg) = bsubSign(a, bsub(bigK, BONE));\n      term = bmul(term, bmul(c, x));\n      term = bdiv(term, bigK);\n      if (term == 0) break;\n\n      if (xneg) negative = !negative;\n      if (cneg) negative = !negative;\n      if (negative) {\n        sum = bsub(sum, term);\n      } else {\n        sum = badd(sum, term);\n      }\n    }\n\n    return sum;\n  }\n}\n"
    },
    "contracts/balancer/BToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\n\nimport \"./BNum.sol\";\n\n\n/************************************************************************************************\nOriginally from https://github.com/balancer-labs/balancer-core/blob/master/contracts/BToken.sol\n\nThis source code has been modified from the original, which was copied from the github repository\nat commit hash f4ed5d65362a8d6cec21662fb6eae233b0babc1f.\n\nSubject to the GPL-3.0 license\n*************************************************************************************************/\n\n\n// Highly opinionated token implementation\ninterface IERC20 {\n  event Approval(address indexed src, address indexed dst, uint256 amt);\n  event Transfer(address indexed src, address indexed dst, uint256 amt);\n\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);\n\n  function decimals() external view returns (uint8);\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address whom) external view returns (uint256);\n\n  function allowance(address src, address dst) external view returns (uint256);\n\n  function approve(address dst, uint256 amt) external returns (bool);\n\n  function transfer(address dst, uint256 amt) external returns (bool);\n\n  function transferFrom(\n    address src,\n    address dst,\n    uint256 amt\n  ) external returns (bool);\n}\n\n\ncontract BTokenBase is BNum {\n  mapping(address => uint256) internal _balance;\n  mapping(address => mapping(address => uint256)) internal _allowance;\n  uint256 internal _totalSupply;\n\n  event Approval(address indexed src, address indexed dst, uint256 amt);\n  event Transfer(address indexed src, address indexed dst, uint256 amt);\n\n  function _mint(uint256 amt) internal {\n    _balance[address(this)] = badd(_balance[address(this)], amt);\n    _totalSupply = badd(_totalSupply, amt);\n    emit Transfer(address(0), address(this), amt);\n  }\n\n  function _burn(uint256 amt) internal {\n    require(_balance[address(this)] >= amt, \"ERR_INSUFFICIENT_BAL\");\n    _balance[address(this)] = bsub(_balance[address(this)], amt);\n    _totalSupply = bsub(_totalSupply, amt);\n    emit Transfer(address(this), address(0), amt);\n  }\n\n  function _move(\n    address src,\n    address dst,\n    uint256 amt\n  ) internal {\n    require(_balance[src] >= amt, \"ERR_INSUFFICIENT_BAL\");\n    _balance[src] = bsub(_balance[src], amt);\n    _balance[dst] = badd(_balance[dst], amt);\n    emit Transfer(src, dst, amt);\n  }\n\n  function _push(address to, uint256 amt) internal {\n    _move(address(this), to, amt);\n  }\n\n  function _pull(address from, uint256 amt) internal {\n    _move(from, address(this), amt);\n  }\n}\n\n\ncontract BToken is BTokenBase, IERC20 {\n  uint8 private constant DECIMALS = 18;\n  string private _name;\n  string private _symbol;\n\n  function _initializeToken(string memory name, string memory symbol) internal {\n    require(\n      bytes(_name).length == 0 &&\n      bytes(name).length != 0 &&\n      bytes(symbol).length != 0,\n      \"ERR_BTOKEN_INITIALIZED\"\n    );\n    _name = name;\n    _symbol = symbol;\n  }\n\n  function name()\n    external\n    override\n    view\n    returns (string memory)\n  {\n    return _name;\n  }\n\n  function symbol()\n    external\n    override\n    view\n    returns (string memory)\n  {\n    return _symbol;\n  }\n\n  function decimals()\n    external\n    override\n    view\n    returns (uint8)\n  {\n    return DECIMALS;\n  }\n\n  function allowance(address src, address dst)\n    external\n    override\n    view\n    returns (uint256)\n  {\n    return _allowance[src][dst];\n  }\n\n  function balanceOf(address whom) external override view returns (uint256) {\n    return _balance[whom];\n  }\n\n  function totalSupply() public override view returns (uint256) {\n    return _totalSupply;\n  }\n\n  function approve(address dst, uint256 amt) external override returns (bool) {\n    _allowance[msg.sender][dst] = amt;\n    emit Approval(msg.sender, dst, amt);\n    return true;\n  }\n\n  function increaseApproval(address dst, uint256 amt) external returns (bool) {\n    _allowance[msg.sender][dst] = badd(_allowance[msg.sender][dst], amt);\n    emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\n    return true;\n  }\n\n  function decreaseApproval(address dst, uint256 amt) external returns (bool) {\n    uint256 oldValue = _allowance[msg.sender][dst];\n    if (amt > oldValue) {\n      _allowance[msg.sender][dst] = 0;\n    } else {\n      _allowance[msg.sender][dst] = bsub(oldValue, amt);\n    }\n    emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\n    return true;\n  }\n\n  function transfer(address dst, uint256 amt) external override returns (bool) {\n    _move(msg.sender, dst, amt);\n    return true;\n  }\n\n  function transferFrom(\n    address src,\n    address dst,\n    uint256 amt\n  ) external override returns (bool) {\n    require(\n      msg.sender == src || amt <= _allowance[src][msg.sender],\n      \"ERR_BTOKEN_BAD_CALLER\"\n    );\n    _move(src, dst, amt);\n    if (msg.sender != src && _allowance[src][msg.sender] != uint256(-1)) {\n      _allowance[src][msg.sender] = bsub(_allowance[src][msg.sender], amt);\n      emit Approval(msg.sender, dst, _allowance[src][msg.sender]);\n    }\n    return true;\n  }\n}\n"
    },
    "contracts/balancer/IndexPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\n/* ========== Internal Inheritance ========== */\nimport \"./BToken.sol\";\nimport \"./BMath.sol\";\n\n/* ========== Internal Interfaces ========== */\nimport \"../interfaces/IFlashLoanRecipient.sol\";\nimport \"../interfaces/IIndexPool.sol\";\n\n/************************************************************************************************\nOriginally from https://github.com/balancer-labs/balancer-core/blob/master/contracts/BPool.sol\n\nThis source code has been modified from the original, which was copied from the github repository\nat commit hash f4ed5d65362a8d6cec21662fb6eae233b0babc1f.\n\nSubject to the GPL-3.0 license\n*************************************************************************************************/\n\n\ncontract IndexPool is BToken, BMath, IIndexPool {\n\n/* ==========  EVENTS  ========== */\n\n  /** @dev Emitted when tokens are swapped. */\n  event LOG_SWAP(\n    address indexed caller,\n    address indexed tokenIn,\n    address indexed tokenOut,\n    uint256 tokenAmountIn,\n    uint256 tokenAmountOut\n  );\n\n  /** @dev Emitted when underlying tokens are deposited for pool tokens. */\n  event LOG_JOIN(\n    address indexed caller,\n    address indexed tokenIn,\n    uint256 tokenAmountIn\n  );\n\n  /** @dev Emitted when pool tokens are burned for underlying. */\n  event LOG_EXIT(\n    address indexed caller,\n    address indexed tokenOut,\n    uint256 tokenAmountOut\n  );\n\n  /** @dev Emitted when a token's weight updates. */\n  event LOG_DENORM_UPDATED(address indexed token, uint256 newDenorm);\n\n  /** @dev Emitted when a token's desired weight is set. */\n  event LOG_DESIRED_DENORM_SET(address indexed token, uint256 desiredDenorm);\n\n  /** @dev Emitted when a token is unbound from the pool. */\n  event LOG_TOKEN_REMOVED(address token);\n\n  /** @dev Emitted when a token is unbound from the pool. */\n  event LOG_TOKEN_ADDED(\n    address indexed token,\n    uint256 desiredDenorm,\n    uint256 minimumBalance\n  );\n\n  /** @dev Emitted when a token's minimum balance is updated. */\n  event LOG_MINIMUM_BALANCE_UPDATED(address token, uint256 minimumBalance);\n\n  /** @dev Emitted when a token reaches its minimum balance. */\n  event LOG_TOKEN_READY(address indexed token);\n\n  /** @dev Emitted when public trades are enabled. */\n  event LOG_PUBLIC_SWAP_ENABLED();\n\n  /** @dev Emitted when the maximum tokens value is updated. */\n  event LOG_MAX_TOKENS_UPDATED(uint256 maxPoolTokens);\n\n  /** @dev Emitted when the swap fee is updated. */\n  event LOG_SWAP_FEE_UPDATED(uint256 swapFee);\n\n/* ==========  Modifiers  ========== */\n\n  modifier _lock_ {\n    require(!_mutex, \"ERR_REENTRY\");\n    _mutex = true;\n    _;\n    _mutex = false;\n  }\n\n  modifier _viewlock_() {\n    require(!_mutex, \"ERR_REENTRY\");\n    _;\n  }\n\n  modifier _control_ {\n    require(msg.sender == _controller, \"ERR_NOT_CONTROLLER\");\n    _;\n  }\n\n  modifier _public_ {\n    require(_publicSwap, \"ERR_NOT_PUBLIC\");\n    _;\n  }\n\n/* ==========  Storage  ========== */\n\n  bool internal _mutex;\n\n  // Account with CONTROL role. Able to modify the swap fee,\n  // adjust token weights, bind and unbind tokens and lock\n  // public swaps & joins.\n  address internal _controller;\n\n  // Contract that handles unbound tokens.\n  TokenUnbindHandler internal _unbindHandler;\n\n  // True if PUBLIC can call SWAP & JOIN functions\n  bool internal _publicSwap;\n\n  // `setSwapFee` requires CONTROL\n  uint256 internal _swapFee;\n\n  // Array of underlying tokens in the pool.\n  address[] internal _tokens;\n\n  // Internal records of the pool's underlying tokens\n  mapping(address => Record) internal _records;\n\n  // Total denormalized weight of the pool.\n  uint256 internal _totalWeight;\n\n  // Minimum balances for tokens which have been added without the\n  // requisite initial balance.\n  mapping(address => uint256) internal _minimumBalances;\n\n  // Maximum LP tokens that can be bound.\n  // Used in alpha to restrict the economic impact of a catastrophic\n  // failure. It can be gradually increased as the pool continues to\n  // not be exploited.\n  uint256 internal _maxPoolTokens;\n\n/* ==========  Controls  ========== */\n\n  /**\n   * @dev Sets the controller address and the token name & symbol.\n   *\n   * Note: This saves on storage costs for multi-step pool deployment.\n   *\n   * @param controller Controller of the pool\n   * @param name Name of the pool token\n   * @param symbol Symbol of the pool token\n   */\n  function configure(\n    address controller,\n    string calldata name,\n    string calldata symbol\n  ) external override {\n    require(_controller == address(0), \"ERR_CONFIGURED\");\n    require(controller != address(0), \"ERR_NULL_ADDRESS\");\n    _controller = controller;\n    // default fee is 2.5%\n    _swapFee = BONE / 40;\n    _initializeToken(name, symbol);\n  }\n\n  /**\n   * @dev Sets up the initial assets for the pool.\n   *\n   * Note: `tokenProvider` must have approved the pool to transfer the\n   * corresponding `balances` of `tokens`.\n   *\n   * @param tokens Underlying tokens to initialize the pool with\n   * @param balances Initial balances to transfer\n   * @param denorms Initial denormalized weights for the tokens\n   * @param tokenProvider Address to transfer the balances from\n   */\n  function initialize(\n    address[] calldata tokens,\n    uint256[] calldata balances,\n    uint96[] calldata denorms,\n    address tokenProvider,\n    address unbindHandler\n  )\n    external\n    override\n    _control_\n  {\n    require(_tokens.length == 0, \"ERR_INITIALIZED\");\n    uint256 len = tokens.length;\n    require(len >= MIN_BOUND_TOKENS, \"ERR_MIN_TOKENS\");\n    require(len <= MAX_BOUND_TOKENS, \"ERR_MAX_TOKENS\");\n    require(balances.length == len && denorms.length == len, \"ERR_ARR_LEN\");\n    uint256 totalWeight = 0;\n    for (uint256 i = 0; i < len; i++) {\n      address token = tokens[i];\n      uint96 denorm = denorms[i];\n      uint256 balance = balances[i];\n      require(denorm >= MIN_WEIGHT, \"ERR_MIN_WEIGHT\");\n      require(denorm <= MAX_WEIGHT, \"ERR_MAX_WEIGHT\");\n      require(balance >= MIN_BALANCE, \"ERR_MIN_BALANCE\");\n      _records[token] = Record({\n        bound: true,\n        ready: true,\n        lastDenormUpdate: uint40(now),\n        denorm: denorm,\n        desiredDenorm: denorm,\n        index: uint8(i),\n        balance: balance\n      });\n      _tokens.push(token);\n      totalWeight = badd(totalWeight, denorm);\n      _pullUnderlying(token, tokenProvider, balance);\n    }\n    require(totalWeight <= MAX_TOTAL_WEIGHT, \"ERR_MAX_TOTAL_WEIGHT\");\n    _totalWeight = totalWeight;\n    _publicSwap = true;\n    emit LOG_PUBLIC_SWAP_ENABLED();\n    _mintPoolShare(INIT_POOL_SUPPLY);\n    _pushPoolShare(tokenProvider, INIT_POOL_SUPPLY);\n    _unbindHandler = TokenUnbindHandler(unbindHandler);\n  }\n\n  /**\n   * @dev Sets the maximum number of pool tokens that can be minted.\n   *\n   * This value will be used in the alpha to limit the maximum damage\n   * that can be caused by a catastrophic error. It can be gradually\n   * increased as the pool continues to not be exploited.\n   *\n   * If it is set to 0, the limit will be removed.\n   */\n  function setMaxPoolTokens(uint256 maxPoolTokens) external override _control_ {\n    _maxPoolTokens = maxPoolTokens;\n    emit LOG_MAX_TOKENS_UPDATED(maxPoolTokens);\n  }\n\n/* ==========  Configuration Actions  ========== */\n\n  /**\n   * @dev Set the swap fee.\n   * Note: Swap fee must be between 0.0001% and 10%\n   */\n  function setSwapFee(uint256 swapFee) external override _control_ {\n    require(swapFee >= MIN_FEE, \"ERR_MIN_FEE\");\n    require(swapFee <= MAX_FEE, \"ERR_MAX_FEE\");\n    _swapFee = swapFee;\n    emit LOG_SWAP_FEE_UPDATED(swapFee);\n  }\n\n/* ==========  Token Management Actions  ========== */\n\n  /**\n   * @dev Sets the desired weights for the pool tokens, which\n   * will be adjusted over time as they are swapped.\n   *\n   * Note: This does not check for duplicate tokens or that the total\n   * of the desired weights is equal to the target total weight (25).\n   * Those assumptions should be met in the controller. Further, the\n   * provided tokens should only include the tokens which are not set\n   * for removal.\n   */\n  function reweighTokens(\n    address[] calldata tokens,\n    uint96[] calldata desiredDenorms\n  )\n    external\n    override\n    _lock_\n    _control_\n  {\n    uint256 len = tokens.length;\n    require(desiredDenorms.length == len, \"ERR_ARR_LEN\");\n    for (uint256 i = 0; i < len; i++)\n      _setDesiredDenorm(tokens[i], desiredDenorms[i]);\n  }\n\n  /**\n   * @dev Update the underlying assets held by the pool and their associated\n   * weights. Tokens which are not currently bound will be gradually added\n   * as they are swapped in to reach the provided minimum balances, which must\n   * be an amount of tokens worth the minimum weight of the total pool value.\n   * If a currently bound token is not received in this call, the token's\n   * desired weight will be set to 0.\n   */\n  function reindexTokens(\n    address[] calldata tokens,\n    uint96[] calldata desiredDenorms,\n    uint256[] calldata minimumBalances\n  )\n    external\n    override\n    _lock_\n    _control_\n  {\n    uint256 len = tokens.length;\n    require(\n      desiredDenorms.length == len && minimumBalances.length == len,\n      \"ERR_ARR_LEN\"\n    );\n    // This size may not be the same as the input size, as it is possible\n    // to temporarily exceed the index size while tokens are being phased in\n    // or out.\n    uint256 tLen = _tokens.length;\n    bool[] memory receivedIndices = new bool[](tLen);\n    // We need to read token records in two separate loops, so\n    // write them to memory to avoid duplicate storage reads.\n    Record[] memory records = new Record[](len);\n    // Read all the records from storage and mark which of the existing tokens\n    // were represented in the reindex call.\n    for (uint256 i = 0; i < len; i++) {\n      records[i] = _records[tokens[i]];\n      if (records[i].bound) receivedIndices[records[i].index] = true;\n    }\n    // If any bound tokens were not sent in this call, set their desired weights to 0.\n    for (uint256 i = 0; i < tLen; i++) {\n      if (!receivedIndices[i]) {\n        _setDesiredDenorm(_tokens[i], 0);\n      }\n    }\n    for (uint256 i = 0; i < len; i++) {\n      address token = tokens[i];\n      // If an input weight is less than the minimum weight, use that instead.\n      uint96 denorm = desiredDenorms[i];\n      if (denorm < MIN_WEIGHT) denorm = uint96(MIN_WEIGHT);\n      if (!records[i].bound) {\n        // If the token is not bound, bind it.\n        _bind(token, minimumBalances[i], denorm);\n      } else {\n        _setDesiredDenorm(token, denorm);\n      }\n    }\n  }\n\n  /**\n   * @dev Updates the minimum balance for an uninitialized token.\n   * This becomes useful if a token's external price significantly\n   * rises after being bound, since the pool can not send a token\n   * out until it reaches the minimum balance.\n   */\n  function setMinimumBalance(\n    address token,\n    uint256 minimumBalance\n  )\n    external\n    override\n    _control_\n  {\n    Record storage record = _records[token];\n    require(record.bound, \"ERR_NOT_BOUND\");\n    require(!record.ready, \"ERR_READY\");\n    _minimumBalances[token] = minimumBalance;\n    emit LOG_MINIMUM_BALANCE_UPDATED(token, minimumBalance);\n  }\n\n/* ==========  Liquidity Provider Actions  ========== */\n\n  /**\n   * @dev Mint new pool tokens by providing the proportional amount of each\n   * underlying token's balance relative to the proportion of pool tokens minted.\n   *\n   * For any underlying tokens which are not initialized, the caller must provide\n   * the proportional share of the minimum balance for the token rather than the\n   * actual balance.\n   *\n   * @param poolAmountOut Amount of pool tokens to mint\n   * @param maxAmountsIn Maximum amount of each token to pay in the same\n   * order as the pool's _tokens list.\n   */\n  function joinPool(uint256 poolAmountOut, uint256[] calldata maxAmountsIn)\n    external\n    override\n    _lock_\n    _public_\n  {\n    uint256 poolTotal = totalSupply();\n    uint256 ratio = bdiv(poolAmountOut, poolTotal);\n    require(ratio != 0, \"ERR_MATH_APPROX\");\n    require(maxAmountsIn.length == _tokens.length, \"ERR_ARR_LEN\");\n\n    uint256 maxPoolTokens = _maxPoolTokens;\n    if (maxPoolTokens > 0) {\n      require(\n        badd(poolTotal, poolAmountOut) <= maxPoolTokens,\n        \"ERR_MAX_POOL_TOKENS\"\n      );\n    }\n\n    for (uint256 i = 0; i < maxAmountsIn.length; i++) {\n      address t = _tokens[i];\n      (Record memory record, uint256 realBalance) = _getInputToken(t);\n      uint256 tokenAmountIn = bmul(ratio, record.balance);\n      require(tokenAmountIn != 0, \"ERR_MATH_APPROX\");\n      require(tokenAmountIn <= maxAmountsIn[i], \"ERR_LIMIT_IN\");\n      _updateInputToken(t, record, badd(realBalance, tokenAmountIn));\n      emit LOG_JOIN(msg.sender, t, tokenAmountIn);\n      _pullUnderlying(t, msg.sender, tokenAmountIn);\n    }\n    _mintPoolShare(poolAmountOut);\n    _pushPoolShare(msg.sender, poolAmountOut);\n  }\n\n  /**\n   * @dev Pay `tokenAmountIn` of `tokenIn` to mint at least `minPoolAmountOut`\n   * pool tokens.\n   *\n   * The pool implicitly swaps `(1- weightTokenIn) * tokenAmountIn` to the other\n   * underlying tokens. Thus a swap fee is charged against the input tokens.\n   *\n   * @param tokenIn Token to send the pool\n   * @param tokenAmountIn Exact amount of `tokenIn` to pay\n   * @param minPoolAmountOut Minimum amount of pool tokens to mint\n   * @return poolAmountOut - Amount of pool tokens minted\n   */\n  function joinswapExternAmountIn(\n    address tokenIn,\n    uint256 tokenAmountIn,\n    uint256 minPoolAmountOut\n  )\n    external\n    override\n    _lock_\n    _public_\n    returns (uint256/* poolAmountOut */)\n  {\n    (Record memory inRecord, uint256 realInBalance) = _getInputToken(tokenIn);\n\n    require(tokenAmountIn != 0, \"ERR_ZERO_IN\");\n\n    require(\n      tokenAmountIn <= bmul(inRecord.balance, MAX_IN_RATIO),\n      \"ERR_MAX_IN_RATIO\"\n    );\n\n    uint256 poolAmountOut = calcPoolOutGivenSingleIn(\n      inRecord.balance,\n      inRecord.denorm,\n      _totalSupply,\n      _totalWeight,\n      tokenAmountIn,\n      _swapFee\n    );\n\n    uint256 maxPoolTokens = _maxPoolTokens;\n    if (maxPoolTokens > 0) {\n      require(\n        badd(_totalSupply, poolAmountOut) <= maxPoolTokens,\n        \"ERR_MAX_POOL_TOKENS\"\n      );\n    }\n\n    require(poolAmountOut >= minPoolAmountOut, \"ERR_LIMIT_OUT\");\n\n    _updateInputToken(tokenIn, inRecord, badd(realInBalance, tokenAmountIn));\n\n    emit LOG_JOIN(msg.sender, tokenIn, tokenAmountIn);\n\n    _mintPoolShare(poolAmountOut);\n    _pushPoolShare(msg.sender, poolAmountOut);\n    _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\n\n    return poolAmountOut;\n  }\n\n  /**\n   * @dev Pay up to `maxAmountIn` of `tokenIn` to mint exactly `poolAmountOut`.\n   *\n   * The pool implicitly swaps `(1- weightTokenIn) * tokenAmountIn` to the other\n   * underlying tokens. Thus a swap fee is charged against the input tokens.\n   *\n   * @param tokenIn Token to send the pool\n   * @param poolAmountOut Exact amount of pool tokens to mint\n   * @param maxAmountIn Maximum amount of `tokenIn` to pay\n   * @return tokenAmountIn - Amount of `tokenIn` paid\n   */\n  function joinswapPoolAmountOut(\n    address tokenIn,\n    uint256 poolAmountOut,\n    uint256 maxAmountIn\n  )\n    external\n    override\n    _lock_\n    _public_\n    returns (uint256/* tokenAmountIn */)\n  {\n    uint256 maxPoolTokens = _maxPoolTokens;\n    if (maxPoolTokens > 0) {\n      require(\n        badd(_totalSupply, poolAmountOut) <= maxPoolTokens,\n        \"ERR_MAX_POOL_TOKENS\"\n      );\n    }\n\n    (Record memory inRecord, uint256 realInBalance) = _getInputToken(tokenIn);\n\n    uint256 tokenAmountIn = calcSingleInGivenPoolOut(\n      inRecord.balance,\n      inRecord.denorm,\n      _totalSupply,\n      _totalWeight,\n      poolAmountOut,\n      _swapFee\n    );\n\n    require(tokenAmountIn != 0, \"ERR_MATH_APPROX\");\n    require(tokenAmountIn <= maxAmountIn, \"ERR_LIMIT_IN\");\n\n    require(\n      tokenAmountIn <= bmul(inRecord.balance, MAX_IN_RATIO),\n      \"ERR_MAX_IN_RATIO\"\n    );\n\n    _updateInputToken(tokenIn, inRecord, badd(realInBalance, tokenAmountIn));\n\n    emit LOG_JOIN(msg.sender, tokenIn, tokenAmountIn);\n\n    _mintPoolShare(poolAmountOut);\n    _pushPoolShare(msg.sender, poolAmountOut);\n    _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\n\n    return tokenAmountIn;\n  }\n\n  /**\n   * @dev Burns `poolAmountIn` pool tokens in exchange for the amounts of each\n   * underlying token's balance proportional to the ratio of tokens burned to\n   * total pool supply. The amount of each token transferred to the caller must\n   * be greater than or equal to the associated minimum output amount from the\n   * `minAmountsOut` array.\n   *\n   * @param poolAmountIn Exact amount of pool tokens to burn\n   * @param minAmountsOut Minimum amount of each token to receive, in the same\n   * order as the pool's _tokens list.\n   */\n  function exitPool(uint256 poolAmountIn, uint256[] calldata minAmountsOut)\n    external\n    override\n    _lock_\n  {\n    require(minAmountsOut.length == _tokens.length, \"ERR_ARR_LEN\");\n    uint256 poolTotal = totalSupply();\n    uint256 exitFee = bmul(poolAmountIn, EXIT_FEE);\n    uint256 pAiAfterExitFee = bsub(poolAmountIn, exitFee);\n    uint256 ratio = bdiv(pAiAfterExitFee, poolTotal);\n    require(ratio != 0, \"ERR_MATH_APPROX\");\n\n    _pullPoolShare(msg.sender, poolAmountIn);\n    _pushPoolShare(_controller, exitFee);\n    _burnPoolShare(pAiAfterExitFee);\n    for (uint256 i = 0; i < minAmountsOut.length; i++) {\n      address t = _tokens[i];\n      Record memory record = _records[t];\n      if (record.ready) {\n        uint256 tokenAmountOut = bmul(ratio, record.balance);\n        require(tokenAmountOut != 0, \"ERR_MATH_APPROX\");\n        require(tokenAmountOut >= minAmountsOut[i], \"ERR_LIMIT_OUT\");\n\n        _records[t].balance = bsub(record.balance, tokenAmountOut);\n        emit LOG_EXIT(msg.sender, t, tokenAmountOut);\n        _pushUnderlying(t, msg.sender, tokenAmountOut);\n      } else {\n        // If the token is not initialized, it can not exit the pool.\n        require(minAmountsOut[i] == 0, \"ERR_OUT_NOT_READY\");\n      }\n    }\n  }\n\n  /**\n   * @dev Burns `poolAmountIn` pool tokens in exchange for at least `minAmountOut`\n   * of `tokenOut`. Returns the number of tokens sent to the caller.\n   *\n   * The pool implicitly burns the tokens for all underlying tokens and swaps them\n   * to the desired output token. A swap fee is charged against the output tokens.\n   *\n   * @param tokenOut Token to receive\n   * @param poolAmountIn Exact amount of pool tokens to burn\n   * @param minAmountOut Minimum amount of `tokenOut` to receive\n   * @return tokenAmountOut - Amount of `tokenOut` received\n   */\n  function exitswapPoolAmountIn(\n    address tokenOut,\n    uint256 poolAmountIn,\n    uint256 minAmountOut\n  )\n    external\n    override\n    _lock_\n    returns (uint256/* tokenAmountOut */)\n  {\n    Record memory outRecord = _getOutputToken(tokenOut);\n\n    uint256 tokenAmountOut = calcSingleOutGivenPoolIn(\n      outRecord.balance,\n      outRecord.denorm,\n      _totalSupply,\n      _totalWeight,\n      poolAmountIn,\n      _swapFee\n    );\n\n    require(tokenAmountOut >= minAmountOut, \"ERR_LIMIT_OUT\");\n\n    require(\n      tokenAmountOut <= bmul(outRecord.balance, MAX_OUT_RATIO),\n      \"ERR_MAX_OUT_RATIO\"\n    );\n\n    _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\n    _records[tokenOut].balance = bsub(outRecord.balance, tokenAmountOut);\n    _decreaseDenorm(outRecord, tokenOut);\n    uint256 exitFee = bmul(poolAmountIn, EXIT_FEE);\n\n    emit LOG_EXIT(msg.sender, tokenOut, tokenAmountOut);\n\n    _pullPoolShare(msg.sender, poolAmountIn);\n    _burnPoolShare(bsub(poolAmountIn, exitFee));\n    _pushPoolShare(_controller, exitFee);\n\n    return tokenAmountOut;\n  }\n\n  /**\n   * @dev Burn up to `maxPoolAmountIn` for exactly `tokenAmountOut` of `tokenOut`.\n   * Returns the number of pool tokens burned.\n   *\n   * The pool implicitly burns the tokens for all underlying tokens and swaps them\n   * to the desired output token. A swap fee is charged against the output tokens.\n   *\n   * @param tokenOut Token to receive\n   * @param tokenAmountOut Exact amount of `tokenOut` to receive\n   * @param maxPoolAmountIn Maximum amount of pool tokens to burn\n   * @return poolAmountIn - Amount of pool tokens burned\n   */\n  function exitswapExternAmountOut(\n    address tokenOut,\n    uint256 tokenAmountOut,\n    uint256 maxPoolAmountIn\n  )\n    external\n    override\n    _lock_\n    returns (uint256/* poolAmountIn */)\n  {\n    Record memory outRecord = _getOutputToken(tokenOut);\n    require(\n      tokenAmountOut <= bmul(outRecord.balance, MAX_OUT_RATIO),\n      \"ERR_MAX_OUT_RATIO\"\n    );\n\n    uint256 poolAmountIn = calcPoolInGivenSingleOut(\n      outRecord.balance,\n      outRecord.denorm,\n      _totalSupply,\n      _totalWeight,\n      tokenAmountOut,\n      _swapFee\n    );\n\n    require(poolAmountIn != 0, \"ERR_MATH_APPROX\");\n    require(poolAmountIn <= maxPoolAmountIn, \"ERR_LIMIT_IN\");\n\n    _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\n    _records[tokenOut].balance = bsub(outRecord.balance, tokenAmountOut);\n    _decreaseDenorm(outRecord, tokenOut);\n\n    uint256 exitFee = bmul(poolAmountIn, EXIT_FEE);\n\n    emit LOG_EXIT(msg.sender, tokenOut, tokenAmountOut);\n\n    _pullPoolShare(msg.sender, poolAmountIn);\n    _burnPoolShare(bsub(poolAmountIn, exitFee));\n    _pushPoolShare(_controller, exitFee);\n\n    return poolAmountIn;\n  }\n\n/* ==========  Other  ========== */\n\n  /**\n   * @dev Absorb any tokens that have been sent to the pool.\n   * If the token is not bound, it will be sent to the unbound\n   * token handler.\n   */\n  function gulp(address token) external override _lock_ {\n    Record storage record = _records[token];\n    uint256 balance = IERC20(token).balanceOf(address(this));\n    if (record.bound) {\n      if (!record.ready) {\n        uint256 minimumBalance = _minimumBalances[token];\n        if (balance >= minimumBalance) {\n          _minimumBalances[token] = 0;\n          record.ready = true;\n          emit LOG_TOKEN_READY(token);\n          uint256 additionalBalance = bsub(balance, minimumBalance);\n          uint256 balRatio = bdiv(additionalBalance, minimumBalance);\n          uint96 newDenorm = uint96(badd(MIN_WEIGHT, bmul(MIN_WEIGHT, balRatio)));\n          record.denorm = newDenorm;\n          record.lastDenormUpdate = uint40(now);\n          _totalWeight = badd(_totalWeight, newDenorm);\n          emit LOG_DENORM_UPDATED(token, record.denorm);\n        }\n      }\n      _records[token].balance = balance;\n    } else {\n      _pushUnderlying(token, address(_unbindHandler), balance);\n      _unbindHandler.handleUnbindToken(token, balance);\n    }\n  }\n\n/* ==========  Flash Loan  ========== */\n\n  /**\n   * @dev Execute a flash loan, transferring `amount` of `token` to `recipient`.\n   * `amount` must be repaid with `swapFee` interest by the end of the transaction.\n   *\n   * @param recipient Must implement the IFlashLoanRecipient interface\n   * @param token Token to borrow\n   * @param amount Amount to borrow\n   * @param data Data to send to the recipient in `receiveFlashLoan` call\n   */\n  function flashBorrow(\n    address recipient,\n    address token,\n    uint256 amount,\n    bytes calldata data\n  )\n    external\n    override\n    _lock_\n  {\n    Record storage record = _records[token];\n    require(record.bound, \"ERR_NOT_BOUND\");\n    uint256 balStart = IERC20(token).balanceOf(address(this));\n    require(balStart >= amount, \"ERR_INSUFFICIENT_BAL\");\n    _pushUnderlying(token, address(recipient), amount);\n    uint256 fee = bmul(balStart, _swapFee);\n    uint256 amountDue = badd(amount, fee);\n    IFlashLoanRecipient(recipient).receiveFlashLoan(token, amount, amountDue, data);\n    uint256 balEnd = IERC20(token).balanceOf(address(this));\n    require(\n      balEnd > balStart && balEnd >= amountDue,\n      \"ERR_INSUFFICIENT_PAYMENT\"\n    );\n    record.balance = balEnd;\n    // If the payment brings the token above its minimum balance,\n    // clear the minimum and mark the token as ready.\n    if (!record.ready) {\n      uint256 minimumBalance = _minimumBalances[token];\n      if (balEnd >= minimumBalance) {\n        _minimumBalances[token] = 0;\n        record.ready = true;\n        emit LOG_TOKEN_READY(token);\n        uint256 additionalBalance = bsub(balEnd, minimumBalance);\n        uint256 balRatio = bdiv(additionalBalance, minimumBalance);\n        uint96 newDenorm = uint96(badd(MIN_WEIGHT, bmul(MIN_WEIGHT, balRatio)));\n        record.denorm = newDenorm;\n        record.lastDenormUpdate = uint40(now);\n        _totalWeight = badd(_totalWeight, newDenorm);\n        emit LOG_DENORM_UPDATED(token, record.denorm);\n      }\n    }\n  }\n\n/* ==========  Token Swaps  ========== */\n\n  /**\n   * @dev Execute a token swap with a specified amount of input\n   * tokens and a minimum amount of output tokens.\n   *\n   * Note: Will revert if `tokenOut` is uninitialized.\n   *\n   * @param tokenIn Token to swap in\n   * @param tokenAmountIn Exact amount of `tokenIn` to swap in\n   * @param tokenOut Token to swap out\n   * @param minAmountOut Minimum amount of `tokenOut` to receive\n   * @param maxPrice Maximum ratio of input to output tokens\n   * @return (tokenAmountOut, spotPriceAfter)\n   */\n  function swapExactAmountIn(\n    address tokenIn,\n    uint256 tokenAmountIn,\n    address tokenOut,\n    uint256 minAmountOut,\n    uint256 maxPrice\n  )\n    external\n    override\n    _lock_\n    _public_\n    returns (uint256/* tokenAmountOut */, uint256/* spotPriceAfter */)\n  {\n    (Record memory inRecord, uint256 realInBalance) = _getInputToken(tokenIn);\n    Record memory outRecord = _getOutputToken(tokenOut);\n\n    require(\n      tokenAmountIn <= bmul(inRecord.balance, MAX_IN_RATIO),\n      \"ERR_MAX_IN_RATIO\"\n    );\n\n    uint256 spotPriceBefore = calcSpotPrice(\n      inRecord.balance,\n      inRecord.denorm,\n      outRecord.balance,\n      outRecord.denorm,\n      _swapFee\n    );\n    require(spotPriceBefore <= maxPrice, \"ERR_BAD_LIMIT_PRICE\");\n\n    uint256 tokenAmountOut = calcOutGivenIn(\n      inRecord.balance,\n      inRecord.denorm,\n      outRecord.balance,\n      outRecord.denorm,\n      tokenAmountIn,\n      _swapFee\n    );\n\n    require(tokenAmountOut >= minAmountOut, \"ERR_LIMIT_OUT\");\n\n    _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\n    _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\n\n    realInBalance = badd(realInBalance, tokenAmountIn);\n    _updateInputToken(tokenIn, inRecord, realInBalance);\n    if (inRecord.ready) {\n      inRecord.balance = realInBalance;\n    }\n    // Update the in-memory record for the spotPriceAfter calculation,\n    // then update the storage record with the local balance.\n    outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\n    _records[tokenOut].balance = outRecord.balance;\n    // If needed, update the output token's weight.\n    _decreaseDenorm(outRecord, tokenOut);\n\n    uint256 spotPriceAfter = calcSpotPrice(\n      inRecord.balance,\n      inRecord.denorm,\n      outRecord.balance,\n      outRecord.denorm,\n      _swapFee\n    );\n\n    require(spotPriceAfter >= spotPriceBefore, \"ERR_MATH_APPROX_2\");\n    require(spotPriceAfter <= maxPrice, \"ERR_LIMIT_PRICE\");\n    require(\n      spotPriceBefore <= bdiv(tokenAmountIn, tokenAmountOut),\n      \"ERR_MATH_APPROX\"\n    );\n\n    emit LOG_SWAP(msg.sender, tokenIn, tokenOut, tokenAmountIn, tokenAmountOut);\n\n    return (tokenAmountOut, spotPriceAfter);\n  }\n\n  /**\n   * @dev Trades at most `maxAmountIn` of `tokenIn` for exactly `tokenAmountOut`\n   * of `tokenOut`.\n   *\n   * Returns the actual input amount and the new spot price after the swap,\n   * which can not exceed `maxPrice`.\n   *\n   * @param tokenIn Token to swap in\n   * @param maxAmountIn Maximum amount of `tokenIn` to pay\n   * @param tokenOut Token to swap out\n   * @param tokenAmountOut Exact amount of `tokenOut` to receive\n   * @param maxPrice Maximum ratio of input to output tokens\n   * @return (tokenAmountIn, spotPriceAfter)\n   */\n  function swapExactAmountOut(\n    address tokenIn,\n    uint256 maxAmountIn,\n    address tokenOut,\n    uint256 tokenAmountOut,\n    uint256 maxPrice\n  )\n    external\n    override\n    _lock_\n    _public_\n    returns (uint256 /* tokenAmountIn */, uint256 /* spotPriceAfter */)\n  {\n    (Record memory inRecord, uint256 realInBalance) = _getInputToken(tokenIn);\n    Record memory outRecord = _getOutputToken(tokenOut);\n\n    require(\n      tokenAmountOut <= bmul(outRecord.balance, MAX_OUT_RATIO),\n      \"ERR_MAX_OUT_RATIO\"\n    );\n\n    uint256 spotPriceBefore = calcSpotPrice(\n      inRecord.balance,\n      inRecord.denorm,\n      outRecord.balance,\n      outRecord.denorm,\n      _swapFee\n    );\n    require(spotPriceBefore <= maxPrice, \"ERR_BAD_LIMIT_PRICE\");\n\n    uint256 tokenAmountIn = calcInGivenOut(\n      inRecord.balance,\n      inRecord.denorm,\n      outRecord.balance,\n      outRecord.denorm,\n      tokenAmountOut,\n      _swapFee\n    );\n\n    require(tokenAmountIn <= maxAmountIn, \"ERR_LIMIT_IN\");\n\n    _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\n    _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\n\n    // Update the balance and (if necessary) weight of the input token.\n    realInBalance = badd(realInBalance, tokenAmountIn);\n    _updateInputToken(tokenIn, inRecord, realInBalance);\n    if (inRecord.ready) {\n      inRecord.balance = realInBalance;\n    }\n    // Update the in-memory record for the spotPriceAfter calculation,\n    // then update the storage record with the local balance.\n    outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\n    _records[tokenOut].balance = outRecord.balance;\n    // If needed, update the output token's weight.\n    _decreaseDenorm(outRecord, tokenOut);\n\n    uint256 spotPriceAfter = calcSpotPrice(\n      inRecord.balance,\n      inRecord.denorm,\n      outRecord.balance,\n      outRecord.denorm,\n      _swapFee\n    );\n\n    require(spotPriceAfter >= spotPriceBefore, \"ERR_MATH_APPROX\");\n    require(spotPriceAfter <= maxPrice, \"ERR_LIMIT_PRICE\");\n    require(\n      spotPriceBefore <= bdiv(tokenAmountIn, tokenAmountOut),\n      \"ERR_MATH_APPROX\"\n    );\n\n    emit LOG_SWAP(msg.sender, tokenIn, tokenOut, tokenAmountIn, tokenAmountOut);\n\n    return (tokenAmountIn, spotPriceAfter);\n  }\n\n/* ==========  Config Queries  ========== */\n  /**\n   * @dev Check if swapping tokens and joining the pool is allowed.\n   */\n  function isPublicSwap() external view override returns (bool) {\n    return _publicSwap;\n  }\n\n  function getSwapFee() external view override _viewlock_ returns (uint256/* swapFee */) {\n    return _swapFee;\n  }\n\n  /**\n   * @dev Returns the controller address.\n   */\n  function getController() external view override returns (address)\n  {\n    return _controller;\n  }\n\n/* ==========  Token Queries  ========== */\n  function getMaxPoolTokens() external view override returns (uint256) {\n    return _maxPoolTokens;\n  }\n\n  /**\n   * @dev Check if a token is bound to the pool.\n   */\n  function isBound(address t) external view override returns (bool) {\n    return _records[t].bound;\n  }\n\n  /**\n   * @dev Get the number of tokens bound to the pool.\n   */\n  function getNumTokens() external view override returns (uint256) {\n    return _tokens.length;\n  }\n\n  /**\n   * @dev Get all bound tokens.\n   */\n  function getCurrentTokens()\n    external\n    view\n    override\n    _viewlock_\n    returns (address[] memory tokens)\n  {\n    tokens = _tokens;\n  }\n\n  /**\n   * @dev Returns the list of tokens which have a desired weight above 0.\n   * Tokens with a desired weight of 0 are set to be phased out of the pool.\n   */\n  function getCurrentDesiredTokens()\n    external\n    view\n    override\n    _viewlock_\n    returns (address[] memory tokens)\n  {\n    address[] memory tempTokens = _tokens;\n    tokens = new address[](tempTokens.length);\n    uint256 usedIndex = 0;\n    for (uint256 i = 0; i < tokens.length; i++) {\n      address token = tempTokens[i];\n      if (_records[token].desiredDenorm > 0) {\n        tokens[usedIndex++] = token;\n      }\n    }\n    assembly { mstore(tokens, usedIndex) }\n  }\n\n  /**\n   * @dev Returns the denormalized weight of a bound token.\n   */\n  function getDenormalizedWeight(address token)\n    external\n    view\n    override\n    _viewlock_\n    returns (uint256/* denorm */)\n  {\n    require(_records[token].bound, \"ERR_NOT_BOUND\");\n    return _records[token].denorm;\n  }\n\n  /**\n   * @dev Returns the record for a token bound to the pool.\n   */\n  function getTokenRecord(address token)\n    external\n    view\n    override\n    _viewlock_\n    returns (Record memory record)\n  {\n    record = _records[token];\n    require(record.bound, \"ERR_NOT_BOUND\");\n  }\n\n  /**\n   * @dev Finds the first token which is both initialized and has a\n   * desired weight above 0, then returns the address of that token\n   * and the extrapolated value of the pool in terms of that token.\n   *\n   * The value is extrapolated by multiplying the token's\n   * balance by the reciprocal of its normalized weight.\n   * @return (token, extrapolatedValue)\n   */\n  function extrapolatePoolValueFromToken()\n    external\n    view\n    override\n    _viewlock_\n    returns (address/* token */, uint256/* extrapolatedValue */)\n  {\n    address token;\n    uint256 extrapolatedValue;\n    uint256 len = _tokens.length;\n    for (uint256 i = 0; i < len; i++) {\n      token = _tokens[i];\n      Record storage record = _records[token];\n      if (record.ready && record.desiredDenorm > 0) {\n        extrapolatedValue = bmul(\n          record.balance,\n          bdiv(_totalWeight, record.denorm)\n        );\n        break;\n      }\n    }\n    require(extrapolatedValue > 0, \"ERR_NONE_READY\");\n    return (token, extrapolatedValue);\n  }\n\n  /**\n   * @dev Get the total denormalized weight of the pool.\n   */\n  function getTotalDenormalizedWeight()\n    external\n    view\n    override\n    _viewlock_\n    returns (uint256)\n  {\n    return _totalWeight;\n  }\n\n  /**\n   * @dev Returns the stored balance of a bound token.\n   */\n  function getBalance(address token) external view override _viewlock_ returns (uint256) {\n    Record storage record = _records[token];\n    require(record.bound, \"ERR_NOT_BOUND\");\n    return record.balance;\n  }\n\n  /**\n   * @dev Get the minimum balance of an uninitialized token.\n   * Note: Throws if the token is initialized.\n   */\n  function getMinimumBalance(address token) external view override _viewlock_ returns (uint256) {\n    Record memory record = _records[token];\n    require(record.bound, \"ERR_NOT_BOUND\");\n    require(!record.ready, \"ERR_READY\");\n    return _minimumBalances[token];\n  }\n\n  /**\n   * @dev Returns the balance of a token which is used in price\n   * calculations. If the token is initialized, this is the\n   * stored balance; if not, this is the minimum balance.\n   */\n  function getUsedBalance(address token) external view override _viewlock_ returns (uint256) {\n    Record memory record = _records[token];\n    require(record.bound, \"ERR_NOT_BOUND\");\n    if (!record.ready) {\n      return _minimumBalances[token];\n    }\n    return record.balance;\n  }\n\n/* ==========  Price Queries  ========== */\n  /**\n   * @dev Returns the spot price for `tokenOut` in terms of `tokenIn`.\n   */\n  function getSpotPrice(address tokenIn, address tokenOut)\n    external\n    view\n    override\n    _viewlock_\n    returns (uint256)\n  {\n    (Record memory inRecord,) = _getInputToken(tokenIn);\n    Record memory outRecord = _getOutputToken(tokenOut);\n    return\n      calcSpotPrice(\n        inRecord.balance,\n        inRecord.denorm,\n        outRecord.balance,\n        outRecord.denorm,\n        _swapFee\n      );\n  }\n\n/* ==========  Pool Share Internal Functions  ========== */\n\n  function _pullPoolShare(address from, uint256 amount) internal {\n    _pull(from, amount);\n  }\n\n  function _pushPoolShare(address to, uint256 amount) internal {\n    _push(to, amount);\n  }\n\n  function _mintPoolShare(uint256 amount) internal {\n    _mint(amount);\n  }\n\n  function _burnPoolShare(uint256 amount) internal {\n    _burn(amount);\n  }\n\n/* ==========  Underlying Token Internal Functions  ========== */\n  // 'Underlying' token-manipulation functions make external calls but are NOT locked\n  // You must `_lock_` or otherwise ensure reentry-safety\n\n  function _pullUnderlying(\n    address erc20,\n    address from,\n    uint256 amount\n  ) internal {\n    (bool success, bytes memory data) = erc20.call(\n      abi.encodeWithSelector(\n        IERC20.transferFrom.selector,\n        from,\n        address(this),\n        amount\n      )\n    );\n    require(\n      success && (data.length == 0 || abi.decode(data, (bool))),\n      \"ERR_ERC20_FALSE\"\n    );\n  }\n\n  function _pushUnderlying(\n    address erc20,\n    address to,\n    uint256 amount\n  ) internal {\n    (bool success, bytes memory data) = erc20.call(\n      abi.encodeWithSelector(\n        IERC20.transfer.selector,\n        to,\n        amount\n      )\n    );\n    require(\n      success && (data.length == 0 || abi.decode(data, (bool))),\n      \"ERR_ERC20_FALSE\"\n    );\n  }\n\n/* ==========  Token Management Internal Functions  ========== */\n\n  /**\n   * @dev Bind a token by address without actually depositing a balance.\n   * The token will be unable to be swapped out until it reaches the minimum balance.\n   * Note: Token must not already be bound.\n   * Note: `minimumBalance` should represent an amount of the token which is worth\n   * the portion of the current pool value represented by the minimum weight.\n   * @param token Address of the token to bind\n   * @param minimumBalance minimum balance to reach before the token can be swapped out\n   * @param desiredDenorm Desired weight for the token.\n   */\n  function _bind(\n    address token,\n    uint256 minimumBalance,\n    uint96 desiredDenorm\n  ) internal {\n    require(!_records[token].bound, \"ERR_IS_BOUND\");\n\n    require(desiredDenorm >= MIN_WEIGHT, \"ERR_MIN_WEIGHT\");\n    require(desiredDenorm <= MAX_WEIGHT, \"ERR_MAX_WEIGHT\");\n    require(minimumBalance >= MIN_BALANCE, \"ERR_MIN_BALANCE\");\n\n    _records[token] = Record({\n      bound: true,\n      ready: false,\n      lastDenormUpdate: 0,\n      denorm: 0,\n      desiredDenorm: desiredDenorm,\n      index: uint8(_tokens.length),\n      balance: 0\n    });\n    _tokens.push(token);\n    _minimumBalances[token] = minimumBalance;\n    emit LOG_TOKEN_ADDED(token, desiredDenorm, minimumBalance);\n  }\n\n  /**\n   * @dev Remove a token from the pool.\n   * Replaces the address in the tokens array with the last address,\n   * then removes it from the array.\n   * Note: This should only be called after the total weight has been adjusted.\n   * Note: Must be called in a function with:\n   * - _lock_ modifier to prevent reentrance\n   * - requirement that the token is bound\n   */\n  function _unbind(address token) internal {\n    Record memory record = _records[token];\n    uint256 tokenBalance = record.balance;\n\n    // Swap the token-to-unbind with the last token,\n    // then delete the last token\n    uint256 index = record.index;\n    uint256 last = _tokens.length - 1;\n    // Only swap the token with the last token if it is not\n    // already at the end of the array.\n    if (index != last) {\n      _tokens[index] = _tokens[last];\n      _records[_tokens[index]].index = uint8(index);\n    }\n    _tokens.pop();\n    _records[token] = Record({\n      bound: false,\n      ready: false,\n      lastDenormUpdate: 0,\n      denorm: 0,\n      desiredDenorm: 0,\n      index: 0,\n      balance: 0\n    });\n    // transfer any remaining tokens out\n    _pushUnderlying(token, address(_unbindHandler), tokenBalance);\n    _unbindHandler.handleUnbindToken(token, tokenBalance);\n    emit LOG_TOKEN_REMOVED(token);\n  }\n\n  function _setDesiredDenorm(address token, uint96 desiredDenorm) internal {\n    Record storage record = _records[token];\n    require(record.bound, \"ERR_NOT_BOUND\");\n    // If the desired weight is 0, this will trigger a gradual unbinding of the token.\n    // Therefore the weight only needs to be above the minimum weight if it isn't 0.\n    require(\n      desiredDenorm >= MIN_WEIGHT || desiredDenorm == 0,\n      \"ERR_MIN_WEIGHT\"\n    );\n    require(desiredDenorm <= MAX_WEIGHT, \"ERR_MAX_WEIGHT\");\n    record.desiredDenorm = desiredDenorm;\n    emit LOG_DESIRED_DENORM_SET(token, desiredDenorm);\n  }\n\n  function _increaseDenorm(Record memory record, address token) internal {\n    // If the weight does not need to increase or the token is not\n    // initialized, don't do anything.\n    if (\n      record.denorm >= record.desiredDenorm ||\n      !record.ready ||\n      now - record.lastDenormUpdate < WEIGHT_UPDATE_DELAY\n    ) return;\n    uint96 oldWeight = record.denorm;\n    uint96 denorm = record.desiredDenorm;\n    uint256 maxDiff = bmul(oldWeight, WEIGHT_CHANGE_PCT);\n    uint256 diff = bsub(denorm, oldWeight);\n    if (diff > maxDiff) {\n      denorm = uint96(badd(oldWeight, maxDiff));\n      diff = maxDiff;\n    }\n    _totalWeight = badd(_totalWeight, diff);\n    require(_totalWeight <= MAX_TOTAL_WEIGHT, \"ERR_MAX_TOTAL_WEIGHT\");\n    // Update the in-memory denorm value for spot-price computations.\n    record.denorm = denorm;\n    // Update the storage record\n    _records[token].denorm = denorm;\n    _records[token].lastDenormUpdate = uint40(now);\n    emit LOG_DENORM_UPDATED(token, denorm);\n  }\n\n  function _decreaseDenorm(Record memory record, address token) internal {\n    // If the weight does not need to decrease, don't do anything.\n    if (\n      record.denorm <= record.desiredDenorm ||\n      !record.ready ||\n      now - record.lastDenormUpdate < WEIGHT_UPDATE_DELAY\n    ) return;\n    uint96 oldWeight = record.denorm;\n    uint96 denorm = record.desiredDenorm;\n    uint256 maxDiff = bmul(oldWeight, WEIGHT_CHANGE_PCT);\n    uint256 diff = bsub(oldWeight, denorm);\n    if (diff > maxDiff) {\n      denorm = uint96(bsub(oldWeight, maxDiff));\n      diff = maxDiff;\n    }\n    if (denorm <= MIN_WEIGHT) {\n      denorm = 0;\n      _totalWeight = bsub(_totalWeight, denorm);\n      // Because this is removing the token from the pool, the\n      // in-memory denorm value is irrelevant, as it is only used\n      // to calculate the new spot price, but the spot price calc\n      // will throw if it is passed 0 for the denorm.\n      _unbind(token);\n    } else {\n      _totalWeight = bsub(_totalWeight, diff);\n      // Update the in-memory denorm value for spot-price computations.\n      record.denorm = denorm;\n      // Update the stored denorm value\n      _records[token].denorm = denorm;\n      _records[token].lastDenormUpdate = uint40(now);\n      emit LOG_DENORM_UPDATED(token, denorm);\n    }\n  }\n\n  /**\n   * @dev Handles weight changes and initialization of an\n   * input token.\n   *\n   * If the token is not initialized and the new balance is\n   * still below the minimum, this will not do anything.\n   *\n   * If the token is not initialized but the new balance will\n   * bring the token above the minimum balance, this will\n   * mark the token as initialized, remove the minimum\n   * balance and set the weight to the minimum weight plus\n   * 1%.\n   *\n   *\n   * @param token Address of the input token\n   * @param record Token record with minimums applied to the balance\n   * and weight if the token was uninitialized.\n   */\n  function _updateInputToken(\n    address token,\n    Record memory record,\n    uint256 realBalance\n  )\n    internal\n  {\n    if (!record.ready) {\n      // Check if the minimum balance has been reached\n      if (realBalance >= record.balance) {\n        // Remove the minimum balance record\n        _minimumBalances[token] = 0;\n        // Mark the token as initialized\n        _records[token].ready = true;\n        record.ready = true;\n        emit LOG_TOKEN_READY(token);\n        // Set the initial denorm value to the minimum weight times one plus\n        // the ratio of the increase in balance over the minimum to the minimum\n        // balance.\n        // weight = (1 + ((bal - min_bal) / min_bal)) * min_weight\n        uint256 additionalBalance = bsub(realBalance, record.balance);\n        uint256 balRatio = bdiv(additionalBalance, record.balance);\n        record.denorm = uint96(badd(MIN_WEIGHT, bmul(MIN_WEIGHT, balRatio)));\n        _records[token].denorm = record.denorm;\n        _records[token].lastDenormUpdate = uint40(now);\n        _totalWeight = badd(_totalWeight, record.denorm);\n        emit LOG_DENORM_UPDATED(token, record.denorm);\n      } else {\n        uint256 realToMinRatio = bdiv(\n          bsub(record.balance, realBalance),\n          record.balance\n        );\n        uint256 weightPremium = bmul(MIN_WEIGHT / 10, realToMinRatio);\n        record.denorm = uint96(badd(MIN_WEIGHT, weightPremium));\n      }\n      // If the token is still not ready, do not adjust the weight.\n    } else {\n      // If the token is already initialized, update the weight (if any adjustment\n      // is needed).\n      _increaseDenorm(record, token);\n    }\n    // Regardless of whether the token is initialized, store the actual new balance.\n    _records[token].balance = realBalance;\n  }\n\n/* ==========  Token Query Internal Functions  ========== */\n\n  /**\n   * @dev Get the record for a token which is being swapped in.\n   * The token must be bound to the pool. If the token is not\n   * initialized (meaning it does not have the minimum balance)\n   * this function will return the actual balance of the token\n   * which the pool holds, but set the record's balance and weight\n   * to the token's minimum balance and the pool's minimum weight.\n   * This allows the token swap to be priced correctly even if the\n   * pool does not own any of the tokens.\n   */\n  function _getInputToken(address token)\n    internal\n    view\n    returns (Record memory record, uint256 realBalance)\n  {\n    record = _records[token];\n    require(record.bound, \"ERR_NOT_BOUND\");\n\n    realBalance = record.balance;\n    // If the input token is not initialized, we use the minimum\n    // initial weight and minimum initial balance instead of the\n    // real values for price and output calculations.\n    if (!record.ready) {\n      record.balance = _minimumBalances[token];\n      uint256 realToMinRatio = bdiv(\n        bsub(record.balance, realBalance),\n        record.balance\n      );\n      uint256 weightPremium = bmul(MIN_WEIGHT / 10, realToMinRatio);\n      record.denorm = uint96(badd(MIN_WEIGHT, weightPremium));\n    }\n  }\n\n  function _getOutputToken(address token)\n    internal\n    view\n    returns (Record memory record)\n  {\n    record = _records[token];\n    require(record.bound, \"ERR_NOT_BOUND\");\n    // Tokens which have not reached their minimum balance can not be\n    // swapped out.\n    require(record.ready, \"ERR_OUT_NOT_READY\");\n  }\n}\n\n\ninterface TokenUnbindHandler {\n  /**\n   * @dev Receive `amount` of `token` from the pool.\n   */\n  function handleUnbindToken(address token, uint256 amount) external;\n}"
    },
    "contracts/interfaces/IFlashLoanRecipient.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\n\ninterface IFlashLoanRecipient {\n  function receiveFlashLoan(\n    address tokenBorrowed,\n    uint256 amountBorrowed,\n    uint256 amountDue,\n    bytes calldata data\n  ) external;\n}"
    },
    "contracts/interfaces/IIndexPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\n\ninterface IIndexPool {\n  /**\n   * @dev Token record data structure\n   * @param bound is token bound to pool\n   * @param ready has token been initialized\n   * @param lastDenormUpdate timestamp of last denorm change\n   * @param denorm denormalized weight\n   * @param desiredDenorm desired denormalized weight (used for incremental changes)\n   * @param index index of address in tokens array\n   * @param balance token balance\n   */\n  struct Record {\n    bool bound;\n    bool ready;\n    uint40 lastDenormUpdate;\n    uint96 denorm;\n    uint96 desiredDenorm;\n    uint8 index;\n    uint256 balance;\n  }\n\n  event LOG_SWAP(\n    address indexed caller,\n    address indexed tokenIn,\n    address indexed tokenOut,\n    uint256 tokenAmountIn,\n    uint256 tokenAmountOut\n  );\n\n  event LOG_JOIN(\n    address indexed caller,\n    address indexed tokenIn,\n    uint256 tokenAmountIn\n  );\n\n  event LOG_EXIT(\n    address indexed caller,\n    address indexed tokenOut,\n    uint256 tokenAmountOut\n  );\n\n  event LOG_DENORM_UPDATED(address indexed token, uint256 newDenorm);\n\n  event LOG_DESIRED_DENORM_SET(address indexed token, uint256 desiredDenorm);\n\n  event LOG_TOKEN_REMOVED(address token);\n\n  event LOG_TOKEN_ADDED(\n    address indexed token,\n    uint256 desiredDenorm,\n    uint256 minimumBalance\n  );\n\n  event LOG_MINIMUM_BALANCE_UPDATED(address token, uint256 minimumBalance);\n\n  event LOG_TOKEN_READY(address indexed token);\n\n  event LOG_PUBLIC_SWAP_ENABLED();\n\n  event LOG_MAX_TOKENS_UPDATED(uint256 maxPoolTokens);\n\n  event LOG_SWAP_FEE_UPDATED(uint256 swapFee);\n\n  function configure(\n    address controller,\n    string calldata name,\n    string calldata symbol\n  ) external;\n\n  function initialize(\n    address[] calldata tokens,\n    uint256[] calldata balances,\n    uint96[] calldata denorms,\n    address tokenProvider,\n    address unbindHandler\n  ) external;\n\n  function setMaxPoolTokens(uint256 maxPoolTokens) external;\n\n  function setSwapFee(uint256 swapFee) external;\n\n  function reweighTokens(\n    address[] calldata tokens,\n    uint96[] calldata desiredDenorms\n  ) external;\n\n  function reindexTokens(\n    address[] calldata tokens,\n    uint96[] calldata desiredDenorms,\n    uint256[] calldata minimumBalances\n  ) external;\n\n  function setMinimumBalance(address token, uint256 minimumBalance) external;\n\n  function joinPool(uint256 poolAmountOut, uint256[] calldata maxAmountsIn) external;\n\n  function joinswapExternAmountIn(\n    address tokenIn,\n    uint256 tokenAmountIn,\n    uint256 minPoolAmountOut\n  ) external returns (uint256/* poolAmountOut */);\n\n  function joinswapPoolAmountOut(\n    address tokenIn,\n    uint256 poolAmountOut,\n    uint256 maxAmountIn\n  ) external returns (uint256/* tokenAmountIn */);\n\n  function exitPool(uint256 poolAmountIn, uint256[] calldata minAmountsOut) external;\n\n  function exitswapPoolAmountIn(\n    address tokenOut,\n    uint256 poolAmountIn,\n    uint256 minAmountOut\n  )\n    external returns (uint256/* tokenAmountOut */);\n\n  function exitswapExternAmountOut(\n    address tokenOut,\n    uint256 tokenAmountOut,\n    uint256 maxPoolAmountIn\n  ) external returns (uint256/* poolAmountIn */);\n\n  function gulp(address token) external;\n\n  function flashBorrow(\n    address recipient,\n    address token,\n    uint256 amount,\n    bytes calldata data\n  ) external;\n\n  function swapExactAmountIn(\n    address tokenIn,\n    uint256 tokenAmountIn,\n    address tokenOut,\n    uint256 minAmountOut,\n    uint256 maxPrice\n  ) external returns (uint256/* tokenAmountOut */, uint256/* spotPriceAfter */);\n\n  function swapExactAmountOut(\n    address tokenIn,\n    uint256 maxAmountIn,\n    address tokenOut,\n    uint256 tokenAmountOut,\n    uint256 maxPrice\n  ) external returns (uint256 /* tokenAmountIn */, uint256 /* spotPriceAfter */);\n\n  function isPublicSwap() external view returns (bool);\n\n  function getSwapFee() external view returns (uint256/* swapFee */);\n\n  function getController() external view returns (address);\n\n  function getMaxPoolTokens() external view returns (uint256);\n\n  function isBound(address t) external view returns (bool);\n\n  function getNumTokens() external view returns (uint256);\n\n  function getCurrentTokens() external view returns (address[] memory tokens);\n\n  function getCurrentDesiredTokens() external view returns (address[] memory tokens);\n\n  function getDenormalizedWeight(address token) external view returns (uint256/* denorm */);\n\n  function getTokenRecord(address token) external view returns (Record memory record);\n\n  function extrapolatePoolValueFromToken() external view returns (address/* token */, uint256/* extrapolatedValue */);\n\n  function getTotalDenormalizedWeight() external view returns (uint256);\n\n  function getBalance(address token) external view returns (uint256);\n\n  function getMinimumBalance(address token) external view returns (uint256);\n\n  function getUsedBalance(address token) external view returns (uint256);\n\n  function getSpotPrice(address tokenIn, address tokenOut) external view returns (uint256);\n}"
    },
    "contracts/interfaces/IMarketCapSqrtController.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\n\nimport \"@indexed-finance/uniswap-v2-oracle/contracts/interfaces/IIndexedUniswapV2Oracle.sol\";\n\n\ninterface IMarketCapSqrtController {\n/* ========== Events ========== */\n\n  event CategoryAdded(uint256 categoryID, bytes32 metadataHash);\n\n  event CategorySorted(uint256 categoryID);\n\n  event TokenAdded(address token, uint256 categoryID);\n\n  event PoolInitialized(\n    address pool,\n    address unboundTokenSeller,\n    uint256 categoryID,\n    uint256 indexSize\n  );\n\n  event NewPoolInitializer(\n    address pool,\n    address initializer,\n    uint256 categoryID,\n    uint256 indexSize\n  );\n\n/* ========== Mutative ========== */\n\n  function updateCategoryPrices(uint256 categoryID) external;\n\n  function createCategory(bytes32 metadataHash) external;\n\n  function addToken(address token, uint256 categoryID) external;\n\n  function addTokens(uint256 categoryID, address[] calldata tokens) external;\n\n  function orderCategoryTokensByMarketCap(uint256 categoryID) external;\n\n/* ========== Views ========== */\n\n  function categoryIndex() external view returns (uint256);\n\n  function oracle() external view returns (IIndexedUniswapV2Oracle);\n\n  function computeAverageMarketCap(address token) external view returns (uint144);\n\n  function computeAverageMarketCaps(address[] memory tokens) external view returns (uint144[] memory);\n\n  function hasCategory(uint256 categoryID) external view returns (bool);\n\n  function getLastCategoryUpdate(uint256 categoryID) external view returns (uint256);\n\n  function isTokenInCategory(uint256 categoryID, address token) external view returns (bool);\n\n  function getCategoryTokens(uint256 categoryID) external view returns (address[] memory);\n\n  function getCategoryMarketCaps(uint256 categoryID) external view returns (uint144[] memory);\n\n  function getTopCategoryTokens(uint256 categoryID, uint256 num) external view returns (address[] memory);\n}"
    },
    "@indexed-finance/uniswap-v2-oracle/contracts/interfaces/IIndexedUniswapV2Oracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\n/* ==========  Libraries  ========== */\nimport \"../lib/PriceLibrary.sol\";\nimport \"../lib/FixedPoint.sol\";\n\n\ninterface IIndexedUniswapV2Oracle {\n/* ==========  Mutative Functions  ========== */\n\n  function updatePrice(address token) external returns (bool);\n\n  function updatePrices(address[] calldata tokens) external returns (bool[] memory);\n\n/* ==========  Meta Price Queries  ========== */\n\n  function hasPriceObservationInWindow(address token, uint256 priceKey) external view returns (bool);\n\n  function getPriceObservationInWindow(\n    address token, uint256 priceKey\n  ) external view returns (PriceLibrary.PriceObservation memory);\n\n  function getPriceObservationsInRange(\n    address token, uint256 timeFrom, uint256 timeTo\n  ) external view returns (PriceLibrary.PriceObservation[] memory prices);\n\n/* ==========  Price Update Queries  ========== */\n\n  function canUpdatePrice(address token) external view returns (bool);\n\n  function canUpdatePrices(address[] calldata tokens) external view returns (bool[] memory);\n\n/* ==========  Price Queries: Singular  ========== */\n\n  function computeTwoWayAveragePrice(\n    address token, uint256 minTimeElapsed, uint256 maxTimeElapsed\n  ) external view returns (PriceLibrary.TwoWayAveragePrice memory);\n\n  function computeAverageTokenPrice(\n    address token, uint256 minTimeElapsed, uint256 maxTimeElapsed\n  ) external view returns (FixedPoint.uq112x112 memory);\n\n  function computeAverageEthPrice(\n    address token, uint256 minTimeElapsed, uint256 maxTimeElapsed\n  ) external view returns (FixedPoint.uq112x112 memory);\n\n/* ==========  Price Queries: Multiple  ========== */\n\n  function computeTwoWayAveragePrices(\n    address[] calldata tokens,\n    uint256 minTimeElapsed,\n    uint256 maxTimeElapsed\n  ) external view returns (PriceLibrary.TwoWayAveragePrice[] memory);\n\n  function computeAverageTokenPrices(\n    address[] calldata tokens,\n    uint256 minTimeElapsed,\n    uint256 maxTimeElapsed\n  ) external view returns (FixedPoint.uq112x112[] memory);\n\n  function computeAverageEthPrices(\n    address[] calldata tokens,\n    uint256 minTimeElapsed,\n    uint256 maxTimeElapsed\n  ) external view returns (FixedPoint.uq112x112[] memory);\n\n/* ==========  Value Queries: Singular  ========== */\n\n  function computeAverageEthForTokens(\n    address token,\n    uint256 tokenAmount,\n    uint256 minTimeElapsed,\n    uint256 maxTimeElapsed\n  ) external view returns (uint144);\n\n  function computeAverageTokensForEth(\n    address token,\n    uint256 wethAmount,\n    uint256 minTimeElapsed,\n    uint256 maxTimeElapsed\n  ) external view returns (uint144);\n\n/* ==========  Value Queries: Multiple  ========== */\n\n  function computeAverageEthForTokens(\n    address[] calldata tokens,\n    uint256[] calldata tokenAmounts,\n    uint256 minTimeElapsed,\n    uint256 maxTimeElapsed\n  ) external view returns (uint144[] memory);\n\n  function computeAverageTokensForEth(\n    address[] calldata tokens,\n    uint256[] calldata wethAmounts,\n    uint256 minTimeElapsed,\n    uint256 maxTimeElapsed\n  ) external view returns (uint144[] memory);\n}"
    },
    "@indexed-finance/uniswap-v2-oracle/contracts/lib/PriceLibrary.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\n/* ==========  Internal Libraries  ========== */\nimport \"./FixedPoint.sol\";\nimport \"./UniswapV2OracleLibrary.sol\";\nimport \"./UniswapV2Library.sol\";\n\n\nlibrary PriceLibrary {\n  using FixedPoint for FixedPoint.uq112x112;\n  using FixedPoint for FixedPoint.uq144x112;\n\n/* ========= Structs ========= */\n\n  struct PriceObservation {\n    uint32 timestamp;\n    uint224 priceCumulativeLast;\n    uint224 ethPriceCumulativeLast;\n  }\n\n  /**\n   * @dev Average prices for a token in terms of weth and weth in terms of the token.\n   *\n   * Note: The average weth price is not equivalent to the reciprocal of the average\n   * token price. See the UniSwap whitepaper for more info.\n   */\n  struct TwoWayAveragePrice {\n    uint224 priceAverage;\n    uint224 ethPriceAverage;\n  }\n\n/* ========= View Functions ========= */\n\n  function pairInitialized(\n    address uniswapFactory,\n    address token,\n    address weth\n  )\n    internal\n    view\n    returns (bool)\n  {\n    address pair = UniswapV2Library.pairFor(uniswapFactory, token, weth);\n    (uint112 reserve0, uint112 reserve1,) = IUniswapV2Pair(pair).getReserves();\n    return reserve0 != 0 && reserve1 != 0;\n  }\n\n  function observePrice(\n    address uniswapFactory,\n    address tokenIn,\n    address quoteToken\n  )\n    internal\n    view\n    returns (uint32 /* timestamp */, uint224 /* priceCumulativeLast */)\n  {\n    (address token0, address token1) = UniswapV2Library.sortTokens(tokenIn, quoteToken);\n    address pair = UniswapV2Library.calculatePair(uniswapFactory, token0, token1);\n    if (token0 == tokenIn) {\n      (uint256 price0Cumulative, uint32 blockTimestamp) = UniswapV2OracleLibrary.currentCumulativePrice0(pair);\n      return (blockTimestamp, uint224(price0Cumulative));\n    } else {\n      (uint256 price1Cumulative, uint32 blockTimestamp) = UniswapV2OracleLibrary.currentCumulativePrice1(pair);\n      return (blockTimestamp, uint224(price1Cumulative));\n    }\n  }\n\n  /**\n   * @dev Query the current cumulative price of a token in terms of weth\n   * and the current cumulative price of weth in terms of the token.\n   */\n  function observeTwoWayPrice(\n    address uniswapFactory,\n    address token,\n    address weth\n  ) internal view returns (PriceObservation memory) {\n    (address token0, address token1) = UniswapV2Library.sortTokens(token, weth);\n    address pair = UniswapV2Library.calculatePair(uniswapFactory, token0, token1);\n    // Get the sorted token prices\n    (\n      uint256 price0Cumulative,\n      uint256 price1Cumulative,\n      uint32 blockTimestamp\n    ) = UniswapV2OracleLibrary.currentCumulativePrices(pair);\n    // Check which token is weth and which is the token,\n    // then build the price observation.\n    if (token0 == token) {\n      return PriceObservation({\n        timestamp: blockTimestamp,\n        priceCumulativeLast: uint224(price0Cumulative),\n        ethPriceCumulativeLast: uint224(price1Cumulative)\n      });\n    } else {\n      return PriceObservation({\n        timestamp: blockTimestamp,\n        priceCumulativeLast: uint224(price1Cumulative),\n        ethPriceCumulativeLast: uint224(price0Cumulative)\n      });\n    }\n  }\n\n/* ========= Utility Functions ========= */\n\n  /**\n   * @dev Computes the average price of a token in terms of weth\n   * and the average price of weth in terms of a token using two\n   * price observations.\n   */\n  function computeTwoWayAveragePrice(\n    PriceObservation memory observation1,\n    PriceObservation memory observation2\n  ) internal pure returns (TwoWayAveragePrice memory) {\n    uint32 timeElapsed = uint32(observation2.timestamp - observation1.timestamp);\n    FixedPoint.uq112x112 memory priceAverage = UniswapV2OracleLibrary.computeAveragePrice(\n      observation1.priceCumulativeLast,\n      observation2.priceCumulativeLast,\n      timeElapsed\n    );\n    FixedPoint.uq112x112 memory ethPriceAverage = UniswapV2OracleLibrary.computeAveragePrice(\n      observation1.ethPriceCumulativeLast,\n      observation2.ethPriceCumulativeLast,\n      timeElapsed\n    );\n    return TwoWayAveragePrice({\n      priceAverage: priceAverage._x,\n      ethPriceAverage: ethPriceAverage._x\n    });\n  }\n\n  function computeAveragePrice(\n    uint32 timestampStart,\n    uint224 priceCumulativeStart,\n    uint32 timestampEnd,\n    uint224 priceCumulativeEnd\n  ) internal pure returns (FixedPoint.uq112x112 memory) {\n    return UniswapV2OracleLibrary.computeAveragePrice(\n      priceCumulativeStart,\n      priceCumulativeEnd,\n      uint32(timestampEnd - timestampStart)\n    );\n  }\n\n  /**\n   * @dev Computes the average price of the token the price observations\n   * are for in terms of weth.\n   */\n  function computeAverageTokenPrice(\n    PriceObservation memory observation1,\n    PriceObservation memory observation2\n  ) internal pure returns (FixedPoint.uq112x112 memory) {\n    return UniswapV2OracleLibrary.computeAveragePrice(\n      observation1.priceCumulativeLast,\n      observation2.priceCumulativeLast,\n      uint32(observation2.timestamp - observation1.timestamp)\n    );\n  }\n\n  /**\n   * @dev Computes the average price of weth in terms of the token\n   * the price observations are for.\n   */\n  function computeAverageEthPrice(\n    PriceObservation memory observation1,\n    PriceObservation memory observation2\n  ) internal pure returns (FixedPoint.uq112x112 memory) {\n    return UniswapV2OracleLibrary.computeAveragePrice(\n      observation1.ethPriceCumulativeLast,\n      observation2.ethPriceCumulativeLast,\n      uint32(observation2.timestamp - observation1.timestamp)\n    );\n  }\n\n  /**\n   * @dev Compute the average value in weth of `tokenAmount` of the\n   * token that the average price values are for.\n   */\n  function computeAverageEthForTokens(\n    TwoWayAveragePrice memory prices,\n    uint256 tokenAmount\n  ) internal pure returns (uint144) {\n    return FixedPoint.uq112x112(prices.priceAverage).mul(tokenAmount).decode144();\n  }\n\n  /**\n   * @dev Compute the average value of `wethAmount` weth in terms of\n   * the token that the average price values are for.\n   */\n  function computeAverageTokensForEth(\n    TwoWayAveragePrice memory prices,\n    uint256 wethAmount\n  ) internal pure returns (uint144) {\n    return FixedPoint.uq112x112(prices.ethPriceAverage).mul(wethAmount).decode144();\n  }\n}"
    },
    "@indexed-finance/uniswap-v2-oracle/contracts/lib/FixedPoint.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\n\n\n/************************************************************************************************\nFrom https://github.com/Uniswap/uniswap-lib/blob/master/contracts/libraries/FixedPoint.sol\n\nCopied from the github repository at commit hash 9642a0705fdaf36b477354a4167a8cd765250860.\n\nModifications:\n- Removed `sqrt` function\n\nSubject to the GPL-3.0 license\n*************************************************************************************************/\n\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\nlibrary FixedPoint {\n  // range: [0, 2**112 - 1]\n  // resolution: 1 / 2**112\n  struct uq112x112 {\n    uint224 _x;\n  }\n\n  // range: [0, 2**144 - 1]\n  // resolution: 1 / 2**112\n  struct uq144x112 {\n    uint _x;\n  }\n\n  uint8 private constant RESOLUTION = 112;\n  uint private constant Q112 = uint(1) << RESOLUTION;\n  uint private constant Q224 = Q112 << RESOLUTION;\n\n  // encode a uint112 as a UQ112x112\n  function encode(uint112 x) internal pure returns (uq112x112 memory) {\n    return uq112x112(uint224(x) << RESOLUTION);\n  }\n\n  // encodes a uint144 as a UQ144x112\n  function encode144(uint144 x) internal pure returns (uq144x112 memory) {\n    return uq144x112(uint256(x) << RESOLUTION);\n  }\n\n  // divide a UQ112x112 by a uint112, returning a UQ112x112\n  function div(uq112x112 memory self, uint112 x) internal pure returns (uq112x112 memory) {\n    require(x != 0, \"FixedPoint: DIV_BY_ZERO\");\n    return uq112x112(self._x / uint224(x));\n  }\n\n  // multiply a UQ112x112 by a uint, returning a UQ144x112\n  // reverts on overflow\n  function mul(uq112x112 memory self, uint y) internal pure returns (uq144x112 memory) {\n    uint z;\n    require(\n      y == 0 || (z = uint(self._x) * y) / y == uint(self._x),\n      \"FixedPoint: MULTIPLICATION_OVERFLOW\"\n    );\n    return uq144x112(z);\n  }\n\n  // returns a UQ112x112 which represents the ratio of the numerator to the denominator\n  // equivalent to encode(numerator).div(denominator)\n  function fraction(uint112 numerator, uint112 denominator) internal pure returns (uq112x112 memory) {\n    require(denominator > 0, \"FixedPoint: DIV_BY_ZERO\");\n    return uq112x112((uint224(numerator) << RESOLUTION) / denominator);\n  }\n\n  // decode a UQ112x112 into a uint112 by truncating after the radix point\n  function decode(uq112x112 memory self) internal pure returns (uint112) {\n    return uint112(self._x >> RESOLUTION);\n  }\n\n  // decode a UQ144x112 into a uint144 by truncating after the radix point\n  function decode144(uq144x112 memory self) internal pure returns (uint144) {\n    return uint144(self._x >> RESOLUTION);\n  }\n\n  // take the reciprocal of a UQ112x112\n  function reciprocal(uq112x112 memory self) internal pure returns (uq112x112 memory) {\n    require(self._x != 0, \"FixedPoint: ZERO_RECIPROCAL\");\n    return uq112x112(uint224(Q224 / self._x));\n  }\n}"
    },
    "@indexed-finance/uniswap-v2-oracle/contracts/lib/UniswapV2OracleLibrary.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\n\n/* ==========  Internal Interfaces  ========== */\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\n\n/* ==========  Internal Libraries  ========== */\nimport \"./FixedPoint.sol\";\n\n\n/************************************************************************************************\nOriginally from https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/libraries/UniswapV2OracleLibrary.sol\n\nThis source code has been modified from the original, which was copied from the github repository\nat commit hash 6d03bede0a97c72323fa1c379ed3fdf7231d0b26.\n\nSubject to the GPL-3.0 license\n*************************************************************************************************/\n\n\n// library with helper methods for oracles that are concerned with computing average prices\nlibrary UniswapV2OracleLibrary {\n  using FixedPoint for *;\n\n  // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\n  function currentBlockTimestamp() internal view returns (uint32) {\n    return uint32(block.timestamp % 2**32);\n  }\n\n  // produces the cumulative prices using counterfactuals to save gas and avoid a call to sync.\n  function currentCumulativePrices(address pair)\n    internal\n    view\n    returns (\n      uint256 price0Cumulative,\n      uint256 price1Cumulative,\n      uint32 blockTimestamp\n    )\n  {\n    blockTimestamp = currentBlockTimestamp();\n    price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\n    price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\n\n    // if time has elapsed since the last update on the pair, mock the accumulated price values\n    (\n      uint112 reserve0,\n      uint112 reserve1,\n      uint32 blockTimestampLast\n    ) = IUniswapV2Pair(pair).getReserves();\n    require(\n      reserve0 != 0 && reserve1 != 0,\n      \"UniswapV2OracleLibrary::currentCumulativePrices: Pair has no reserves.\"\n    );\n    if (blockTimestampLast != blockTimestamp) {\n      // subtraction overflow is desired\n      uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n      // addition overflow is desired\n      // counterfactual\n      price0Cumulative += (\n        uint256(FixedPoint.fraction(reserve1, reserve0)._x) *\n        timeElapsed\n      );\n      // counterfactual\n      price1Cumulative += (\n        uint256(FixedPoint.fraction(reserve0, reserve1)._x) *\n        timeElapsed\n      );\n    }\n  }\n\n  // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\n  // only gets the first price\n  function currentCumulativePrice0(address pair)\n    internal\n    view\n    returns (uint256 price0Cumulative, uint32 blockTimestamp)\n  {\n    blockTimestamp = currentBlockTimestamp();\n    price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\n\n    // if time has elapsed since the last update on the pair, mock the accumulated price values\n    (\n      uint112 reserve0,\n      uint112 reserve1,\n      uint32 blockTimestampLast\n    ) = IUniswapV2Pair(pair).getReserves();\n    require(\n      reserve0 != 0 && reserve1 != 0,\n      \"UniswapV2OracleLibrary::currentCumulativePrice0: Pair has no reserves.\"\n    );\n    if (blockTimestampLast != blockTimestamp) {\n      // subtraction overflow is desired\n      uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n      // addition overflow is desired\n      // counterfactual\n      price0Cumulative += (\n        uint256(FixedPoint.fraction(reserve1, reserve0)._x) *\n        timeElapsed\n      );\n    }\n  }\n\n  // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\n  // only gets the second price\n  function currentCumulativePrice1(address pair)\n    internal\n    view\n    returns (uint256 price1Cumulative, uint32 blockTimestamp)\n  {\n    blockTimestamp = currentBlockTimestamp();\n    price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\n\n    // if time has elapsed since the last update on the pair, mock the accumulated price values\n    (\n      uint112 reserve0,\n      uint112 reserve1,\n      uint32 blockTimestampLast\n    ) = IUniswapV2Pair(pair).getReserves();\n    require(\n      reserve0 != 0 && reserve1 != 0,\n      \"UniswapV2OracleLibrary::currentCumulativePrice1: Pair has no reserves.\"\n    );\n    if (blockTimestampLast != blockTimestamp) {\n      // subtraction overflow is desired\n      uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n      // addition overflow is desired\n      // counterfactual\n      price1Cumulative += (\n        uint256(FixedPoint.fraction(reserve0, reserve1)._x) *\n        timeElapsed\n      );\n    }\n  }\n\n  function computeAveragePrice(\n    uint224 priceCumulativeStart,\n    uint224 priceCumulativeEnd,\n    uint32 timeElapsed\n  ) internal pure returns (FixedPoint.uq112x112 memory priceAverage) {\n    // overflow is desired.\n    priceAverage = FixedPoint.uq112x112(\n      uint224((priceCumulativeEnd - priceCumulativeStart) / timeElapsed)\n    );\n  }\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "@indexed-finance/uniswap-v2-oracle/contracts/lib/UniswapV2Library.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\n\n/************************************************************************************************\nOriginally from https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/libraries/UniswapV2Library.sol\n\nThis source code has been modified from the original, which was copied from the github repository\nat commit hash 87edfdcaf49ccc52591502993db4c8c08ea9eec0.\n\nSubject to the GPL-3.0 license\n*************************************************************************************************/\n\n\nlibrary UniswapV2Library {\n  // returns sorted token addresses, used to handle return values from pairs sorted in this order\n  function sortTokens(address tokenA, address tokenB)\n    internal\n    pure\n    returns (address token0, address token1)\n  {\n    require(tokenA != tokenB, \"UniswapV2Library: IDENTICAL_ADDRESSES\");\n    (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n    require(token0 != address(0), \"UniswapV2Library: ZERO_ADDRESS\");\n  }\n\n  function calculatePair(\n    address factory,\n    address token0,\n    address token1\n  ) internal pure returns (address pair) {\n    pair = address(\n      uint256(\n        keccak256(\n          abi.encodePacked(\n            hex\"ff\",\n            factory,\n            keccak256(abi.encodePacked(token0, token1)),\n            hex\"96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f\" // init code hash\n          )\n        )\n      )\n    );\n  }\n\n  // calculates the CREATE2 address for a pair without making any external calls\n  function pairFor(\n    address factory,\n    address tokenA,\n    address tokenB\n  ) internal pure returns (address pair) {\n    (address token0, address token1) = sortTokens(tokenA, tokenB);\n    pair = calculatePair(factory, token0, token1);\n  }\n}\n"
    },
    "contracts/interfaces/IPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\n\nimport \"@indexed-finance/proxies/contracts/interfaces/IDelegateCallProxyManager.sol\";\n\n\ninterface IPoolFactory {\n/* ========== Events ========== */\n\n  event NewPool(address pool, address controller, bytes32 implementationID);\n\n/* ========== Mutative ========== */\n\n  function approvePoolController(address controller) external;\n\n  function disapprovePoolController(address controller) external;\n\n  function deployPool(bytes32 implementationID, bytes32 controllerSalt) external returns (address);\n\n/* ========== Views ========== */\n\n  function proxyManager() external view returns (IDelegateCallProxyManager);\n\n  function isApprovedController(address) external view returns (bool);\n\n  function getPoolImplementationID(address) external view returns (bytes32);\n\n  function isRecognizedPool(address pool) external view returns (bool);\n\n  function computePoolAddress(\n    bytes32 implementationID,\n    address controller,\n    bytes32 controllerSalt\n  ) external view returns (address);\n}"
    },
    "@indexed-finance/proxies/contracts/interfaces/IDelegateCallProxyManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\n\n\n/**\n * @dev Contract that manages deployment and upgrades of delegatecall proxies.\n *\n * An implementation identifier can be created on the proxy manager which is\n * used to specify the logic address for a particular contract type, and to\n * upgrade the implementation as needed.\n *\n * A one-to-one proxy is a single proxy contract with an upgradeable implementation\n * address.\n *\n * A many-to-one proxy is a single upgradeable implementation address that may be\n * used by many proxy contracts.\n */\ninterface IDelegateCallProxyManager {\n/* ==========  Events  ========== */\n\n  event DeploymentApprovalGranted(address deployer);\n  event DeploymentApprovalRevoked(address deployer);\n\n  event ManyToOne_ImplementationCreated(\n    bytes32 implementationID,\n    address implementationAddress\n  );\n\n  event ManyToOne_ImplementationUpdated(\n    bytes32 implementationID,\n    address implementationAddress\n  );\n\n  event ManyToOne_ProxyDeployed(\n    bytes32 implementationID,\n    address proxyAddress\n  );\n\n  event OneToOne_ProxyDeployed(\n    address proxyAddress,\n    address implementationAddress\n  );\n\n  event OneToOne_ImplementationUpdated(\n    address proxyAddress,\n    address implementationAddress\n  );\n\n/* ==========  Controls  ========== */\n\n  /**\n   * @dev Allows `deployer` to deploy many-to-one proxies.\n   */\n  function approveDeployer(address deployer) external;\n\n  /**\n   * @dev Prevents `deployer` from deploying many-to-one proxies.\n   */\n  function revokeDeployerApproval(address deployer) external;\n\n/* ==========  Implementation Management  ========== */\n\n  /**\n   * @dev Creates a many-to-one proxy relationship.\n   *\n   * Deploys an implementation holder contract which stores the\n   * implementation address for many proxies. The implementation\n   * address can be updated on the holder to change the runtime\n   * code used by all its proxies.\n   *\n   * @param implementationID ID for the implementation, used to identify the\n   * proxies that use it. Also used as the salt in the create2 call when\n   * deploying the implementation holder contract.\n   * @param implementation Address with the runtime code the proxies\n   * should use.\n   */\n  function createManyToOneProxyRelationship(\n    bytes32 implementationID,\n    address implementation\n  ) external;\n\n  /**\n   * @dev Lock the current implementation for `proxyAddress` so that it can never be upgraded again.\n   */\n  function lockImplementationManyToOne(bytes32 implementationID) external;\n\n  /**\n   * @dev Lock the current implementation for `proxyAddress` so that it can never be upgraded again.\n   */\n  function lockImplementationOneToOne(address proxyAddress) external;\n\n  /**\n   * @dev Updates the implementation address for a many-to-one\n   * proxy relationship.\n   *\n   * @param implementationID Identifier for the implementation.\n   * @param implementation Address with the runtime code the proxies\n   * should use.\n   */\n  function setImplementationAddressManyToOne(\n    bytes32 implementationID,\n    address implementation\n  ) external;\n\n  /**\n   * @dev Updates the implementation address for a one-to-one proxy.\n   *\n   * Note: This could work for many-to-one as well if the caller\n   * provides the implementation holder address in place of the\n   * proxy address, as they use the same access control and update\n   * mechanism.\n   *\n   * @param proxyAddress Address of the deployed proxy\n   * @param implementation Address with the runtime code for\n   * the proxy to use.\n   */\n  function setImplementationAddressOneToOne(\n    address proxyAddress,\n    address implementation\n  ) external;\n\n/* ==========  Proxy Deployment  ========== */\n\n  /**\n   * @dev Deploy a proxy contract with a one-to-one relationship\n   * with its implementation.\n   *\n   * The proxy will have its own implementation address which can\n   * be updated by the proxy manager.\n   *\n   * @param suppliedSalt Salt provided by the account requesting deployment.\n   * @param implementation Address of the contract with the runtime\n   * code that the proxy should use.\n   */\n  function deployProxyOneToOne(\n    bytes32 suppliedSalt,\n    address implementation\n  ) external returns(address proxyAddress);\n\n  /**\n   * @dev Deploy a proxy with a many-to-one relationship with its implemenation.\n   *\n   * The proxy will call the implementation holder for every transaction to\n   * determine the address to use in calls.\n   *\n   * @param implementationID Identifier for the proxy's implementation.\n   * @param suppliedSalt Salt provided by the account requesting deployment.\n   */\n  function deployProxyManyToOne(\n    bytes32 implementationID,\n    bytes32 suppliedSalt\n  ) external returns(address proxyAddress);\n\n/* ==========  Queries  ========== */\n\n  /**\n   * @dev Returns a boolean stating whether `implementationID` is locked.\n   */\n  function isImplementationLocked(bytes32 implementationID) external view returns (bool);\n\n  /**\n   * @dev Returns a boolean stating whether `proxyAddress` is locked.\n   */\n  function isImplementationLocked(address proxyAddress) external view returns (bool);\n\n  /**\n   * @dev Returns a boolean stating whether `deployer` is allowed to deploy many-to-one\n   * proxies.\n   */\n  function isApprovedDeployer(address deployer) external view returns (bool);\n\n  /**\n   * @dev Queries the temporary storage value `_implementationHolder`.\n   * This is used in the constructor of the many-to-one proxy contract\n   * so that the create2 address is static (adding constructor arguments\n   * would change the codehash) and the implementation holder can be\n   * stored as a constant.\n   */\n  function getImplementationHolder() external view returns (address);\n\n  /**\n   * @dev Returns the address of the implementation holder contract\n   * for `implementationID`.\n   */\n  function getImplementationHolder(bytes32 implementationID) external view returns (address);\n\n  /**\n   * @dev Computes the create2 address for a one-to-one proxy requested\n   * by `originator` using `suppliedSalt`.\n   *\n   * @param originator Address of the account requesting deployment.\n   * @param suppliedSalt Salt provided by the account requesting deployment.\n   */\n  function computeProxyAddressOneToOne(\n    address originator,\n    bytes32 suppliedSalt\n  ) external view returns (address);\n\n  /**\n   * @dev Computes the create2 address for a many-to-one proxy for the\n   * implementation `implementationID` requested by `originator` using\n   * `suppliedSalt`.\n   *\n   * @param originator Address of the account requesting deployment.\n   * @param implementationID The identifier for the contract implementation.\n   * @param suppliedSalt Salt provided by the account requesting deployment.\n  */\n  function computeProxyAddressManyToOne(\n    address originator,\n    bytes32 implementationID,\n    bytes32 suppliedSalt\n  ) external view returns (address);\n\n  /**\n   * @dev Computes the create2 address of the implementation holder\n   * for `implementationID`.\n   *\n   * @param implementationID The identifier for the contract implementation.\n  */\n  function computeHolderAddressManyToOne(bytes32 implementationID) external view returns (address);\n}"
    },
    "contracts/interfaces/IPoolInitializer.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\n\n\ninterface IPoolInitializer {\n/* ========== Events ========== */\n\n  event TokensContributed(\n    address from,\n    address token,\n    uint256 amount,\n    uint256 credit\n  );\n\n/* ========== Mutative ========== */\n\n  function initialize(\n    address poolAddress,\n    address[] calldata tokens,\n    uint256[] calldata amounts\n  ) external;\n\n  function finish() external;\n\n  function claimTokens() external;\n\n  function claimTokens(address account) external;\n\n  function claimTokens(address[] calldata accounts) external;\n\n  function contributeTokens(\n    address token,\n    uint256 amountIn,\n    uint256 minimumCredit\n  ) external returns (uint256);\n\n  function contributeTokens(\n    address[] calldata tokens,\n    uint256[] calldata amountsIn,\n    uint256 minimumCredit\n  ) external returns (uint256);\n\n  function updatePrices() external;\n\n/* ========== Views ========== */\n\n  function isFinished() external view returns (bool);\n\n  function getTotalCredit() external view returns (uint256);\n\n  function getCreditOf(address account) external view returns (uint256);\n\n  function getDesiredTokens() external view returns (address[] memory);\n\n  function getDesiredAmount(address token) external view returns (uint256);\n\n  function getDesiredAmounts(address[] calldata tokens) external view returns (uint256[] memory);\n\n  function getCreditForTokens(address token, uint256 amountIn) external view returns (uint144);\n}"
    },
    "contracts/interfaces/IUnboundTokenSeller.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\n\ninterface IUnboundTokenSeller {\n/* ========== Events ========== */\n\n  event PremiumPercentSet(uint8 premium);\n\n  event NewTokensToSell(address indexed token, uint256 amountReceived);\n\n  event SwappedTokens(\n    address indexed tokenSold,\n    address indexed tokenBought,\n    uint256 soldAmount,\n    uint256 boughtAmount\n  );\n\n/* ========== Mutative ========== */\n\n  function initialize(address pool, uint8 premiumPercent) external;\n\n  function handleUnbindToken(address token, uint256 amount) external;\n\n  function setPremiumPercent(uint8 premiumPercent) external;\n\n  function executeSwapTokensForExactTokens(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountOut,\n    address[] calldata path\n  ) external returns (uint256);\n\n  function executeSwapExactTokensForTokens(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountIn,\n    address[] calldata path\n  ) external returns (uint256);\n\n  function swapExactTokensForTokens(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountIn,\n    uint256 minAmountOut\n  ) external returns (uint256);\n\n  function swapTokensForExactTokens(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountOut,\n    uint256 maxAmountIn\n  ) external returns (uint256);\n\n/* ========== Views ========== */\n\n  function getPremiumPercent() external view returns (uint8);\n\n  function calcInGivenOut(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountOut\n  ) external view returns (uint256);\n\n  function calcOutGivenIn(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountIn\n  ) external view returns (uint256);\n}"
    },
    "contracts/lib/Babylonian.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.0;\n\n\n/************************************************************************************************\nOriginally from https://github.com/Uniswap/uniswap-lib/blob/master/contracts/libraries/Babylonian.sol\n\nThis source code has been modified from the original, which was copied from the github repository\nat commit hash 9642a0705fdaf36b477354a4167a8cd765250860.\n\nSubject to the GPL-3.0 license\n*************************************************************************************************/\n\n\n// computes square roots using the babylonian method\n// https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\nlibrary Babylonian {\n  function sqrt(uint y) internal pure returns (uint z) {\n    if (y > 3) {\n      z = y;\n      uint x = (y + 1) / 2;\n      while (x < z) {\n        z = x;\n        x = (y / x + x) / 2;\n      }\n    } else if (y != 0) {\n      z = 1;\n    }\n    // else z = 0\n  }\n}\n"
    },
    "contracts/lib/MCapSqrtLibrary.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\n/* ========== External Interfaces ========== */\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/* ========== External Libraries ========== */\nimport \"@indexed-finance/uniswap-v2-oracle/contracts/lib/PriceLibrary.sol\";\nimport \"@indexed-finance/uniswap-v2-oracle/contracts/lib/FixedPoint.sol\";\n\n/* ========== Internal Libraries ========== */\nimport \"./Babylonian.sol\";\n\n\nlibrary MCapSqrtLibrary {\n  using Babylonian for uint256;\n  using FixedPoint for FixedPoint.uq112x112;\n  using FixedPoint for FixedPoint.uq144x112;\n  using PriceLibrary for PriceLibrary.TwoWayAveragePrice;\n\n  /**\n   * @dev Compute the average market cap of a token by extrapolating the\n   * average price to the token's total supply.\n   * @param token Address of the ERC20 token\n   * @param averagePrice Two-way average price of the token (token-weth & weth-token).\n   * @return Extrapolated average market cap.\n   */\n  function computeAverageMarketCap(\n    address token,\n    PriceLibrary.TwoWayAveragePrice memory averagePrice\n  ) internal view returns (uint144) {\n    uint256 totalSupply = IERC20(token).totalSupply();\n    return averagePrice.computeAverageEthForTokens(totalSupply);\n  }\n\n  /**\n   * @dev Calculate the square roots of the market caps of the indexed tokens.\n   * @param tokens Array of ERC20 tokens to get the market cap square roots for.\n   * @param averagePrices Array of two-way average prices of each token.\n   *  - Must be in the same order as the tokens array.\n   * @return sqrts Array of market cap square roots for the provided tokens.\n   */\n  function computeMarketCapSqrts(\n    address[] memory tokens,\n    PriceLibrary.TwoWayAveragePrice[] memory averagePrices\n  ) internal view returns (uint112[] memory sqrts) {\n    uint256 len = tokens.length;\n    sqrts = new uint112[](len);\n    for (uint256 i = 0; i < len; i++) {\n      uint256 marketCap = computeAverageMarketCap(tokens[i], averagePrices[i]);\n      sqrts[i] = uint112(marketCap.sqrt());\n    }\n  }\n\n    /**\n   * @dev Calculate the weights of the provided tokens.\n   * The weight of a token is the square root of its market cap\n   * divided by the sum of market cap square roots.\n   * @param tokens Array of ERC20 tokens to weigh\n   * @param averagePrices Array of average prices from UniSwap for the tokens array.\n   * @return weights Array of token weights represented as fractions of the sum of roots.\n   */\n  function computeTokenWeights(\n    address[] memory tokens,\n    PriceLibrary.TwoWayAveragePrice[] memory averagePrices\n  ) internal view returns (FixedPoint.uq112x112[] memory weights) {\n    // Get the square roots of token market caps\n    uint112[] memory sqrts = computeMarketCapSqrts(tokens, averagePrices);\n    uint112 rootSum;\n    uint256 len = sqrts.length;\n    // Calculate the sum of square roots\n    // Will not overflow - would need 72057594037927940 tokens in the index\n    // before the sum of sqrts of a uint112 could overflow\n    for (uint256 i = 0; i < len; i++) rootSum += sqrts[i];\n    // Initialize the array of weights\n    weights = new FixedPoint.uq112x112[](len);\n    // Calculate the token weights as fractions of the root sum.\n    for (uint256 i = 0; i < len; i++) {\n      weights[i] = FixedPoint.fraction(sqrts[i], rootSum);\n    }\n  }\n\n  /**\n   * @dev Computes the weighted balance of a token relative to the\n   * total value of the index. Multiplies the total value by the weight,\n   * then multiplies by the reciprocal of the price (equivalent to dividing\n   * by price, but without rounding the price).\n   * @param totalValue Total value of the index in the stablecoin\n   * @param weight Fraction of the total value that should be held in the token.\n   * @param averagePrice Two-way average price of the token.\n   * @return weightedBalance Desired balance of the token based on the weighted value.\n   */\n  function computeWeightedBalance(\n    uint144 totalValue,\n    FixedPoint.uq112x112 memory weight,\n    PriceLibrary.TwoWayAveragePrice memory averagePrice\n  ) internal pure returns (uint144 weightedBalance) {\n    uint144 desiredWethValue = weight.mul(totalValue).decode144();\n    // Multiply by reciprocal to avoid rounding in intermediary steps.\n    return averagePrice.computeAverageTokensForEth(desiredWethValue);\n  }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/lib/UniswapV2Library.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.6.0;\n\n/* ========== External Interfaces ========== */\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\n\n/* ========== External Libraries ========== */\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n/************************************************************************************************\nOriginally from https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/libraries/UniswapV2Library.sol\n\nThis source code has been modified from the original, which was copied from the github repository\nat commit hash 87edfdcaf49ccc52591502993db4c8c08ea9eec0.\n\nSubject to the GPL-3.0 license\n*************************************************************************************************/\n\n\nlibrary UniswapV2Library {\n  using SafeMath for uint256;\n\n  // returns sorted token addresses, used to handle return values from pairs sorted in this order\n  function sortTokens(address tokenA, address tokenB)\n    internal\n    pure\n    returns (address token0, address token1)\n  {\n    require(tokenA != tokenB, \"UniswapV2Library: IDENTICAL_ADDRESSES\");\n    (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n    require(token0 != address(0), \"UniswapV2Library: ZERO_ADDRESS\");\n  }\n\n  function calculatePair(\n    address factory,\n    address token0,\n    address token1\n  ) internal pure returns (address pair) {\n    pair = address(\n      uint256(\n        keccak256(\n          abi.encodePacked(\n            hex\"ff\",\n            factory,\n            keccak256(abi.encodePacked(token0, token1)),\n            hex\"96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f\" // init code hash\n          )\n        )\n      )\n    );\n  }\n\n  // calculates the CREATE2 address for a pair without making any external calls\n  function pairFor(\n    address factory,\n    address tokenA,\n    address tokenB\n  ) internal pure returns (address pair) {\n    (address token0, address token1) = sortTokens(tokenA, tokenB);\n    pair = calculatePair(factory, token0, token1);\n  }\n\n  function getCumulativePriceLast(\n    address factory,\n    address tokenIn,\n    address tokenOut\n  ) internal view returns (uint256) {\n    (address token0, address token1) = sortTokens(tokenIn, tokenOut);\n    IUniswapV2Pair pair = IUniswapV2Pair(\n      calculatePair(factory, token0, token1)\n    );\n    if (token0 == tokenIn) return pair.price0CumulativeLast();\n    return pair.price1CumulativeLast();\n  }\n\n  // fetches and sorts the reserves for a pair\n  function getReserves(\n    address factory,\n    address tokenA,\n    address tokenB\n  ) internal view returns (uint256 reserveA, uint256 reserveB) {\n    (address token0, ) = sortTokens(tokenA, tokenB);\n    (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(\n      pairFor(factory, tokenA, tokenB)\n    )\n      .getReserves();\n    (reserveA, reserveB) = tokenA == token0\n      ? (reserve0, reserve1)\n      : (reserve1, reserve0);\n  }\n\n  // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n  function quote(\n    uint256 amountA,\n    uint256 reserveA,\n    uint256 reserveB\n  ) internal pure returns (uint256 amountB) {\n    require(amountA > 0, \"UniswapV2Library: INSUFFICIENT_AMOUNT\");\n    require(\n      reserveA > 0 && reserveB > 0,\n      \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\"\n    );\n    amountB = amountA.mul(reserveB) / reserveA;\n  }\n\n  // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n  function getAmountOut(\n    uint256 amountIn,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) internal pure returns (uint256 amountOut) {\n    require(amountIn > 0, \"UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT\");\n    require(\n      reserveIn > 0 && reserveOut > 0,\n      \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\"\n    );\n    uint256 amountInWithFee = amountIn.mul(997);\n    uint256 numerator = amountInWithFee.mul(reserveOut);\n    uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\n    amountOut = numerator / denominator;\n  }\n\n  // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n  function getAmountIn(\n    uint256 amountOut,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) internal pure returns (uint256 amountIn) {\n    require(amountOut > 0, \"UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT\");\n    require(\n      reserveIn > 0 && reserveOut > 0,\n      \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\"\n    );\n    uint256 numerator = reserveIn.mul(amountOut).mul(1000);\n    uint256 denominator = reserveOut.sub(amountOut).mul(997);\n    amountIn = (numerator / denominator).add(1);\n  }\n\n  // performs chained getAmountOut calculations on any number of pairs\n  function getAmountsOut(\n    address factory,\n    uint256 amountIn,\n    address[] memory path\n  ) internal view returns (uint256[] memory amounts) {\n    require(path.length >= 2, \"UniswapV2Library: INVALID_PATH\");\n    amounts = new uint256[](path.length);\n    amounts[0] = amountIn;\n    for (uint256 i; i < path.length - 1; i++) {\n      (uint256 reserveIn, uint256 reserveOut) = getReserves(\n        factory,\n        path[i],\n        path[i + 1]\n      );\n      amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n    }\n  }\n\n  // performs chained getAmountIn calculations on any number of pairs\n  function getAmountsIn(\n    address factory,\n    uint256 amountOut,\n    address[] memory path\n  ) internal view returns (uint256[] memory amounts) {\n    require(path.length >= 2, \"UniswapV2Library: INVALID_PATH\");\n    amounts = new uint256[](path.length);\n    amounts[amounts.length - 1] = amountOut;\n    for (uint256 i = path.length - 1; i > 0; i--) {\n      (uint256 reserveIn, uint256 reserveOut) = getReserves(\n        factory,\n        path[i - 1],\n        path[i]\n      );\n      amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n    }\n  }\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/MarketCapSortedTokenCategories.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\n/* ========== External Inheritance ========== */\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/* ========== External Interfaces ========== */\nimport \"@indexed-finance/uniswap-v2-oracle/contracts/interfaces/IIndexedUniswapV2Oracle.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n\n/**\n * @title MarketCapSortedCategories\n * @author d1ll0n\n *\n * @dev This contract stores token categories created by the contract owner.\n * Token categories are sorted by their fully diluted market caps, which is\n * extrapolated by multiplying each token's total supply by its moving\n * average weth price on UniSwap.\n *\n * Categories are periodically sorted, ranking their tokens in descending order by\n * market cap.\n *\n * CRITERIA\n * ===============\n * To be added to a category, a token should meet the following requirements in addition\n * to any other criteria for the particular category:\n *\n * 1. The token is at least a week old.\n * 2. The token complies with the ERC20 standard (boolean return values not required)\n * 3. No major vulnerabilities have been discovered in the token contract.\n * 4. The token does not have a deflationary supply model.\n * 5. The token's supply can not be arbitrarily inflated or deflated maliciously.\n * 5.a. The control model should be considered if the supply can be modified arbitrarily.\n * ===============\n */\ncontract MarketCapSortedTokenCategories is Ownable {\n/* ==========  Constants  ========== */\n\n  // TWAP parameters for capturing long-term price trends\n  uint32 internal constant LONG_TWAP_MIN_TIME_ELAPSED = 1 days;\n  uint32 internal constant LONG_TWAP_MAX_TIME_ELAPSED = 1.5 weeks;\n\n  // TWAP parameters for assessing current price\n  uint32 internal constant SHORT_TWAP_MIN_TIME_ELAPSED = 20 minutes;\n  uint32 internal constant SHORT_TWAP_MAX_TIME_ELAPSED = 2 days;\n\n  // Maximum time between a category being sorted and a query for the top n tokens\n  uint256 internal constant MAX_SORT_DELAY = 1 days;\n\n  // Maximum number of tokens in a category\n  uint256 internal constant MAX_CATEGORY_TOKENS = 25;\n\n  // Long term price oracle\n  IIndexedUniswapV2Oracle public immutable oracle;\n\n/* ==========  Events  ========== */\n\n  /** @dev Emitted when a new category is created. */\n  event CategoryAdded(uint256 categoryID, bytes32 metadataHash);\n\n  /** @dev Emitted when a category is sorted. */\n  event CategorySorted(uint256 categoryID);\n\n  /** @dev Emitted when a token is added to a category. */\n  event TokenAdded(address token, uint256 categoryID);\n\n/* ==========  Storage  ========== */\n\n  // Number of categories that exist.\n  uint256 public categoryIndex;\n  // Array of tokens for each category.\n  mapping(uint256 => address[]) internal _categoryTokens;\n  mapping(uint256 => mapping(address => bool)) internal _isCategoryToken;\n  // Last time a category was sorted\n  mapping(uint256 => uint256) internal _lastCategoryUpdate;\n\n/* ========== Modifiers ========== */\n\n  modifier validCategory(uint256 categoryID) {\n    require(categoryID <= categoryIndex && categoryID > 0, \"ERR_CATEGORY_ID\");\n    _;\n  }\n\n/* ==========  Constructor  ========== */\n\n  /**\n   * @dev Deploy the controller and configure the addresses\n   * of the related contracts.\n   */\n  constructor(IIndexedUniswapV2Oracle _oracle) public Ownable() {\n    oracle = _oracle;\n  }\n\n/* ==========  Category Management  ========== */\n\n  /**\n   * @dev Updates the prices on the oracle for all the tokens in a category.\n   */\n  function updateCategoryPrices(uint256 categoryID) external validCategory(categoryID) returns (bool[] memory pricesUpdated) {\n    address[] memory tokens = _categoryTokens[categoryID];\n    pricesUpdated = oracle.updatePrices(tokens);\n  }\n\n  /**\n   * @dev Creates a new token category.\n   * @param metadataHash Hash of metadata about the token category\n   * which can be distributed on IPFS.\n   */\n  function createCategory(bytes32 metadataHash) external onlyOwner {\n    uint256 categoryID = ++categoryIndex;\n    emit CategoryAdded(categoryID, metadataHash);\n  }\n\n  /**\n   * @dev Adds a new token to a category.\n   * Note: A token can only be assigned to one category at a time.\n   */\n  function addToken(address token, uint256 categoryID) external onlyOwner validCategory(categoryID) {\n    require(\n      _categoryTokens[categoryID].length < MAX_CATEGORY_TOKENS,\n      \"ERR_MAX_CATEGORY_TOKENS\"\n    );\n    _addToken(token, categoryID);\n    oracle.updatePrice(token);\n    // Decrement the timestamp for the last category update to ensure\n    // that the new token is sorted before the category's top tokens\n    // can be queried.\n    _lastCategoryUpdate[categoryID] -= MAX_SORT_DELAY;\n  }\n\n  /**\n   * @dev Add tokens to a category.\n   * @param categoryID Category identifier.\n   * @param tokens Array of tokens to add to the category.\n   */\n  function addTokens(uint256 categoryID, address[] calldata tokens)\n    external\n    onlyOwner\n    validCategory(categoryID)\n  {\n    require(\n      _categoryTokens[categoryID].length + tokens.length <= MAX_CATEGORY_TOKENS,\n      \"ERR_MAX_CATEGORY_TOKENS\"\n    );\n    for (uint256 i = 0; i < tokens.length; i++) {\n      _addToken(tokens[i], categoryID);\n    }\n    oracle.updatePrices(tokens);\n    // Decrement the timestamp for the last category update to ensure\n    // that the new tokens are sorted before the category's top tokens\n    // can be queried.\n    _lastCategoryUpdate[categoryID] -= MAX_SORT_DELAY;\n  }\n\n  function removeToken(uint256 categoryID, address token) external onlyOwner validCategory(categoryID) {\n    uint256 i = 0;\n    uint256 len = _categoryTokens[categoryID].length;\n    require(len > 0, \"ERR_EMPTY_CATEGORY\");\n    for (; i < len; i++) {\n      if (_categoryTokens[categoryID][i] == token) {\n        uint256 last = len - 1;\n        if (i != last) {\n          address lastToken = _categoryTokens[categoryID][last];\n          _categoryTokens[categoryID][i] = lastToken;\n        }\n        _lastCategoryUpdate[categoryID] -= MAX_SORT_DELAY;\n        _categoryTokens[categoryID].pop();\n        return;\n      }\n    }\n    revert(\"ERR_TOKEN_NOT_FOUND\");\n  }\n\n  /**\n   * @dev Sorts a category's tokens in descending order by market cap.\n   * Note: Uses in-memory insertion sort.\n   *\n   * @param categoryID Category to sort\n   */\n  function orderCategoryTokensByMarketCap(uint256 categoryID) external validCategory(categoryID) {\n    address[] memory categoryTokens = _categoryTokens[categoryID];\n    uint256 len = categoryTokens.length;\n    uint144[] memory marketCaps = computeAverageMarketCaps(categoryTokens);\n    for (uint256 i = 1; i < len; i++) {\n      uint144 cap = marketCaps[i];\n      address token = categoryTokens[i];\n      uint256 j = i - 1;\n      while (int(j) >= 0 && marketCaps[j] < cap) {\n        marketCaps[j + 1] = marketCaps[j];\n        categoryTokens[j + 1] = categoryTokens[j];\n        j--;\n      }\n      marketCaps[j + 1] = cap;\n      categoryTokens[j + 1] = token;\n    }\n    _categoryTokens[categoryID] = categoryTokens;\n    \n    _lastCategoryUpdate[categoryID] = now;\n    emit CategorySorted(categoryID);\n  }\n\n/* ==========  Market Cap Queries  ========== */\n\n  /**\n   * @dev Compute the average market cap of a token in weth.\n   * Queries the average amount of ether that the total supply is worth\n   * using the recent moving average price.\n   */\n  function computeAverageMarketCap(address token)\n    public\n    view\n    returns (uint144)\n  {\n    uint256 totalSupply = IERC20(token).totalSupply();\n    return oracle.computeAverageEthForTokens(\n      token,\n      totalSupply,\n      LONG_TWAP_MIN_TIME_ELAPSED,\n      LONG_TWAP_MAX_TIME_ELAPSED\n    ); \n  }\n\n  /**\n   * @dev Returns the average market cap for each token.\n   */\n  function computeAverageMarketCaps(address[] memory tokens)\n    public\n    view\n    returns (uint144[] memory marketCaps)\n  {\n    uint256 len = tokens.length;\n    uint256[] memory totalSupplies = new uint256[](len);\n    for (uint256 i = 0; i < len; i++) {\n      totalSupplies[i] = IERC20(tokens[i]).totalSupply();\n    }\n    marketCaps = oracle.computeAverageEthForTokens(\n      tokens,\n      totalSupplies,\n      LONG_TWAP_MIN_TIME_ELAPSED,\n      LONG_TWAP_MAX_TIME_ELAPSED\n    );\n  }\n\n/* ==========  Category Queries  ========== */\n\n  /**\n   * @dev Returns a boolean stating whether a category exists.\n   */\n  function hasCategory(uint256 categoryID) external view returns (bool) {\n    return categoryID <= categoryIndex && categoryID > 0;\n  }\n\n  /**\n   * @dev Returns the timestamp of the last time the category was sorted.\n   */\n  function getLastCategoryUpdate(uint256 categoryID)\n    external\n    view\n    validCategory(categoryID)\n    returns (uint256)\n  {\n    return _lastCategoryUpdate[categoryID];\n  }\n\n  /**\n   * @dev Returns boolean stating whether `token` is a member of the category `categoryID`.\n   */\n  function isTokenInCategory(uint256 categoryID, address token)\n    external\n    view\n    validCategory(categoryID)\n    returns (bool)\n  {\n    return _isCategoryToken[categoryID][token];\n  }\n\n  /**\n   * @dev Returns the array of tokens in a category.\n   */\n  function getCategoryTokens(uint256 categoryID)\n    external\n    view\n    validCategory(categoryID)\n    returns (address[] memory tokens)\n  {\n    address[] storage _tokens = _categoryTokens[categoryID];\n    tokens = new address[](_tokens.length);\n    for (uint256 i = 0; i < tokens.length; i++) {\n      tokens[i] = _tokens[i];\n    }\n  }\n\n  /**\n   * @dev Returns the fully diluted market caps for the tokens in a category.\n   */\n  function getCategoryMarketCaps(uint256 categoryID)\n    external\n    view\n    validCategory(categoryID)\n    returns (uint144[] memory marketCaps)\n  {\n    return computeAverageMarketCaps(_categoryTokens[categoryID]);\n  }\n\n  /**\n   * @dev Get the top `num` tokens in a category.\n   *\n   * Note: The category must have been sorted by market cap\n   * in the last `MAX_SORT_DELAY` seconds.\n   */\n  function getTopCategoryTokens(uint256 categoryID, uint256 num)\n    public\n    view\n    validCategory(categoryID)\n    returns (address[] memory tokens)\n  {\n    address[] storage categoryTokens = _categoryTokens[categoryID];\n    require(num <= categoryTokens.length, \"ERR_CATEGORY_SIZE\");\n    require(\n      now - _lastCategoryUpdate[categoryID] <= MAX_SORT_DELAY,\n      \"ERR_CATEGORY_NOT_READY\"\n    );\n    tokens = new address[](num);\n    for (uint256 i = 0; i < num; i++) tokens[i] = categoryTokens[i];\n  }\n\n/* ==========  Category Utility Functions  ========== */\n\n  /**\n   * @dev Adds a new token to a category.\n   */\n  function _addToken(address token, uint256 categoryID) internal {\n    require(!_isCategoryToken[categoryID][token], \"ERR_TOKEN_BOUND\");\n    _isCategoryToken[categoryID][token] = true;\n    _categoryTokens[categoryID].push(token);\n    emit TokenAdded(token, categoryID);\n  }\n}"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"../GSN/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "@openzeppelin/contracts/GSN/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "contracts/MarketCapSqrtController.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\n/* ========== External Interfaces ========== */\nimport \"@indexed-finance/uniswap-v2-oracle/contracts/interfaces/IIndexedUniswapV2Oracle.sol\";\nimport \"@indexed-finance/proxies/contracts/interfaces/IDelegateCallProxyManager.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/* ========== External Libraries ========== */\nimport \"@indexed-finance/uniswap-v2-oracle/contracts/lib/PriceLibrary.sol\";\nimport \"@indexed-finance/uniswap-v2-oracle/contracts/lib/FixedPoint.sol\";\nimport \"@indexed-finance/proxies/contracts/SaltyLib.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n/* ========== Internal Interfaces ========== */\nimport \"./interfaces/IIndexPool.sol\";\nimport \"./interfaces/IPoolFactory.sol\";\nimport \"./interfaces/IPoolInitializer.sol\";\nimport \"./interfaces/IUnboundTokenSeller.sol\";\n\n/* ========== Internal Libraries ========== */\nimport \"./lib/MCapSqrtLibrary.sol\";\n\n/* ========== Internal Inheritance ========== */\nimport \"./MarketCapSortedTokenCategories.sol\";\n\n\n/**\n * @title MarketCapSqrtController\n * @author d1ll0n\n * @dev This contract implements the market cap square root index management strategy.\n *\n * Index pools have a defined size which is used to select the top tokens from the pool's\n * category.\n *\n * REBALANCING\n * ===============\n * Every 1 weeks, pools are either re-weighed or re-indexed.\n * They are re-indexed once for every three re-weighs.\n *\n * Re-indexing involves selecting the top tokens from the pool's category and weighing them\n * by the square root of their market caps.\n * Re-weighing involves weighing the tokens which are already indexed by the pool by the\n * square root of their market caps.\n * When a pool is re-weighed, only the tokens with a desired weight above 0 are included.\n * ===============\n */\ncontract MarketCapSqrtController is MarketCapSortedTokenCategories {\n  using FixedPoint for FixedPoint.uq112x112;\n  using FixedPoint for FixedPoint.uq144x112;\n  using SafeMath for uint256;\n  using PriceLibrary for PriceLibrary.TwoWayAveragePrice;\n\n/* ==========  Constants  ========== */\n  // Minimum number of tokens in an index.\n  uint256 internal constant MIN_INDEX_SIZE = 2;\n\n  // Maximum number of tokens in an index.\n  uint256 internal constant MAX_INDEX_SIZE = 10;\n\n  // Identifier for the pool initializer implementation on the proxy manager.\n  bytes32 internal constant INITIALIZER_IMPLEMENTATION_ID = keccak256(\"PoolInitializer.sol\");\n\n  // Identifier for the unbound token seller implementation on the proxy manager.\n  bytes32 internal constant SELLER_IMPLEMENTATION_ID = keccak256(\"UnboundTokenSeller.sol\");\n\n  // Identifier for the index pool implementation on the proxy manager.\n  bytes32 internal constant POOL_IMPLEMENTATION_ID = keccak256(\"IndexPool.sol\");\n\n  // Default total weight for a pool.\n  uint256 internal constant WEIGHT_MULTIPLIER = 25e18;\n\n  // Time between reweigh/reindex calls.\n  uint256 internal constant POOL_REWEIGH_DELAY = 1 weeks;\n\n  // The number of reweighs which occur before a pool is re-indexed.\n  uint256 internal constant REWEIGHS_BEFORE_REINDEX = 3;\n\n  // Pool factory contract\n  IPoolFactory internal immutable _factory;\n\n  // Proxy manager & factory\n  IDelegateCallProxyManager internal immutable _proxyManager;\n\n/* ==========  Events  ========== */\n\n  /** @dev Emitted when a pool is initialized and made public. */\n  event PoolInitialized(\n    address pool,\n    address unboundTokenSeller,\n    uint256 categoryID,\n    uint256 indexSize\n  );\n\n  /** @dev Emitted when a pool and its initializer are deployed. */\n  event NewPoolInitializer(\n    address pool,\n    address initializer,\n    uint256 categoryID,\n    uint256 indexSize\n  );\n\n/* ==========  Structs  ========== */\n\n  /**\n   * @dev Data structure with metadata about an index pool.\n   *\n   * Includes the number of times a pool has been either reweighed\n   * or re-indexed, as well as the timestamp of the last such action.\n   *\n   * To reweigh or re-index, the last update must have occurred at\n   * least `POOL_REWEIGH_DELAY` seconds ago.\n   *\n   * If `++index % REWEIGHS_BEFORE_REINDEX + 1` is 0, the pool will\n   * re-index, otherwise it will reweigh.\n   *\n   * The struct fields are assigned their respective integer sizes so\n   * that solc can pack the entire struct into a single storage slot.\n   * `reweighIndex` is intended to overflow, `categoryID` will never\n   * reach 2**16, `indexSize` is capped at 10 and it is unlikely that\n   * this protocol will be in use in the year 292277026596 (unix time\n   * for 2**64 - 1).\n   *\n   * @param initialized Whether the pool has been initialized with the\n   * starting balances.\n   * @param categoryID Category identifier for the pool.\n   * @param indexSize Number of tokens the pool should hold.\n   * @param reweighIndex Number of times the pool has either re-weighed\n   * or re-indexed.\n   * @param lastReweigh Timestamp of last pool re-weigh or re-index.\n   */\n  struct IndexPoolMeta {\n    bool initialized;\n    uint16 categoryID;\n    uint8 indexSize;\n    uint8 reweighIndex;\n    uint64 lastReweigh;\n  }\n\n/* ==========  Storage  ========== */\n\n  // Default slippage rate for token seller contracts.\n  uint8 public defaultSellerPremium = 2;\n\n  // Metadata about index pools\n  mapping(address => IndexPoolMeta) internal _poolMeta;\n\n/* ========== Modifiers ========== */\n\n  modifier _havePool(address pool) {\n    require(_poolMeta[pool].initialized, \"ERR_POOL_NOT_FOUND\");\n    _;\n  }\n\n/* ==========  Constructor  ========== */\n\n  /**\n   * @dev Deploy the controller and configure the addresses\n   * of the related contracts.\n   */\n  constructor(\n    IIndexedUniswapV2Oracle oracle,\n    IPoolFactory factory,\n    IDelegateCallProxyManager proxyManager\n  )\n    public\n    MarketCapSortedTokenCategories(oracle)\n  {\n    _factory = factory;\n    _proxyManager = proxyManager;\n  }\n\n/* ==========  Pool Deployment  ========== */\n\n  /**\n   * @dev Deploys an index pool and a pool initializer.\n   * The initializer contract is a pool with specific token\n   * balance targets which gives pool tokens in the finished\n   * pool to users who provide the underlying tokens needed\n   * to initialize it.\n   */\n  function prepareIndexPool(\n    uint256 categoryID,\n    uint256 indexSize,\n    uint256 initialWethValue,\n    string calldata name,\n    string calldata symbol\n  )\n    external\n    onlyOwner\n    returns (address poolAddress, address initializerAddress)\n  {\n    require(indexSize >= MIN_INDEX_SIZE, \"ERR_MIN_INDEX_SIZE\");\n    require(indexSize <= MAX_INDEX_SIZE, \"ERR_MAX_INDEX_SIZE\");\n    require(initialWethValue < uint144(-1), \"ERR_MAX_UINT144\");\n\n    poolAddress = _factory.deployPool(\n      POOL_IMPLEMENTATION_ID,\n      keccak256(abi.encodePacked(categoryID, indexSize))\n    );\n    IIndexPool(poolAddress).configure(address(this), name, symbol);\n\n    _poolMeta[poolAddress] = IndexPoolMeta({\n      initialized: false,\n      categoryID: uint16(categoryID),\n      indexSize: uint8(indexSize),\n      lastReweigh: 0,\n      reweighIndex: 0\n    });\n\n    initializerAddress = _proxyManager.deployProxyManyToOne(\n      INITIALIZER_IMPLEMENTATION_ID,\n      keccak256(abi.encodePacked(poolAddress))\n    );\n\n    IPoolInitializer initializer = IPoolInitializer(initializerAddress);\n\n    // Get the initial tokens and balances for the pool.\n    (\n      address[] memory tokens,\n      uint256[] memory balances\n    ) = getInitialTokensAndBalances(categoryID, indexSize, uint144(initialWethValue));\n\n    initializer.initialize(poolAddress, tokens, balances);\n\n    emit NewPoolInitializer(\n      poolAddress,\n      initializerAddress,\n      categoryID,\n      indexSize\n    );\n  }\n\n  /**\n   * @dev Initializes a pool which has been deployed but not initialized\n   * and transfers the underlying tokens from the initialization pool to\n   * the actual pool.\n   */\n  function finishPreparedIndexPool(\n    address poolAddress,\n    address[] calldata tokens,\n    uint256[] calldata balances\n  ) external {\n    require(\n      msg.sender == computeInitializerAddress(poolAddress),\n      \"ERR_NOT_PRE_DEPLOY_POOL\"\n    );\n    uint256 len = tokens.length;\n    require(balances.length == len, \"ERR_ARR_LEN\");\n\n    IndexPoolMeta memory meta = _poolMeta[poolAddress];\n    require(!meta.initialized, \"ERR_INITIALIZED\");\n    uint96[] memory denormalizedWeights = new uint96[](len);\n    uint256 valueSum;\n    uint144[] memory ethValues = oracle.computeAverageEthForTokens(\n      tokens,\n      balances,\n      SHORT_TWAP_MIN_TIME_ELAPSED,\n      SHORT_TWAP_MAX_TIME_ELAPSED\n    );\n    for (uint256 i = 0; i < len; i++) {\n      valueSum = valueSum.add(ethValues[i]);\n    }\n    for (uint256 i = 0; i < len; i++) {\n      denormalizedWeights[i] = _denormalizeFractionalWeight(\n        FixedPoint.fraction(uint112(ethValues[i]), uint112(valueSum))\n      );\n    }\n\n    address sellerAddress = _proxyManager.deployProxyManyToOne(\n      SELLER_IMPLEMENTATION_ID,\n      keccak256(abi.encodePacked(poolAddress))\n    );\n\n    IIndexPool(poolAddress).initialize(\n      tokens,\n      balances,\n      denormalizedWeights,\n      msg.sender,\n      sellerAddress\n    );\n\n    IUnboundTokenSeller(sellerAddress).initialize(\n      poolAddress,\n      defaultSellerPremium\n    );\n\n    meta.lastReweigh = uint64(now);\n    meta.initialized = true;\n    _poolMeta[poolAddress] = meta;\n\n    emit PoolInitialized(\n      poolAddress,\n      sellerAddress,\n      meta.categoryID,\n      meta.indexSize\n    );\n  }\n\n/* ==========  Pool Management  ========== */\n\n  /**\n   * @dev Sets the default premium rate for token seller contracts.\n   */\n  function setDefaultSellerPremium(\n    uint8 _defaultSellerPremium\n  ) external onlyOwner {\n    require(_defaultSellerPremium > 0 && _defaultSellerPremium < 20, \"ERR_PREMIUM\");\n    defaultSellerPremium = _defaultSellerPremium;\n  }\n\n  /**\n   * @dev Set the premium rate on `sellerAddress` to the given rate.\n   */\n  function updateSellerPremium(address tokenSeller, uint8 premiumPercent) external onlyOwner {\n    require(premiumPercent > 0 && premiumPercent < 20, \"ERR_PREMIUM\");\n    IUnboundTokenSeller(tokenSeller).setPremiumPercent(premiumPercent);\n  }\n\n  /**\n   * @dev Sets the maximum number of pool tokens that can be minted\n   * for a particular pool.\n   *\n   * This value will be used in the alpha to limit the maximum damage\n   * that can be caused by a catastrophic error. It can be gradually\n   * increased as the pool continues to not be exploited.\n   *\n   * If it is set to 0, the limit will be removed.\n   *\n   * @param poolAddress Address of the pool to set the limit on.\n   * @param maxPoolTokens Maximum LP tokens the pool can mint.\n   */\n  function setMaxPoolTokens(\n    address poolAddress,\n    uint256 maxPoolTokens\n  ) external onlyOwner _havePool(poolAddress) {\n    IIndexPool(poolAddress).setMaxPoolTokens(maxPoolTokens);\n  }\n\n  /**\n   * @dev Sets the swap fee on an index pool.\n   */\n  function setSwapFee(address poolAddress, uint256 swapFee) external onlyOwner _havePool(poolAddress) {\n    IIndexPool(poolAddress).setSwapFee(swapFee);\n  }\n\n  /**\n   * @dev Updates the minimum balance of an uninitialized token, which is\n   * useful when the token's price on the pool is too low relative to\n   * external prices for people to trade it in.\n   */\n  function updateMinimumBalance(IIndexPool pool, address tokenAddress) external _havePool(address(pool)) {\n    IIndexPool.Record memory record = pool.getTokenRecord(tokenAddress);\n    require(!record.ready, \"ERR_TOKEN_READY\");\n    uint256 poolValue = _estimatePoolValue(pool);\n    PriceLibrary.TwoWayAveragePrice memory price = oracle.computeTwoWayAveragePrice(\n      tokenAddress,\n      SHORT_TWAP_MIN_TIME_ELAPSED,\n      SHORT_TWAP_MAX_TIME_ELAPSED\n    );\n    uint256 minimumBalance = price.computeAverageTokensForEth(poolValue) / 100;\n    pool.setMinimumBalance(tokenAddress, minimumBalance);\n  }\n\n/* ==========  Pool Rebalance Actions  ========== */\n\n  /**\n   * @dev Re-indexes a pool by setting the underlying assets to the top\n   * tokens in its category by market cap.\n   */\n  function reindexPool(address poolAddress) external {\n    IndexPoolMeta memory meta = _poolMeta[poolAddress];\n    require(meta.initialized, \"ERR_POOL_NOT_FOUND\");\n    require(\n      now - meta.lastReweigh >= POOL_REWEIGH_DELAY,\n      \"ERR_POOL_REWEIGH_DELAY\"\n    );\n    require(\n      (++meta.reweighIndex % (REWEIGHS_BEFORE_REINDEX + 1)) == 0,\n      \"ERR_REWEIGH_INDEX\"\n    );\n    uint256 size = meta.indexSize;\n    address[] memory tokens = getTopCategoryTokens(meta.categoryID, size);\n  \n    PriceLibrary.TwoWayAveragePrice[] memory prices = oracle.computeTwoWayAveragePrices(\n      tokens,\n      LONG_TWAP_MIN_TIME_ELAPSED,\n      LONG_TWAP_MAX_TIME_ELAPSED\n    );\n    FixedPoint.uq112x112[] memory weights = MCapSqrtLibrary.computeTokenWeights(tokens, prices);\n\n    uint256[] memory minimumBalances = new uint256[](size);\n    uint96[] memory denormalizedWeights = new uint96[](size);\n    uint144 totalValue = _estimatePoolValue(IIndexPool(poolAddress));\n\n    for (uint256 i = 0; i < size; i++) {\n      // The minimum balance is the number of tokens worth the minimum weight\n      // of the pool. The minimum weight is 1/100, so we divide the total value\n      // by 100 to get the desired weth value, then multiply by the price of eth\n      // in terms of that token to get the minimum balance.\n      minimumBalances[i] = prices[i].computeAverageTokensForEth(totalValue) / 100;\n      denormalizedWeights[i] = _denormalizeFractionalWeight(weights[i]);\n    }\n\n    meta.lastReweigh = uint64(now);\n    _poolMeta[poolAddress] = meta;\n\n    IIndexPool(poolAddress).reindexTokens(\n      tokens,\n      denormalizedWeights,\n      minimumBalances\n    );\n  }\n\n  /**\n   * @dev Reweighs the assets in a pool by market cap and sets the\n   * desired new weights, which will be adjusted over time.\n   */\n  function reweighPool(address poolAddress) external {\n    IndexPoolMeta memory meta = _poolMeta[poolAddress];\n    require(meta.initialized, \"ERR_POOL_NOT_FOUND\");\n\n    require(\n      now - meta.lastReweigh >= POOL_REWEIGH_DELAY,\n      \"ERR_POOL_REWEIGH_DELAY\"\n    );\n\n    require(\n      (++meta.reweighIndex % (REWEIGHS_BEFORE_REINDEX + 1)) != 0,\n      \"ERR_REWEIGH_INDEX\"\n    );\n\n    address[] memory tokens = IIndexPool(poolAddress).getCurrentDesiredTokens();\n    PriceLibrary.TwoWayAveragePrice[] memory prices = oracle.computeTwoWayAveragePrices(\n      tokens,\n      LONG_TWAP_MIN_TIME_ELAPSED,\n      LONG_TWAP_MAX_TIME_ELAPSED\n    );\n    FixedPoint.uq112x112[] memory weights = MCapSqrtLibrary.computeTokenWeights(tokens, prices);\n    uint96[] memory denormalizedWeights = new uint96[](tokens.length);\n\n    for (uint256 i = 0; i < tokens.length; i++) {\n      denormalizedWeights[i] = _denormalizeFractionalWeight(weights[i]);\n    }\n\n    meta.lastReweigh = uint64(now);\n    _poolMeta[poolAddress] = meta;\n    IIndexPool(poolAddress).reweighTokens(tokens, denormalizedWeights);\n  }\n\n/* ==========  Pool Queries  ========== */\n\n  /**\n   * @dev Compute the create2 address for a pool initializer.\n   */\n  function computeInitializerAddress(address poolAddress)\n    public\n    view\n    returns (address initializerAddress)\n  {\n    initializerAddress = SaltyLib.computeProxyAddressManyToOne(\n      address(_proxyManager),\n      address(this),\n      INITIALIZER_IMPLEMENTATION_ID,\n      keccak256(abi.encodePacked(poolAddress))\n    );\n  }\n\n  /**\n   * @dev Compute the create2 address for a pool's unbound token seller.\n   */\n  function computeSellerAddress(address poolAddress)\n    public\n    view\n    returns (address sellerAddress)\n  {\n    sellerAddress = SaltyLib.computeProxyAddressManyToOne(\n      address(_proxyManager),\n      address(this),\n      SELLER_IMPLEMENTATION_ID,\n      keccak256(abi.encodePacked(poolAddress))\n    );\n  }\n\n  /**\n   * @dev Compute the create2 address for a pool.\n   */\n  function computePoolAddress(uint256 categoryID, uint256 indexSize)\n    public\n    view\n    returns (address poolAddress)\n  {\n    poolAddress = SaltyLib.computeProxyAddressManyToOne(\n      address(_proxyManager),\n      address(_factory),\n      POOL_IMPLEMENTATION_ID,\n      keccak256(abi.encodePacked(\n        address(this),\n        keccak256(abi.encodePacked(categoryID, indexSize))\n      ))\n    );\n  }\n\n  /**\n   * @dev Queries the top `indexSize` tokens in a category from the market oracle,\n   * computes their relative weights by market cap square root and determines\n   * the weighted balance of each token to meet a specified total value.\n   */\n  function getInitialTokensAndBalances(\n    uint256 categoryID,\n    uint256 indexSize,\n    uint144 wethValue\n  )\n    public\n    view\n    returns (\n      address[] memory tokens,\n      uint256[] memory balances\n    )\n  {\n    tokens = getTopCategoryTokens(categoryID, indexSize);\n    PriceLibrary.TwoWayAveragePrice[] memory prices = oracle.computeTwoWayAveragePrices(\n      tokens,\n      LONG_TWAP_MIN_TIME_ELAPSED,\n      LONG_TWAP_MAX_TIME_ELAPSED\n    );\n    FixedPoint.uq112x112[] memory weights = MCapSqrtLibrary.computeTokenWeights(tokens, prices);\n    balances = new uint256[](indexSize);\n    for (uint256 i = 0; i < indexSize; i++) {\n      balances[i] = MCapSqrtLibrary.computeWeightedBalance(wethValue, weights[i], prices[i]);\n    }\n  }\n\n/* ==========  Internal Pool Utility Functions  ========== */\n\n  /**\n   * @dev Estimate the total value of a pool by taking its first token's\n   * \"virtual balance\" (balance * (totalWeight/weight)) and multiplying\n   * by that token's average ether price from UniSwap.\n   */\n  function _estimatePoolValue(IIndexPool pool) internal view returns (uint144) {\n    (address token, uint256 value) = pool.extrapolatePoolValueFromToken();\n    return oracle.computeAverageEthForTokens(\n      token,\n      value,\n      SHORT_TWAP_MIN_TIME_ELAPSED,\n      SHORT_TWAP_MAX_TIME_ELAPSED\n    );\n  }\n\n/* ==========  General Utility Functions  ========== */\n\n  /**\n   * @dev Converts a fixed point fraction to a denormalized weight.\n   * Multiply the fraction by the max weight and decode to an unsigned integer.\n   */\n  function _denormalizeFractionalWeight(FixedPoint.uq112x112 memory fraction)\n    internal\n    pure\n    returns (uint96)\n  {\n    return uint96(fraction.mul(WEIGHT_MULTIPLIER).decode144());\n  }\n}"
    },
    "@indexed-finance/proxies/contracts/SaltyLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\n\n/* ---  External Libraries  --- */\nimport { Create2 } from \"@openzeppelin/contracts/utils/Create2.sol\";\n\n/* ---  Proxy Contracts  --- */\nimport { CodeHashes } from \"./CodeHashes.sol\";\n\n\n/**\n * @dev Library for computing create2 salts and addresses for proxies\n * deployed by `DelegateCallProxyManager`.\n *\n * Because the proxy factory is meant to be used by multiple contracts,\n * we use a salt derivation pattern that includes the address of the\n * contract that requested the proxy deployment, a salt provided by that\n * contract and the implementation ID used (for many-to-one proxies only).\n */\nlibrary SaltyLib {\n/* ---  Salt Derivation  --- */\n\n  /**\n   * @dev Derives the create2 salt for a many-to-one proxy.\n   *\n   * Many different contracts in the Indexed framework may use the\n   * same implementation contract, and they all use the same init\n   * code, so we derive the actual create2 salt from a combination\n   * of the implementation ID, the address of the account requesting\n   * deployment and the user-supplied salt.\n   *\n   * @param originator Address of the account requesting deployment.\n   * @param implementationID The identifier for the contract implementation.\n   * @param suppliedSalt Salt provided by the account requesting deployment.\n   */\n  function deriveManyToOneSalt(\n    address originator,\n    bytes32 implementationID,\n    bytes32 suppliedSalt\n  )\n    internal\n    pure\n    returns (bytes32)\n  {\n    return keccak256(\n      abi.encodePacked(\n        originator,\n        implementationID,\n        suppliedSalt\n      )\n    );\n  }\n\n  /**\n   * @dev Derives the create2 salt for a one-to-one proxy.\n   *\n   * @param originator Address of the account requesting deployment.\n   * @param suppliedSalt Salt provided by the account requesting deployment.\n   */\n  function deriveOneToOneSalt(\n    address originator,\n    bytes32 suppliedSalt\n  )\n    internal\n    pure\n    returns (bytes32)\n  {\n    return keccak256(abi.encodePacked(originator, suppliedSalt));\n  }\n\n/* ---  Address Derivation  --- */\n\n  /**\n   * @dev Computes the create2 address for a one-to-one proxy deployed\n   * by `deployer` (the factory) when requested by `originator` using\n   * `suppliedSalt`.\n   *\n   * @param deployer Address of the proxy factory.\n   * @param originator Address of the account requesting deployment.\n   * @param suppliedSalt Salt provided by the account requesting deployment.\n   */\n  function computeProxyAddressOneToOne(\n    address deployer,\n    address originator,\n    bytes32 suppliedSalt\n  )\n    internal\n    pure\n    returns (address)\n  {\n    bytes32 salt = deriveOneToOneSalt(originator, suppliedSalt);\n    return Create2.computeAddress(salt, CodeHashes.ONE_TO_ONE_CODEHASH, deployer);\n  }\n\n  /**\n   * @dev Computes the create2 address for a many-to-one proxy for the\n   * implementation `implementationID` deployed by `deployer` (the factory)\n   * when requested by `originator` using `suppliedSalt`.\n   *\n   * @param deployer Address of the proxy factory.\n   * @param originator Address of the account requesting deployment.\n   * @param implementationID The identifier for the contract implementation.\n   * @param suppliedSalt Salt provided by the account requesting deployment.\n  */\n  function computeProxyAddressManyToOne(\n    address deployer,\n    address originator,\n    bytes32 implementationID,\n    bytes32 suppliedSalt\n  )\n    internal\n    pure\n    returns (address)\n  {\n    bytes32 salt = deriveManyToOneSalt(\n      originator,\n      implementationID,\n      suppliedSalt\n    );\n    return Create2.computeAddress(salt, CodeHashes.MANY_TO_ONE_CODEHASH, deployer);\n  }\n\n  /**\n   * @dev Computes the create2 address of the implementation holder\n   * for `implementationID`.\n   *\n   * @param deployer Address of the proxy factory.\n   * @param implementationID The identifier for the contract implementation.\n  */\n  function computeHolderAddressManyToOne(\n    address deployer,\n    bytes32 implementationID\n  )\n    internal\n    pure\n    returns (address)\n  {\n    return Create2.computeAddress(\n      implementationID,\n      CodeHashes.IMPLEMENTATION_HOLDER_CODEHASH,\n      deployer\n    );\n  }\n}"
    },
    "@openzeppelin/contracts/utils/Create2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\n * `CREATE2` can be used to compute in advance the address where a smart\n * contract will be deployed, which allows for interesting new mechanisms known\n * as 'counterfactual interactions'.\n *\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\n * information.\n */\nlibrary Create2 {\n    /**\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\n     * will be deployed can be known in advance via {computeAddress}.\n     *\n     * The bytecode for a contract can be obtained from Solidity with\n     * `type(contractName).creationCode`.\n     *\n     * Requirements:\n     *\n     * - `bytecode` must not be empty.\n     * - `salt` must have not been used for `bytecode` already.\n     * - the factory must have a balance of at least `amount`.\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\n     */\n    function deploy(uint256 amount, bytes32 salt, bytes memory bytecode) internal returns (address) {\n        address addr;\n        require(address(this).balance >= amount, \"Create2: insufficient balance\");\n        require(bytecode.length != 0, \"Create2: bytecode length is zero\");\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\n        }\n        require(addr != address(0), \"Create2: Failed on deploy\");\n        return addr;\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\n     * `bytecodeHash` or `salt` will result in a new destination address.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\n        return computeAddress(salt, bytecodeHash, address(this));\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer) internal pure returns (address) {\n        bytes32 _data = keccak256(\n            abi.encodePacked(bytes1(0xff), deployer, salt, bytecodeHash)\n        );\n        return address(uint256(_data));\n    }\n}\n"
    },
    "@indexed-finance/proxies/contracts/CodeHashes.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\n\n\n/**\n * @dev Because we use the code hashes of the proxy contracts for proxy address\n * derivation, it is important that other packages have access to the correct\n * values when they import the salt library.\n */\nlibrary CodeHashes {\n  bytes32 internal constant ONE_TO_ONE_CODEHASH = 0xdf533b6e999d326280ce88ca39ea2eddf95ed96f6c153ed5642d9b0a95dba4a2;\n  bytes32 internal constant MANY_TO_ONE_CODEHASH = 0x8fb4522edc5e0645a7ae5cfdbfe3b34d4a14de9e0279b74da795856b5ef4f1e6;\n  bytes32 internal constant IMPLEMENTATION_HOLDER_CODEHASH = 0xfc7aed17e5c5d36a15e443235cb9c59bae4a013202cde6ab3e657fa1176d7f3e;\n}"
    },
    "contracts/mocks/InitializerErrorTrigger.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\nimport \"./MockERC20.sol\";\n\n\ninterface Controller {\n  function finishPreparedIndexPool(\n    address poolAddress,\n    address[] calldata tokens,\n    uint256[] calldata balances\n  ) external;\n}\n\n\ncontract InitializerErrorTrigger {\n  Controller internal _controller;\n  address internal _pool;\n  address[] internal _tokens;\n  uint256[] internal _balances;\n\n  function initialize(address pool, address[] calldata tokens, uint256[] calldata balances) external {\n    _tokens = tokens;\n    _balances = balances;\n    _pool = pool;\n    _controller = Controller(msg.sender);\n  }\n\n  function triggerArrLenError() external {\n    uint256[] memory balances = new uint256[](_balances.length - 1);\n    _controller.finishPreparedIndexPool(_pool, _tokens, balances);\n  }\n\n  function triggerDuplicateInit() external {\n    address[] memory tokens = _tokens;\n    uint256[] memory balances = _balances;\n    address pool = _pool;\n    for (uint256 i = 0; i < tokens.length; i++) {\n      MockERC20(tokens[i]).getFreeTokens(address(this), balances[i]);\n      MockERC20(tokens[i]).approve(pool, balances[i]);\n    }\n    _controller.finishPreparedIndexPool(pool, tokens, balances);\n    _controller.finishPreparedIndexPool(pool, tokens, balances);\n  }\n}"
    },
    "contracts/mocks/MockERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n\ncontract MockERC20 is ERC20 {\n  constructor(string memory name, string memory symbol) public ERC20(name, symbol) {}\n\n  // Mocks WETH deposit fn\n  function deposit() external payable {\n    _mint(msg.sender, msg.value);\n  }\n\n  function getFreeTokens(address to, uint256 amount) public {\n    _mint(to, amount);\n  }\n}"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"../../GSN/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name, string memory symbol) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies in extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/mocks/LiquidityAdder.sol": {
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport {\n  IUniswapV2Pair\n} from \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\nimport {\n  IUniswapV2Factory\n} from \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\";\nimport {\n  IUniswapV2Router02\n} from \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\nimport { UniswapV2Library } from \"../lib/UniswapV2Library.sol\";\nimport \"./MockERC20.sol\";\n\n\ncontract LiquidityAdder {\n  MockERC20 public immutable weth;\n  IUniswapV2Factory public immutable factory;\n  IUniswapV2Router02 public immutable router;\n\n  constructor(\n    address weth_,\n    address factory_,\n    address router_\n  ) public {\n    weth = MockERC20(weth_);\n    factory = IUniswapV2Factory(factory_);\n    router = IUniswapV2Router02(router_);\n  }\n\n  struct LiquidityToAdd {\n    address token;\n    uint256 amountToken;\n    uint256 amountWeth;\n  }\n\n  function addLiquidityMulti(LiquidityToAdd[] memory inputs) public {\n    for (uint256 i = 0; i < inputs.length; i++) {\n      LiquidityToAdd memory _input = inputs[i];\n      _addLiquidity(\n        MockERC20(_input.token),\n        _input.amountToken,\n        _input.amountWeth\n      );\n    }\n  }\n\n  function addLiquiditySingle(\n    MockERC20 token, uint256 amountToken, uint256 amountWeth\n  ) public returns (uint256 amountTokenActual, uint256 amountWethActual) {\n    return _addLiquidity(\n      token,\n      amountToken,\n      amountWeth\n    );\n  }\n\n  function _addLiquidity(\n    MockERC20 token,\n    uint256 amountToken,\n    uint256 amountWeth\n  ) internal returns (uint256 amountTokenActual, uint256 amountWethActual) {\n    (uint256 reserveToken, uint256 reserveWeth) = UniswapV2Library.getReserves(\n      address(factory),\n      address(token),\n      address(weth)\n    );\n    if (reserveWeth > 0) {\n      amountWeth = (amountToken * reserveWeth) / reserveToken;\n    }\n    token.getFreeTokens(address(this), amountToken);\n    weth.getFreeTokens(address(this), amountWeth);\n    token.approve(address(router), amountToken);\n    weth.approve(address(router), amountWeth);\n    (amountTokenActual, amountWethActual,) = router.addLiquidity(\n      address(token),\n      address(weth),\n      amountToken,\n      amountWeth,\n      amountToken / 2,\n      amountWeth / 2,\n      address(this),\n      now + 1\n    );\n  }\n\n  function swapDecreasePrice(MockERC20 token) external returns (uint256[] memory amounts) {\n    address pair = UniswapV2Library.pairFor(\n      address(factory),\n      address(token),\n      address(weth)\n    );\n    uint256 amountToken = token.balanceOf(address(pair)) / 5;\n    address[] memory path = new address[](2);\n    path[0] = address(token);\n    path[1] = address(weth);\n    token.getFreeTokens(address(this), amountToken);\n    token.approve(address(router), amountToken);\n    return router.swapExactTokensForTokens(\n      amountToken,\n      0,\n      path,\n      address(this),\n      now\n    );\n  }\n\n  function swapIncreasePrice(MockERC20 token) external returns (uint256[] memory amounts) {\n    address pair = UniswapV2Library.pairFor(\n      address(factory),\n      address(token),\n      address(weth)\n    );\n    uint256 amountWeth = weth.balanceOf(address(pair)) / 5;\n    address[] memory path = new address[](2);\n    path[0] = address(weth);\n    path[1] = address(token);\n    weth.getFreeTokens(address(this), amountWeth);\n    weth.approve(address(router), amountWeth);\n    return router.swapExactTokensForTokens(\n      amountWeth,\n      0,\n      path,\n      address(this),\n      now\n    );\n  }\n}"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n"
    },
    "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol": {
      "content": "pragma solidity >=0.6.2;\n\nimport './IUniswapV2Router01.sol';\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n"
    },
    "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol": {
      "content": "pragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n"
    },
    "contracts/mocks/MockBorrower.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport {MockERC20} from \"./MockERC20.sol\";\nimport \"../interfaces/IIndexPool.sol\";\n\n\ncontract MockBorrower {\n  function receiveFlashLoan(\n    address tokenBorrowed,\n    uint256 amountBorrowed,\n    uint256 amountDue,\n    bytes calldata data\n  ) external {\n    (uint256 testScenario) = abi.decode((data), (uint8));\n    MockERC20 token = MockERC20(tokenBorrowed);\n\n    if (testScenario == 0) {\n      // Repay with fee\n      token.getFreeTokens(msg.sender, amountDue);\n    } else if (testScenario == 1) {\n      // Repay amount borrowed\n      token.getFreeTokens(msg.sender, amountBorrowed);\n    } else if (testScenario == 2) {\n      // Attempt reentry\n      IIndexPool(msg.sender).gulp(tokenBorrowed);\n    }\n  }\n}"
    },
    "contracts/mocks/MockUnbindSourcePool.sol": {
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { MockERC20 } from \"./MockERC20.sol\";\n\n/**\n * @dev Mock contract for testing the unbound token sale functionality.\n */\ncontract MockUnbindSourcePool {\n\n  event NewTokensToSell(\n    address indexed token,\n    uint256 amountReceived\n  );\n\n  struct Record {\n    bool bound;\n    bool ready;\n    uint40 lastDenormUpdate;\n    uint96 denorm;\n    uint96 desiredDenorm;\n    uint8 index;\n    uint256 balance;\n  }\n\n  TokenUnbindHandler internal _unbindHandler;\n  mapping(address => Record) internal _records;\n\n  constructor(address unbindHandler) public {\n    _unbindHandler = TokenUnbindHandler(unbindHandler);\n  }\n\n  function getTokenRecord(address token)\n    external\n    view\n    returns (Record memory record)\n  {\n    record = _records[token];\n    require(record.bound, \"ERR_NOT_BOUND\");\n  }\n\n  function getBalance(address token)\n    external\n    view\n    returns (uint256 balance)\n  {\n    Record memory record = _records[token];\n    require(record.bound, \"ERR_NOT_BOUND\");\n    balance = record.balance;\n  }\n\n  function addToken(\n    address token,\n    uint96 desiredDenorm,\n    uint256 balance\n  ) external {\n\n    _records[token] = Record(\n      true,\n      true,\n      0,\n      desiredDenorm,\n      desiredDenorm,\n      0,\n      balance\n    );\n    MockERC20(token).getFreeTokens(address(this), balance);\n  }\n\n  function gulp(address token) external {\n    uint256 bal = IERC20(token).balanceOf(address(this));\n    _records[token].balance = bal;\n  }\n\n  function unbind(address token) external {\n    uint256 balance = _records[token].balance;\n    _records[token] = Record(false, false, 0, 0, 0, 0, 0);\n    IERC20(token).transfer(address(_unbindHandler), balance);\n    _unbindHandler.handleUnbindToken(token, balance);\n  }\n}\n\n\ninterface TokenUnbindHandler {\n  event NewTokensToSell(\n    address indexed token,\n    uint256 amountReceived\n  );\n  /**\n   * @dev Receive `amount` of `token` from the pool.\n   */\n  function handleUnbindToken(address token, uint256 amount) external;\n}"
    },
    "contracts/mocks/MockUnbindTokenHandler.sol": {
      "content": "pragma solidity ^0.6.0;\n\n\n/**\n * @dev Mock contract for testing the unbind token functionality\n * on the index pool.\n */\ncontract MockUnbindTokenHandler {\n  mapping(address => uint256) internal _receivedTokens;\n  function handleUnbindToken(address token, uint256 amount) external {\n    _receivedTokens[token] += amount;\n  }\n\n  function getReceivedTokens(address token) external view returns (uint256) {\n    return _receivedTokens[token];\n  }\n}"
    },
    "contracts/mocks/OracleFallthrough.sol": {
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@indexed-finance/uniswap-v2-oracle/contracts/interfaces/IIndexedUniswapV2Oracle.sol\";\nimport \"@indexed-finance/uniswap-v2-oracle/contracts/lib/PriceLibrary.sol\";\nimport \"@indexed-finance/uniswap-v2-oracle/contracts/lib/FixedPoint.sol\";\n\n\n/**\n * Proxy contract to reduce the TWAP period on testnets.\n*/\ncontract OracleFallthrough {\n  IIndexedUniswapV2Oracle public oracle;\n  address internal immutable _owner;\n\n  constructor(address oracle_) public {\n    oracle = IIndexedUniswapV2Oracle(oracle_);\n    _owner = msg.sender;\n  }\n\n  function setOracle(address oracle_) external {\n    oracle = IIndexedUniswapV2Oracle(oracle_);\n  }\n\n  /* ==========  Price Updates  ========== */\n\n  function updatePrice(address token) external returns (bool) {\n    return oracle.updatePrice(token);\n  }\n\n  function updatePrices(address[] calldata tokens) external returns (bool[] memory) {\n    return oracle.updatePrices(tokens);\n  }\n\n  /* ==========  Price Queries: Singular  ========== */\n\n  function computeTwoWayAveragePrice(\n    address token,\n    uint256 /* minTimeElapsed */,\n    uint256 /* maxTimeElapsed */\n  ) external view returns (PriceLibrary.TwoWayAveragePrice memory) {\n    return oracle.computeTwoWayAveragePrice(token, 1 minutes, 2 weeks);\n  }\n\n  function computeAverageTokenPrice(\n    address token,\n    uint256 /* minTimeElapsed */,\n    uint256 /* maxTimeElapsed */\n  ) external view returns (FixedPoint.uq112x112 memory) {\n    return oracle.computeAverageTokenPrice(token, 1 minutes, 2 weeks);\n  }\n\n  function computeAverageEthPrice(\n    address token,\n    uint256 /* minTimeElapsed */,\n    uint256 /* maxTimeElapsed */\n  ) external view returns (FixedPoint.uq112x112 memory) {\n    return oracle.computeAverageEthPrice(token, 1 minutes, 2 weeks);\n  }\n\n  /* ==========  Price Queries: Multiple  ========== */\n\n  function computeTwoWayAveragePrices(\n    address[] calldata tokens,\n    uint256 /* minTimeElapsed */,\n    uint256 /* maxTimeElapsed */\n  ) external view returns (PriceLibrary.TwoWayAveragePrice[] memory) {\n    return oracle.computeTwoWayAveragePrices(tokens, 1 minutes, 2 weeks);\n  }\n\n  function computeAverageTokenPrices(\n    address[] calldata tokens,\n    uint256 /* minTimeElapsed */,\n    uint256 /* maxTimeElapsed */\n  ) external view returns (FixedPoint.uq112x112[] memory) {\n    return oracle.computeAverageTokenPrices(tokens, 1 minutes, 2 weeks);\n  }\n\n  function computeAverageEthPrices(\n    address[] calldata tokens,\n    uint256 /* minTimeElapsed */,\n    uint256 /* maxTimeElapsed */\n  ) external view returns (FixedPoint.uq112x112[] memory) {\n    return oracle.computeAverageEthPrices(tokens, 1 minutes, 2 weeks);\n  }\n\n/* ==========  Value Queries: Singular  ========== */\n\n  function computeAverageEthForTokens(\n    address token,\n    uint256 tokenAmount,\n    uint256 /* minTimeElapsed */,\n    uint256 /* maxTimeElapsed */\n  ) external view returns (uint144) {\n    return oracle.computeAverageEthForTokens(token, tokenAmount, 1 minutes, 2 weeks);\n  }\n\n  function computeAverageTokensForEth(\n    address token,\n    uint256 wethAmount,\n    uint256 /* minTimeElapsed */,\n    uint256 /* maxTimeElapsed */\n  ) external view returns (uint144) {\n    return oracle.computeAverageTokensForEth(token, wethAmount, 1 minutes, 2 weeks);\n  }\n\n/* ==========  Value Queries: Multiple  ========== */\n\n  function computeAverageEthForTokens(\n    address[] calldata tokens,\n    uint256[] calldata tokenAmounts,\n    uint256 /* minTimeElapsed */,\n    uint256 /* maxTimeElapsed */\n  ) external view returns (uint144[] memory) {\n    return oracle.computeAverageEthForTokens(tokens, tokenAmounts, 1 minutes, 2 weeks);\n  }\n\n  function computeAverageTokensForEth(\n    address[] calldata tokens,\n    uint256[] calldata wethAmounts,\n    uint256 /* minTimeElapsed */,\n    uint256 /* maxTimeElapsed */\n  ) external view returns (uint144[] memory) {\n    return oracle.computeAverageTokensForEth(tokens, wethAmounts, 1 minutes, 2 weeks);\n  }\n}"
    },
    "contracts/mocks/tests/SellerTest.sol": {
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport {\n  IUniswapV2Pair\n} from \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\nimport {\n  IUniswapV2Factory\n} from \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\";\nimport {\n  IUniswapV2Router02\n} from \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\nimport { IIndexedUniswapV2Oracle } from \"@indexed-finance/uniswap-v2-oracle/contracts/interfaces/IIndexedUniswapV2Oracle.sol\";\nimport { MockERC20, TestTokenMarkets } from \"./util/TestTokenMarkets.sol\";\nimport \"./util/Diff.sol\";\nimport \"./util/TestOrder.sol\";\nimport { UnboundTokenSeller, IIndexPool } from \"../../UnboundTokenSeller.sol\";\nimport { MockUnbindSourcePool } from \"../MockUnbindSourcePool.sol\";\nimport { UniswapV2Library } from \"../../lib/UniswapV2Library.sol\";\n\n\ncontract SellerTest is TestTokenMarkets, Diff, TestOrder {\n  UnboundTokenSeller public seller;\n  IIndexedUniswapV2Oracle public oracle;\n  MockUnbindSourcePool public pool;\n  address undesiredToken;\n\n  /* abi.encodeWithSelector(token.transfer.selector, to, value) */\n\n  constructor(\n    MockERC20 _weth,\n    IUniswapV2Factory _factory,\n    IUniswapV2Router02 _router,\n    IIndexedUniswapV2Oracle _oracle\n  )\n    public\n    TestTokenMarkets(_weth, _factory, _router)\n  {\n    oracle = _oracle;\n    seller = new UnboundTokenSeller(_router, _oracle, address(this));\n    pool = new MockUnbindSourcePool(address(seller));\n  }\n\n  function test_initialize() external {\n    try seller.initialize(address(0), 2) {\n      revert(\"Error: Expected revert\");\n    } catch Error(string memory errorMsg) {\n      require(\n        keccak256(abi.encodePacked(errorMsg)) == keccak256(\"ERR_NULL_ADDRESS\"),\n        \"Error: Expected ERR_NULL_ADDRESS error message.\"\n      );\n    }\n    try seller.initialize(address(pool), 0) {\n      revert(\"Error: Expected revert\");\n    } catch Error(string memory errorMsg) {\n      require(\n        keccak256(abi.encodePacked(errorMsg)) == keccak256(\"ERR_PREMIUM\"),\n        \"Error: Expected ERR_PREMIUM error message.\"\n      );\n    }\n    try seller.initialize(address(pool), 21) {\n      revert(\"Error: Expected revert\");\n    } catch Error(string memory errorMsg) {\n      require(\n        keccak256(abi.encodePacked(errorMsg)) == keccak256(\"ERR_PREMIUM\"),\n        \"Error: Expected ERR_PREMIUM error message.\"\n      );\n    }\n    seller.initialize(address(pool), 2);\n    try seller.initialize(address(pool), 2) {\n      revert(\"Error: Expected revert\");\n    } catch Error(string memory errorMsg) {\n      require(\n        keccak256(abi.encodePacked(errorMsg)) == keccak256(\"ERR_INITIALIZED\"),\n        \"Error: Expected ERR_INITIALIZED error message.\"\n      );\n    }\n  }\n\n  function init() public {\n    _deployTokens();\n  }\n\n  function init2() public {\n    _deployMarkets();\n  }\n\n  function init3() public {\n    oracle.updatePrices(tokensOrderedByPrice());\n    pool.addToken(address(token1), 1.5e18, 5e21 / price1);\n    pool.addToken(address(token2), 1.5e18, 5e21 / price2);\n    pool.addToken(address(token3), 1.5e18, 5e21 / price3);\n    pool.addToken(address(token4), 1.5e18, 5e21 / price4);\n    pool.addToken(address(token5), 1.5e18, 5e21 / price5);\n    undesiredToken = address(new MockERC20(\"Test Token\", \"TTU\"));\n    pool.addToken(undesiredToken, 0, 100);\n  }\n\n  function test_setPremiumPercent() external {\n    try seller.setPremiumPercent(0) {\n      revert(\"Expected error.\");\n    } catch Error(string memory errorMsg) {\n      require(\n        keccak256(abi.encodePacked(errorMsg)) == keccak256(\"ERR_PREMIUM\"),\n        \"Error: Expected ERR_PREMIUM error message.\"\n      );\n    }\n    try seller.setPremiumPercent(20) {\n      revert(\"Expected error.\");\n    } catch Error(string memory errorMsg) {\n      require(\n        keccak256(abi.encodePacked(errorMsg)) == keccak256(\"ERR_PREMIUM\"),\n        \"Error: Expected ERR_PREMIUM error message.\"\n      );\n    }\n    seller.setPremiumPercent(2);\n    require(seller.getPremiumPercent() == 2, \"Error: Unexpected premium returned.\");\n  }\n\n  function test_handleUnbindToken() external {\n    try seller.handleUnbindToken(address(token1), 1e18) {\n      revert(\"Expected error.\");\n    } catch Error(string memory errorMsg) {\n      require(\n        keccak256(abi.encodePacked(errorMsg)) == keccak256(\"ERR_ONLY_POOL\"),\n        \"Error: Expected ERR_ONLY_POOL error message.\"\n      );\n    }\n    pool.unbind(address(token1));\n    require(\n      token1.balanceOf(address(seller)) == 5e21 / price1,\n      \"Error: tokens not transferred to pool.\"\n    );\n  }\n\n  function test_calcOutGivenIn() external view {\n    uint256 amountIn = 1e18;\n    uint256 wethValue = (amountIn * price2 * 100) / 98;\n    uint256 expectedTokenOutput = wethValue / price1;\n    uint256 actualTokenOutput = seller.calcOutGivenIn(\n      address(token2),\n      address(token1),\n      amountIn\n    );\n    testDiff(\n      expectedTokenOutput,\n      actualTokenOutput,\n      \"Error: Seller gave unexpected output value.\"\n    );\n\n    try seller.calcOutGivenIn(undesiredToken, address(token1), 0) returns (uint256) {\n      revert(\"Error: Expected revert\");\n    } catch Error(string memory errorMsg) {\n      require(\n        keccak256(abi.encodePacked(errorMsg)) == keccak256(\"ERR_UNDESIRED_TOKEN\"),\n        \"Error: Expected ERR_UNDESIRED_TOKEN error message.\"\n      );\n    }\n\n    try seller.calcOutGivenIn(address(token2), address(token1), 1e40) returns (uint256) {\n      revert(\"Error: Expected revert\");\n    } catch Error(string memory errorMsg) {\n      require(\n        keccak256(abi.encodePacked(errorMsg)) == keccak256(\"ERR_INSUFFICIENT_BALANCE\"),\n        \"Error: Expected ERR_INSUFFICIENT_BALANCE error message.\"\n      );\n    }\n  }\n\n  function test_calcInGivenOut() external view {\n    uint256 amountOut = 1e18;\n    uint256 valueOut = (amountOut * price1 * 98) / 100;\n    uint256 expectedTokenInput = valueOut / price2;\n    uint256 actualTokenInput = seller.calcInGivenOut(\n      address(token2),\n      address(token1),\n      amountOut\n    );\n\n    testDiff(expectedTokenInput, actualTokenInput, \"Error: Seller gave unexpected input value.\");\n\n    try seller.calcInGivenOut(undesiredToken, address(token1), 0) returns (uint256) {\n      revert(\"Error: Expected revert\");\n    } catch Error(string memory errorMsg) {\n      require(\n        keccak256(abi.encodePacked(errorMsg)) == keccak256(\"ERR_UNDESIRED_TOKEN\"),\n        \"Error: Expected ERR_UNDESIRED_TOKEN error message.\"\n      );\n    }\n\n    try seller.calcInGivenOut(address(token2), address(token1), 1e40) returns (uint256) {\n      revert(\"Error: Expected revert\");\n    } catch Error(string memory errorMsg) {\n      require(\n        keccak256(abi.encodePacked(errorMsg)) == keccak256(\"ERR_INSUFFICIENT_BALANCE\"),\n        \"Error: Expected ERR_INSUFFICIENT_BALANCE error message.\"\n      );\n    }\n  }\n\n  function test_swapExactTokensForTokens() external {\n    uint256 amountIn = 1e17;\n    uint256 wethValue = (amountIn * price2 * 100) / 98;\n    uint256 expectedTokenOutput = wethValue / price1;\n  \n    try seller.swapExactTokensForTokens(\n      address(token2),\n      address(token1),\n      amountIn,\n      expectedTokenOutput + 1\n    ) {\n      revert(\"Expected error.\");\n    } catch Error(string memory errorMsg) {\n      require(\n        keccak256(abi.encodePacked(errorMsg)) == keccak256(\"ERR_MIN_AMOUNT_OUT\"),\n        \"Error: Expected ERR_MIN_AMOUNT_OUT error message.\"\n      );\n    }\n    token2.getFreeTokens(address(this), amountIn);\n    token2.approve(address(seller), amountIn);\n    uint256 poolBalance1 = pool.getBalance(address(token2));\n    uint256 amountOut = seller.swapExactTokensForTokens(\n      address(token2),\n      address(token1),\n      amountIn,\n      expectedTokenOutput\n    );\n    require(\n      amountOut == expectedTokenOutput,\n      \"Error: Received unexpected token output.\"\n    );\n    uint256 poolBalance2 = pool.getBalance(address(token2));\n    require(\n      poolBalance1 + amountIn == poolBalance2,\n      \"Error: Pool did not gulp tokens.\"\n    );\n  }\n\n  function test_swapTokensForExactTokens() external {\n    uint256 amountOut = 1e17;\n    uint256 valueOut = (amountOut * price1 * 98) / 100;\n    uint256 expectedTokenInput = valueOut / price2;\n  \n    try seller.swapTokensForExactTokens(\n      address(token2),\n      address(token1),\n      amountOut,\n      expectedTokenInput - 1\n    ) {\n      revert(\"Expected error.\");\n    } catch Error(string memory errorMsg) {\n      require(\n        keccak256(abi.encodePacked(errorMsg)) == keccak256(\"ERR_MAX_AMOUNT_IN\"),\n        \"Error: Expected ERR_MAX_AMOUNT_IN error message.\"\n      );\n    }\n    token2.getFreeTokens(address(this), expectedTokenInput);\n    token2.approve(address(seller), expectedTokenInput);\n    uint256 poolBalance1 = pool.getBalance(address(token2));\n    uint256 amountIn = seller.swapTokensForExactTokens(\n      address(token2),\n      address(token1),\n      amountOut,\n      expectedTokenInput\n    );\n    require(\n      amountIn == expectedTokenInput,\n      \"Error: Paid an unexpected amount.\"\n    );\n    uint256 poolBalance2 = pool.getBalance(address(token2));\n    require(\n      poolBalance1 + amountIn == poolBalance2,\n      \"Error: Pool did not gulp tokens.\"\n    );\n  }\n\n  function test_executeSwapTokensForExactTokens() external {\n    uint256 amountOut = 1e17;\n    uint256 maxValueIn = (amountOut * price2 * 100) / 98;\n    uint256 maxAmountIn = maxValueIn / price1;\n    uint256 expectedWethSwap2 = UniswapV2Library.getAmountIn(amountOut, 1e20 * price2, 1e20);\n    uint256 expectedAmountIn = UniswapV2Library.getAmountIn(expectedWethSwap2, 1e20, 1e20 * price1);\n    uint256 expectedPremium = maxAmountIn - expectedAmountIn;\n\n    address[] memory path = new address[](3);\n    path[0] = address(token1);\n    path[1] = address(weth);\n    path[2] = address(token2);\n    uint256 poolBalance1 = pool.getBalance(address(token2));\n    uint256 premium = seller.executeSwapTokensForExactTokens(\n      address(token1),\n      address(token2),\n      amountOut,\n      path\n    );\n    uint256 poolBalance2 = pool.getBalance(address(token2));\n    require(poolBalance1 + amountOut == poolBalance2, \"Error: Pool did not gulp tokens.\");\n    require(expectedPremium == premium, \"Error: Unexpected premium.\");\n\n    address[] memory path2 = new address[](2);\n    path2[0] = address(0);\n    path2[1] = address(token2);\n    try seller.executeSwapTokensForExactTokens(address(token1), address(token2), 1e5, path2) returns (uint256) {\n      revert(\"Error: Expected revert\");\n    } catch Error(string memory errorMsg) {\n      require(\n        keccak256(abi.encodePacked(errorMsg)) == keccak256(\"ERR_PATH_TOKENS\"),\n        \"Error: Expected ERR_PATH_TOKENS error message.\"\n      );\n    }\n    path2[0] = address(token1);\n    path2[1] = address(0);\n    try seller.executeSwapTokensForExactTokens(address(token1), address(token2), 1e5, path2) returns (uint256) {\n      revert(\"Error: Expected revert\");\n    } catch Error(string memory errorMsg) {\n      require(\n        keccak256(abi.encodePacked(errorMsg)) == keccak256(\"ERR_PATH_TOKENS\"),\n        \"Error: Expected ERR_PATH_TOKENS error message.\"\n      );\n    }\n  }\n\n  function test_executeSwapExactTokensForTokens() external {\n    // Relatively small amount to avoid needing to calculate uniswap slippage for\n    // expected premium\n    uint256 amountIn = 1e17;\n    uint256 minValueOut = (amountIn * price1 * 98) / 100;\n    uint256 minAmountOut = minValueOut / price2;\n    uint256 expectedWethSwap1 = UniswapV2Library.getAmountOut(amountIn, 1e20, 1e20 * price1);\n    uint256 expectedAmountOut = UniswapV2Library.getAmountOut(expectedWethSwap1, 1e20 * price2, 1e20);\n    uint256 expectedPremium = expectedAmountOut - minAmountOut;\n\n    address[] memory path = new address[](3);\n    path[0] = address(token1);\n    path[1] = address(weth);\n    path[2] = address(token2);\n    uint256 poolBalance1 = pool.getBalance(address(token2));\n    uint256 premium = seller.executeSwapExactTokensForTokens(\n      address(token1),\n      address(token2),\n      amountIn,\n      path\n    );\n    uint256 poolBalance2 = pool.getBalance(address(token2));\n    require(poolBalance1 + minAmountOut == poolBalance2, \"Error: Pool did not gulp tokens.\");\n    require(expectedPremium == premium, \"Error: Unexpected premium.\");\n\n    address[] memory path2 = new address[](2);\n    path2[0] = address(0);\n    path2[1] = address(token2);\n    try seller.executeSwapExactTokensForTokens(address(token1), address(token2), 1e5, path2) returns (uint256) {\n      revert(\"Error: Expected revert\");\n    } catch Error(string memory errorMsg) {\n      require(\n        keccak256(abi.encodePacked(errorMsg)) == keccak256(\"ERR_PATH_TOKENS\"),\n        \"Error: Expected ERR_PATH_TOKENS error message.\"\n      );\n    }\n    path2[0] = address(token1);\n    path2[1] = address(0);\n    try seller.executeSwapExactTokensForTokens(address(token1), address(token2), 1e5, path2) returns (uint256) {\n      revert(\"Error: Expected revert\");\n    } catch Error(string memory errorMsg) {\n      require(\n        keccak256(abi.encodePacked(errorMsg)) == keccak256(\"ERR_PATH_TOKENS\"),\n        \"Error: Expected ERR_PATH_TOKENS error message.\"\n      );\n    }\n  }\n}"
    },
    "contracts/mocks/tests/util/TestTokenMarkets.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport {\n  IUniswapV2Pair\n} from \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\nimport {\n  IUniswapV2Factory\n} from \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\";\nimport {\n  IUniswapV2Router02\n} from \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\nimport \"./TestTokens.sol\";\n\n\ncontract TestTokenMarkets is TestTokens {\n  MockERC20 public weth;\n  IUniswapV2Factory public factory;\n  IUniswapV2Router02 public router;\n\n  uint256 internal _liquidityAll;\n\n  bool internal _marketsReady;\n  uint256 internal _deployIndex;\n\n  modifier marketsReady {\n    require(_marketsReady, \"Error: markets not deployed.\");\n    _;\n  }\n\n  constructor(\n    MockERC20 _weth,\n    IUniswapV2Factory _factory,\n    IUniswapV2Router02 _router\n  ) public {\n    weth = _weth;\n    factory = _factory;\n    router = _router;\n  }\n\n  function _deployMarkets() internal tokensReady {\n    if (_deployIndex == 0) {\n      _deployIndex++;\n      _deployTokenWethMarketWithLiquidity(token1, 1e20, price1);\n    } else if (_deployIndex == 1) {\n      _deployIndex++;\n      _deployTokenWethMarketWithLiquidity(token2, 1e20, price2);\n    } else if (_deployIndex == 2) {\n      _deployIndex++;\n      _deployTokenWethMarketWithLiquidity(token3, 1e20, price3);\n    } else if (_deployIndex == 3) {\n      _deployIndex++;\n      _deployTokenWethMarketWithLiquidity(token4, 1e20, price4);\n    } else if (_deployIndex == 4) {\n      _deployIndex++;\n      _deployTokenWethMarketWithLiquidity(token5, 1e20, price5);\n      _liquidityAll = 1e20;\n      _marketsReady = true;\n    }\n  }\n\n  function _addLiquidityAll() internal marketsReady {\n    _addLiquidity(token1, 1e19, price1);\n    _addLiquidity(token2, 1e19, price2);\n    _addLiquidity(token3, 1e19, price3);\n    _addLiquidity(token4, 1e19, price4);\n    _addLiquidity(token5, 1e19, price5);\n    _liquidityAll += 1e19;\n  }\n\n  function _addLiquidity(\n    MockERC20 token,\n    uint256 amountToken,\n    uint256 price\n  ) internal {\n    uint256 amountWeth = amountToken * price;\n    token.getFreeTokens(address(this), amountToken);\n    weth.getFreeTokens(address(this), amountWeth);\n    token.approve(address(router), amountToken);\n    weth.approve(address(router), amountWeth);\n    router.addLiquidity(\n      address(token),\n      address(weth),\n      amountToken,\n      amountWeth,\n      amountToken,\n      amountWeth,\n      address(this),\n      now + 1\n    );\n  }\n\n  function _deployTokenWethMarketWithLiquidity(\n    MockERC20 token,\n    uint256 amountToken,\n    uint256 price\n  ) internal {\n    factory.createPair(address(token), address(weth));\n    _addLiquidity(token, amountToken, price);\n  }\n}"
    },
    "contracts/mocks/tests/util/TestTokens.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../../MockERC20.sol\";\n\n\ncontract TestTokens {\n  MockERC20 public token1;\n  MockERC20 public token2;\n  MockERC20 public token3;\n  MockERC20 public token4;\n  MockERC20 public token5;\n\n  uint256 public price1 = 5;\n  uint256 public price2 = 3;\n  uint256 public price3 = 4;\n  uint256 public price4 = 2;\n  uint256 public price5 = 6;\n\n  modifier tokensReady {\n    require(address(token1) != address(0), \"Error: Tester not initialized\");\n    _;\n  }\n\n  function _deployTokens() internal {\n    require(address(token1) == address(0), \"Error: tokens already deployed.\");\n    token1 = new MockERC20(\"Token 1\", \"TK1\");\n    token2 = new MockERC20(\"Token 2\", \"TK2\");\n    token3 = new MockERC20(\"Token 3\", \"TK3\");\n    token4 = new MockERC20(\"Token 4\", \"TK4\");\n    token5 = new MockERC20(\"Token 5\", \"TK5\");\n  }\n\n  function tokensOrderedByPrice()\n    internal\n    view\n    returns (address[] memory tokens)\n  {\n    tokens = new address[](5);\n    tokens[0] = address(token5);\n    tokens[1] = address(token1);\n    tokens[2] = address(token3);\n    tokens[3] = address(token2);\n    tokens[4] = address(token4);\n  }\n\n  function orderedPrices()\n    internal\n    view\n    returns (uint256[] memory prices)\n  {\n    prices = new uint256[](5);\n    prices[0] = price5;\n    prices[1] = price1;\n    prices[2] = price3;\n    prices[3] = price2;\n    prices[4] = price4;\n  }\n\n  function marketCapsOrderedByPrice(uint256 liquidityPer)\n    internal\n    view\n    returns (uint256[] memory marketCaps)\n  {\n    marketCaps = new uint256[](5);\n    marketCaps[0] = price5 * liquidityPer;\n    marketCaps[1] = price1 * liquidityPer;\n    marketCaps[2] = price3 * liquidityPer;\n    marketCaps[3] = price2 * liquidityPer;\n    marketCaps[4] = price4 * liquidityPer;\n  }\n}"
    },
    "contracts/mocks/tests/util/Diff.sol": {
      "content": "pragma solidity ^0.6.0;\n\n\ncontract Diff {\n  function testDiff(\n    uint256 expected,\n    uint256 actual,\n    string memory errorMsg\n  ) internal pure {\n    if (expected == actual) return;\n    uint256 diff = absDiff(expected, actual);\n    // require diff as a fraction is less than 1e-8\n    uint256 _diff = (diff * 1e18) / actual;\n    require(_diff < 1e10, errorMsg);\n  }\n\n  function absDiff(uint256 a, uint256 b) internal pure returns (uint256) {\n    return (a == b) ? 0 : a > b ? a - b : b - a;\n  }\n\n  function testArrayDeepEq(\n    address[] memory expected,\n    address[] memory actual,\n    string memory errorMsg\n  ) internal pure {\n    require(expected.length == actual.length, \"Error: Array lengths do not match.\");\n    for (uint256 i = 0; i < actual.length; i++) {\n      require(expected[i] == actual[i], errorMsg);\n    }\n  }\n\n  function testUintArrayDiff(\n    uint[] memory expected,\n    uint[] memory actual,\n    string memory errorMsg\n  ) internal pure {\n    require(expected.length == actual.length, \"Error: Array lengths do not match.\");\n    for (uint256 i = 0; i < expected.length; i++) {\n      testDiff(expected[i], actual[i], errorMsg);\n    }\n  }\n}"
    },
    "contracts/mocks/tests/util/TestOrder.sol": {
      "content": "pragma solidity ^0.6.0;\n\n\ncontract TestOrder {\n  uint256 internal _testStep;\n  uint256 internal _timestampLast;\n\n  modifier testIndex(uint256 i) {\n    require(_testStep++ == i, \"Error: Wrong test order.\");\n    _;\n  }\n\n  modifier markTime {\n    _timestampLast = block.timestamp;\n    _;\n  }\n\n  modifier forceDelay(uint256 delay) {\n    require(block.timestamp - _timestampLast >= delay, \"Error: test requires time delay\");\n    _timestampLast = block.timestamp;\n    _;\n  }\n}"
    },
    "contracts/UnboundTokenSeller.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\n/* ========== External Interfaces ========== */\nimport \"@indexed-finance/uniswap-v2-oracle/contracts/interfaces/IIndexedUniswapV2Oracle.sol\";\nimport \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/* ========== External Libraries ========== */\nimport \"@indexed-finance/uniswap-v2-oracle/contracts/lib/PriceLibrary.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\n/* ========== Internal Interfaces ========== */\nimport \"./interfaces/IIndexPool.sol\";\nimport \"./interfaces/IUnboundTokenSeller.sol\";\n\n\n/**\n * @title UnboundTokenSeller\n * @author d1ll0n\n * @dev Contract for swapping undesired tokens to desired tokens for\n * an index pool.\n *\n * This contract is deployed as a proxy for each index pool.\n *\n * When tokens are unbound from a pool, they are transferred to this\n * contract and sold on UniSwap or to anyone who calls the contract\n * in exchange for any token which is currently bound to its index pool\n * and which has a desired weight about zero.\n *\n * It uses a short-term uniswap price oracle to price swaps and has a\n * configurable premium rate which is used to decrease the expected\n * output from a swap and to reward callers for triggering a sale.\n *\n * The contract does not track the tokens it has received in order to\n * reduce gas spent by the pool contract. Tokens must be tracked via\n * events, meaning this is not well suited for trades with other smart\n * contracts.\n */\ncontract UnboundTokenSeller is IUnboundTokenSeller {\n  using SafeERC20 for IERC20;\n  using PriceLibrary for PriceLibrary.TwoWayAveragePrice;\n\n/* ==========  Constants  ========== */\n\n  uint32 internal constant SHORT_TWAP_MIN_TIME_ELAPSED = 20 minutes;\n  uint32 internal constant SHORT_TWAP_MAX_TIME_ELAPSED = 2 days;\n\n  IUniswapV2Router02 internal immutable _uniswapRouter;\n  address public immutable controller;\n  IIndexedUniswapV2Oracle public immutable oracle;\n\n/* ==========  Events  ========== */\n\n  event PremiumPercentSet(uint8 premium);\n\n  event NewTokensToSell(\n    address indexed token,\n    uint256 amountReceived\n  );\n\n  /**\n   * @param tokenSold Token sent to caller\n   * @param tokenBought Token received from caller and sent to pool\n   * @param soldAmount Amount of `tokenSold` paid to caller\n   * @param boughtAmount Amount of `tokenBought` sent to pool\n   */\n  event SwappedTokens(\n    address indexed tokenSold,\n    address indexed tokenBought,\n    uint256 soldAmount,\n    uint256 boughtAmount\n  );\n\n/* ==========  Storage  ========== */\n  // Pool the contract is selling tokens for.\n  IIndexPool internal _pool;\n  // Premium on the amount paid in swaps.\n  // Half goes to the caller, half is used to increase payments.\n  uint8 internal _premiumPercent;\n  // Reentrance lock\n  bool internal _mutex;\n\n/* ==========  Modifiers  ========== */\n\n  modifier _control_ {\n    require(msg.sender == controller, \"ERR_NOT_CONTROLLER\");\n    _;\n  }\n\n  modifier _lock_ {\n    require(!_mutex, \"ERR_REENTRY\");\n    _mutex = true;\n    _;\n    _mutex = false;\n  }\n\n  modifier _desired_(address token) {\n    IIndexPool.Record memory record = _pool.getTokenRecord(token);\n    require(record.desiredDenorm > 0, \"ERR_UNDESIRED_TOKEN\");\n    _;\n  }\n\n/* ==========  Constructor  ========== */\n\n  constructor(\n    IUniswapV2Router02 uniswapRouter,\n    IIndexedUniswapV2Oracle oracle_,\n    address controller_\n  ) public {\n    _uniswapRouter = uniswapRouter;\n    oracle = oracle_;\n    controller = controller_;\n  }\n\n  /**\n   * @dev Initialize the proxy contract with the acceptable premium rate\n   * and the address of the pool it is for.\n   */\n  function initialize(address pool, uint8 premiumPercent)\n    external\n    override\n    _control_\n  {\n    require(address(_pool) == address(0), \"ERR_INITIALIZED\");\n    require(pool != address(0), \"ERR_NULL_ADDRESS\");\n    require(\n      premiumPercent > 0 && premiumPercent < 20,\n      \"ERR_PREMIUM\"\n    );\n    _premiumPercent = premiumPercent;\n    _pool = IIndexPool(pool);\n  }\n\n/* ==========  Controls  ========== */\n\n  /**\n   * @dev Receive `amount` of `token` from the pool.\n   */\n  function handleUnbindToken(address token, uint256 amount)\n    external\n    override\n  {\n    require(msg.sender == address(_pool), \"ERR_ONLY_POOL\");\n    emit NewTokensToSell(token, amount);\n  }\n\n  /**\n   * @dev Set the premium rate as a percent.\n   */\n  function setPremiumPercent(uint8 premiumPercent) external override _control_ {\n    require(\n      premiumPercent > 0 && premiumPercent < 20,\n      \"ERR_PREMIUM\"\n    );\n    _premiumPercent = premiumPercent;\n    emit PremiumPercentSet(premiumPercent);\n  }\n\n/* ==========  Token Swaps  ========== */\n\n  /**\n   * @dev Execute a trade with UniSwap to sell some tokens held by the contract\n   * for some tokens desired by the pool and pays the caller the difference between\n   * the maximum input value and the actual paid amount.\n   *\n   * @param tokenIn Token to sell to UniSwap\n   * @param tokenOut Token to receive from UniSwapx\n   * @param amountOut Exact amount of `tokenOut` to receive from UniSwap\n   * @param path Swap path to execute\n   */\n  function executeSwapTokensForExactTokens(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountOut,\n    address[] calldata path\n  )\n    external\n    override\n    _lock_\n    returns (uint256 premiumPaidToCaller)\n  {\n    // calcOutGivenIn uses tokenIn as the token the pool is receiving and\n    // tokenOut as the token the pool is paying, whereas this function is\n    // the reverse.\n    uint256 maxAmountIn = calcOutGivenIn(tokenOut, tokenIn, amountOut);\n    // Approve UniSwap to transfer the input tokens\n    IERC20(tokenIn).safeApprove(address(_uniswapRouter), maxAmountIn);\n    // Verify that the first token in the path is the input token and that\n    // the last is the output token.\n    require(\n      path[0] == tokenIn && path[path.length - 1] == tokenOut,\n      \"ERR_PATH_TOKENS\"\n    );\n    // Execute the swap.\n    uint256[] memory amounts = _uniswapRouter.swapTokensForExactTokens(\n      amountOut,\n      maxAmountIn,\n      path,\n      address(_pool),\n      block.timestamp\n    );\n    // Get the actual amount paid\n    uint256 amountIn = amounts[0];\n    // If we did not swap the full amount, remove the UniSwap allowance.\n    if (amountIn < maxAmountIn) {\n      IERC20(tokenIn).safeApprove(address(_uniswapRouter), 0);\n      premiumPaidToCaller = maxAmountIn - amountIn;\n      // Transfer the difference between what the contract was willing to pay and\n      // what it actually paid to the caller.\n      IERC20(tokenIn).safeTransfer(msg.sender, premiumPaidToCaller);\n\n    }\n    // Update the pool's balance of the token.\n    _pool.gulp(tokenOut);\n    emit SwappedTokens(\n      tokenIn,\n      tokenOut,\n      amountIn,\n      amountOut\n    );\n  }\n\n  /**\n   * @dev Executes a trade with UniSwap to sell some tokens held by the contract\n   * for some tokens desired by the pool and pays the caller any tokens received\n   * above the minimum acceptable output.\n   *\n   * @param tokenIn Token to sell to UniSwap\n   * @param tokenOut Token to receive from UniSwap\n   * @param amountIn Exact amount of `tokenIn` to give UniSwap\n   * @param path Swap path to execute\n   */\n  function executeSwapExactTokensForTokens(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountIn,\n    address[] calldata path\n  )\n    external\n    override\n    _lock_\n    returns (uint256 premiumPaidToCaller)\n  {\n    // calcInGivenOut uses tokenIn as the token the pool is receiving and\n    // tokenOut as the token the pool is paying, whereas this function is\n    // the reverse.\n    uint256 minAmountOut = calcInGivenOut(tokenOut, tokenIn, amountIn);\n    // Approve UniSwap to transfer the input tokens\n    IERC20(tokenIn).safeApprove(address(_uniswapRouter), amountIn);\n    // Verify that the first token in the path is the input token and that\n    // the last is the output token.\n    require(\n      path[0] == tokenIn && path[path.length - 1] == tokenOut,\n      \"ERR_PATH_TOKENS\"\n    );\n    // Execute the swap.\n    uint256[] memory amounts = _uniswapRouter.swapExactTokensForTokens(\n      amountIn,\n      minAmountOut,\n      path,\n      address(this),\n      block.timestamp\n    );\n  \n    // Get the actual amount paid\n    uint256 amountOut = amounts[amounts.length - 1];\n    if (amountOut > minAmountOut) {\n      // Transfer any tokens received beyond the minimum acceptable payment\n      // to the caller as a reward.\n      premiumPaidToCaller = amountOut - minAmountOut;\n      IERC20(tokenOut).safeTransfer(msg.sender, premiumPaidToCaller);\n    }\n    // Transfer the received tokens to the pool\n    IERC20(tokenOut).safeTransfer(address(_pool), minAmountOut);\n    // Update the pool's balance of the token.\n    _pool.gulp(tokenOut);\n    emit SwappedTokens(\n      tokenIn,\n      tokenOut,\n      amountIn,\n      amountOut\n    );\n  }\n\n  /**\n   * @dev Swap exactly `amountIn` of `tokenIn` for at least `minAmountOut`\n   * of `tokenOut`.\n   *\n   * @param tokenIn Token to sell to pool\n   * @param tokenOut Token to buy from pool\n   * @param amountIn Amount of `tokenIn` to sell to pool\n   * @param minAmountOut Minimum amount of `tokenOut` to buy from pool\n   */\n  function swapExactTokensForTokens(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountIn,\n    uint256 minAmountOut\n  )\n    external\n    override\n    _lock_\n    returns (uint256 amountOut)\n  {\n    amountOut = calcOutGivenIn(tokenIn, tokenOut, amountIn);\n    // Verify the amount is above the provided minimum.\n    require(amountOut >= minAmountOut, \"ERR_MIN_AMOUNT_OUT\");\n    // Transfer the input tokens to the pool\n    IERC20(tokenIn).safeTransferFrom(msg.sender, address(_pool), amountIn);\n    _pool.gulp(tokenIn);\n    // Transfer the output tokens to the caller\n    IERC20(tokenOut).safeTransfer(msg.sender, amountOut);\n    emit SwappedTokens(\n      tokenOut,\n      tokenIn,\n      amountOut,\n      amountIn\n    );\n  }\n\n  /**\n   * @dev Swap up to `maxAmountIn` of `tokenIn` for exactly `amountOut`\n   * of `tokenOut`.\n   *\n   * @param tokenIn Token to sell to pool\n   * @param tokenOut Token to buy from pool\n   * @param amountOut Amount of `tokenOut` to buy from pool\n   * @param maxAmountIn Maximum amount of `tokenIn` to sell to pool\n   */\n  function swapTokensForExactTokens(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountOut,\n    uint256 maxAmountIn\n  )\n    external\n    override\n    _lock_\n    returns (uint256 amountIn)\n  {\n    amountIn = calcInGivenOut(tokenIn, tokenOut, amountOut);\n    require(amountIn <= maxAmountIn, \"ERR_MAX_AMOUNT_IN\");\n    // Transfer the input tokens to the pool\n    IERC20(tokenIn).safeTransferFrom(msg.sender, address(_pool), amountIn);\n    _pool.gulp(tokenIn);\n    // Transfer the output tokens to the caller\n    IERC20(tokenOut).safeTransfer(msg.sender, amountOut);\n    emit SwappedTokens(\n      tokenOut,\n      tokenIn,\n      amountOut,\n      amountIn\n    );\n  }\n\n/* ==========  Swap Queries  ========== */\n\n  function getPremiumPercent() external view override returns (uint8) {\n    return _premiumPercent;\n  }\n\n  /**\n   * @dev Calculate the amount of `tokenIn` the pool will accept for\n   * `amountOut` of `tokenOut`.\n   */\n  function calcInGivenOut(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountOut\n  )\n    public\n    view\n    override\n    _desired_(tokenIn)\n    returns (uint256 amountIn)\n  {\n    require(\n      IERC20(tokenOut).balanceOf(address(this)) >= amountOut,\n      \"ERR_INSUFFICIENT_BALANCE\"\n    );\n    (\n      PriceLibrary.TwoWayAveragePrice memory avgPriceIn,\n      PriceLibrary.TwoWayAveragePrice memory avgPriceOut\n    ) = _getAveragePrices(tokenIn, tokenOut);\n    // Compute the average weth value for `amountOut` of `tokenOut`\n    uint144 avgOutValue = avgPriceOut.computeAverageEthForTokens(amountOut);\n    // Compute the minimum weth value the contract must receive for `avgOutValue`\n    uint256 minInValue = _minimumReceivedValue(avgOutValue);\n    // Compute the average amount of `tokenIn` worth `minInValue` weth\n    amountIn = avgPriceIn.computeAverageTokensForEth(minInValue);\n  }\n\n  /**\n   * @dev Calculate the amount of `tokenOut` the pool will give for\n   * `amountIn` of `tokenIn`.\n   */\n  function calcOutGivenIn(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountIn\n  )\n    public\n    view\n    override\n    _desired_(tokenIn)\n    returns (uint256 amountOut)\n  {\n    (\n      PriceLibrary.TwoWayAveragePrice memory avgPriceIn,\n      PriceLibrary.TwoWayAveragePrice memory avgPriceOut\n    ) = _getAveragePrices(tokenIn, tokenOut);\n    // Compute the average weth value for `amountIn` of `tokenIn`\n    uint144 avgInValue = avgPriceIn.computeAverageEthForTokens(amountIn);\n    // Compute the maximum weth value the contract will give for `avgInValue`\n    uint256 maxOutValue = _maximumPaidValue(avgInValue);\n    // Compute the average amount of `tokenOut` worth `maxOutValue` weth\n    amountOut = avgPriceOut.computeAverageTokensForEth(maxOutValue);\n    require(\n      IERC20(tokenOut).balanceOf(address(this)) >= amountOut,\n      \"ERR_INSUFFICIENT_BALANCE\"\n    );\n  }\n\n/* ==========  Internal Functions  ========== */\n\n  function _getAveragePrices(address token1, address token2)\n    internal\n    view\n    returns (\n      PriceLibrary.TwoWayAveragePrice memory avgPrice1,\n      PriceLibrary.TwoWayAveragePrice memory avgPrice2\n    )\n  {\n    address[] memory tokens = new address[](2);\n    tokens[0] = token1;\n    tokens[1] = token2;\n    PriceLibrary.TwoWayAveragePrice[] memory prices = oracle.computeTwoWayAveragePrices(\n      tokens,\n      SHORT_TWAP_MIN_TIME_ELAPSED,\n      SHORT_TWAP_MAX_TIME_ELAPSED\n    );\n    avgPrice1 = prices[0];\n    avgPrice2 = prices[1];\n  }\n\n  function _maximumPaidValue(uint256 valueReceived)\n    internal\n    view\n    returns (uint256 maxPaidValue)\n  {\n    maxPaidValue = (100 * valueReceived) / (100 - _premiumPercent);\n  }\n\n\n  function _minimumReceivedValue(uint256 valuePaid)\n    internal\n    view\n    returns (uint256 minValueReceived)\n  {\n    minValueReceived = (valuePaid * (100 - _premiumPercent)) / 100;\n  }\n}"
    },
    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/PoolFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\n/* ========== External Inheritance ========== */\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/* ========== External Interfaces ========== */\nimport \"@indexed-finance/proxies/contracts/interfaces/IDelegateCallProxyManager.sol\";\n\n/* ========== External Libraries ========== */\nimport \"@indexed-finance/proxies/contracts/SaltyLib.sol\";\n\n/* ========== Internal Interfaces ========== */\nimport \"./interfaces/IPoolFactory.sol\";\n\n\n/**\n * @title PoolFactory\n * @author d1ll0n\n */\ncontract PoolFactory is Ownable, IPoolFactory {\n/* ==========  Constants  ========== */\n\n  // Address of the proxy manager contract.\n  IDelegateCallProxyManager public override immutable proxyManager;\n\n/* ==========  Events  ========== */\n\n  /** @dev Emitted when a pool is deployed. */\n  event NewPool(address pool, address controller, bytes32 implementationID);\n\n/* ==========  Storage  ========== */\n\n  mapping(address => bool) public override isApprovedController;\n  mapping(address => bytes32) public override getPoolImplementationID;\n\n/* ==========  Modifiers  ========== */\n\n  modifier onlyApproved {\n    require(isApprovedController[msg.sender], \"ERR_NOT_APPROVED\");\n    _;\n  }\n\n/* ==========  Constructor  ========== */\n\n  constructor(IDelegateCallProxyManager proxyManager_) public Ownable() {\n    proxyManager = proxyManager_;\n  }\n\n/* ==========  Controller Approval  ========== */\n\n  /** @dev Approves `controller` to deploy pools. */\n  function approvePoolController(address controller) external override onlyOwner {\n    isApprovedController[controller] = true;\n  }\n\n  /** @dev Removes the ability of `controller` to deploy pools. */\n  function disapprovePoolController(address controller) external override onlyOwner {\n    isApprovedController[controller] = false;\n  }\n\n/* ==========  Pool Deployment  ========== */\n\n  /**\n   * @dev Deploys a pool using an implementation ID provided by the controller.\n   *\n   * Note: To support future interfaces, this does not initialize or\n   * configure the pool, this must be executed by the controller.\n   *\n   * Note: Must be called by an approved controller.\n   *\n   * @param implementationID Implementation ID for the pool\n   * @param controllerSalt Create2 salt provided by the deployer\n   */\n  function deployPool(bytes32 implementationID, bytes32 controllerSalt)\n    external\n    override\n    onlyApproved\n    returns (address poolAddress)\n  {\n    bytes32 suppliedSalt = keccak256(abi.encodePacked(msg.sender, controllerSalt));\n    poolAddress = proxyManager.deployProxyManyToOne(implementationID, suppliedSalt);\n    getPoolImplementationID[poolAddress] = implementationID;\n    emit NewPool(poolAddress, msg.sender, implementationID);\n  }\n\n/* ==========  Queries  ========== */\n\n  /**\n   * @dev Checks if an address is a pool that was deployed by the factory.\n   */\n  function isRecognizedPool(address pool) external view override returns (bool) {\n    return getPoolImplementationID[pool] != bytes32(0);\n  }\n\n  /**\n   * @dev Compute the create2 address for a pool deployed by an approved controller.\n   */\n  function computePoolAddress(bytes32 implementationID, address controller, bytes32 controllerSalt)\n    public\n    view\n    override\n    returns (address)\n  {\n    bytes32 suppliedSalt = keccak256(abi.encodePacked(controller, controllerSalt));\n    return SaltyLib.computeProxyAddressManyToOne(\n      address(proxyManager),\n      address(this),\n      implementationID,\n      suppliedSalt\n    );\n  }\n}"
    },
    "contracts/PoolInitializer.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\n/* ========== External Interfaces ========== */\nimport \"@indexed-finance/uniswap-v2-oracle/contracts/interfaces/IIndexedUniswapV2Oracle.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/* ========== External Libraries ========== */\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\n/* ========== Internal Interfaces ========== */\nimport \"./interfaces/IPoolInitializer.sol\";\n\n\n/**\n * @title PoolInitializer\n * @author d1ll0n\n * @dev Contract that acquires the initial balances for an index pool.\n *\n * This uses a short-term UniSwap price oracle to determine the ether\n * value of tokens sent to the contract. When users contribute tokens,\n * they are credited for the moving average ether value of said tokens.\n * When all the tokens needed are acquired, the index pool will be\n * initialized and this contract will receive the initial token supply (100).\n *\n * Once the contract receives the index pool tokens, users can claim their\n * share of the tokens proportional to their credited contribution value.\n */\ncontract PoolInitializer is IPoolInitializer {\n  using SafeMath for uint256;\n  using SafeERC20 for IERC20;\n\n/* ==========  Constants  ========== */\n\n  uint32 internal constant SHORT_TWAP_MIN_TIME_ELAPSED = 20 minutes;\n  uint32 internal constant SHORT_TWAP_MAX_TIME_ELAPSED = 2 days;\n  uint256 internal constant TOKENS_MINTED = 1e20;\n\n  address public immutable controller;\n  IIndexedUniswapV2Oracle public immutable oracle;\n\n/* ==========  Events  ========== */\n\n  event TokensContributed(\n    address from,\n    address token,\n    uint256 amount,\n    uint256 credit\n  );\n\n  event TokensClaimed(address account, uint256 tokens);\n\n/* ==========  Storage  ========== */\n  // Token amounts to purchase\n  mapping(address => uint256) internal _remainingDesiredAmounts;\n  // Value contributed in ether\n  mapping(address => uint256) internal _credits;\n  address[] internal _tokens;\n  // Total value in ether contributed to the pool, computed at the time\n  // of receipt.\n  uint256 internal _totalCredit;\n  // Whether all the desired tokens have been received.\n  bool internal _finished;\n  address internal _poolAddress;\n  bool internal _mutex;\n\n/* ==========  Modifiers  ========== */\n\n  modifier _lock_ {\n    require(!_mutex, \"ERR_REENTRY\");\n    _mutex = true;\n    _;\n    _mutex = false;\n  }\n\n  modifier _control_ {\n    require(msg.sender == controller, \"ERR_NOT_CONTROLLER\");\n    _;\n  }\n\n  modifier _finished_ {\n    require(_finished, \"ERR_NOT_FINISHED\");\n    _;\n  }\n\n  modifier _not_finished_ {\n    require(!_finished, \"ERR_FINISHED\");\n    _;\n  }\n\n/* ==========  Constructor  ========== */\n\n  constructor(\n    IIndexedUniswapV2Oracle oracle_,\n    address controller_\n  ) public {\n    oracle = oracle_;\n    controller = controller_;\n  }\n\n/* ==========  Start & Finish Functions  ========== */\n\n  /**\n   * @dev Sets up the pre-deployment pool.\n   *\n   * @param poolAddress Address of the pool this pre-deployment pool is for\n   * @param tokens Array of desired tokens\n   * @param amounts Desired amounts of the corresponding `tokens`\n   */\n  function initialize(\n    address poolAddress,\n    address[] calldata tokens,\n    uint256[] calldata amounts\n  )\n    external\n    override\n    _control_\n  {\n    require(_poolAddress == address(0), \"ERR_INITIALIZED\");\n    _poolAddress = poolAddress;\n    uint256 len = tokens.length;\n    require(amounts.length == len, \"ERR_ARR_LEN\");\n    _tokens = tokens;\n    for (uint256 i = 0; i < len; i++) {\n      _remainingDesiredAmounts[tokens[i]] = amounts[i];\n    }\n  }\n\n  /**\n   * @dev Finishes the pre-deployment pool and triggers pool initialization.\n   *\n   * Note: The desired amounts of all tokens must be 0.\n  */\n  function finish()\n    external\n    override\n    _lock_\n    _not_finished_\n  {\n    uint256 len = _tokens.length;\n    address controller_ = controller;\n    address[] memory tokens = new address[](len);\n    uint256[] memory balances = new uint256[](len);\n    for (uint256 i = 0; i < len; i++) {\n      address token = _tokens[i];\n      tokens[i] = token;\n      uint256 balance = IERC20(token).balanceOf(address(this));\n      balances[i] = balance;\n      IERC20(token).safeApprove(_poolAddress, balance);\n      require(\n        _remainingDesiredAmounts[token] == 0,\n        \"ERR_PENDING_TOKENS\"\n      );\n    }\n    PoolController(controller_).finishPreparedIndexPool(\n      _poolAddress,\n      tokens,\n      balances\n    );\n    _finished = true;\n  }\n\n/* ==========  Pool Token Claims  ========== */\n\n  /**\n   * @dev Claims the tokens owed to `msg.sender` based on their proportion\n   * of the total credits.\n  */\n  function claimTokens() external override _lock_ _finished_ {\n    _claimTokens(msg.sender);\n  }\n\n  /**\n   * @dev Claims the tokens owed to `account` based on their proportion\n   * of the total credits.\n  */\n  function claimTokens(address account) external override _lock_ _finished_ {\n    _claimTokens(account);\n  }\n\n  /**\n   * @dev Claims the tokens owed to `account` based on their proportion\n   * of the total credits.\n  */\n  function claimTokens(address[] calldata accounts) external override _lock_ _finished_ {\n    for (uint256 i = 0; i < accounts.length; i++) {\n      _claimTokens(accounts[i]);\n    }\n  }\n\n/* ==========  Contribution  ========== */\n\n  /**\n   * @dev Contribute up to `amountIn` of `token` to the pool for credit.\n   * The caller will be credited for the average weth value of the provided\n   * tokens.\n   *\n   * Caller must receive at least `minimumCredit` to not revert.\n   *\n   * If `amountIn` is greater than the desired amount of `token`, the\n   * desired amount will be used instead. \n   */\n  function contributeTokens(\n    address token,\n    uint256 amountIn,\n    uint256 minimumCredit\n  )\n    external\n    override\n    _lock_\n    _not_finished_\n    returns (uint256 credit)\n  {\n    uint256 desiredAmount = _remainingDesiredAmounts[token];\n    require(desiredAmount > 0, \"ERR_NOT_NEEDED\");\n    if (amountIn > desiredAmount) {\n      amountIn = desiredAmount;\n    }\n    credit = oracle.computeAverageEthForTokens(\n      token,\n      amountIn,\n      SHORT_TWAP_MIN_TIME_ELAPSED,\n      SHORT_TWAP_MAX_TIME_ELAPSED\n    );\n    require(credit > 0 && amountIn > 0, \"ERR_ZERO_AMOUNT\");\n    require(credit >= minimumCredit, \"ERR_MIN_CREDIT\");\n    IERC20(token).safeTransferFrom(msg.sender, address(this), amountIn);\n    _remainingDesiredAmounts[token] = desiredAmount.sub(amountIn);\n    _credits[msg.sender] = _credits[msg.sender].add(credit);\n    _totalCredit = _totalCredit.add(credit);\n    emit TokensContributed(msg.sender, token, amountIn, credit);\n  }\n\n  /**\n   * @dev Contribute maximum values from `amountsIn` of the corresponding\n   * tokens in `tokens` to the pool for credit.\n   *\n   * The caller will be credited for the average weth value of the provided\n   * tokens.\n   *\n   * Caller must receive at least `minimumCredit` to not revert.\n   *\n   * If any input amount is greater than the desired amount of the corresponding\n   * token, the desired amount will be used instead.\n   */\n  function contributeTokens(\n    address[] calldata tokens,\n    uint256[] calldata amountsIn,\n    uint256 minimumCredit\n  )\n    external\n    override\n    _lock_\n    _not_finished_\n    returns (uint256 credit)\n  {\n    uint256 len = tokens.length;\n    require(amountsIn.length == len, \"ERR_ARR_LEN\");\n    credit = 0;\n    for (uint256 i = 0; i < len; i++) {\n      address token = tokens[i];\n      uint256 amountIn = amountsIn[i];\n      uint256 desiredAmount = _remainingDesiredAmounts[token];\n      require(desiredAmount > 0, \"ERR_NOT_NEEDED\");\n      if (amountIn > desiredAmount) {\n        amountIn = desiredAmount;\n      }\n      uint256 creditOut = oracle.computeAverageEthForTokens(\n        token,\n        amountIn,\n        SHORT_TWAP_MIN_TIME_ELAPSED,\n        SHORT_TWAP_MAX_TIME_ELAPSED\n      );\n      require(creditOut > 0 && amountIn > 0, \"ERR_ZERO_AMOUNT\");\n      IERC20(token).safeTransferFrom(msg.sender, address(this), amountIn);\n      _remainingDesiredAmounts[token] = desiredAmount.sub(amountIn);\n      credit = credit.add(creditOut);\n      emit TokensContributed(msg.sender, token, amountIn, creditOut);\n    }\n    require(credit >= minimumCredit, \"ERR_MIN_CREDIT\");\n    _credits[msg.sender] = _credits[msg.sender].add(credit);\n    _totalCredit = _totalCredit.add(credit);\n  }\n\n/* ==========  Price Actions  ========== */\n\n  /**\n   * @dev Updates the prices of all tokens.\n   */\n  function updatePrices() external override {\n    oracle.updatePrices(_tokens);\n  }\n\n/* ==========  Status Queries  ========== */\n\n  /**\n   * @dev Returns whether the pool has been initialized.\n   */\n  function isFinished() external view override returns (bool) {\n    return _finished;\n  }\n\n/* ==========  Status Queries  ========== */\n\n  /**\n   * @dev Returns the total value credited for token contributions.\n   */\n  function getTotalCredit() external view override returns (uint256) {\n    return _totalCredit;\n  }\n\n  /**\n   * @dev Returns the amount of credit owed to `account`.\n   */\n  function getCreditOf(address account)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    return _credits[account];\n  }\n\n/* ==========  Token Queries  ========== */\n\n  function getDesiredTokens()\n    external\n    view\n    override\n    returns (address[] memory tokens)\n  {\n    tokens = _tokens;\n  }\n\n  function getDesiredAmount(address token)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    return _remainingDesiredAmounts[token];\n  }\n\n  function getDesiredAmounts(address[] calldata tokens)\n    external\n    view\n    override\n    returns (uint256[] memory amounts)\n  {\n    amounts = new uint256[](tokens.length);\n    for (uint256 i = 0; i < tokens.length; i++) {\n      amounts[i] = _remainingDesiredAmounts[tokens[i]];\n    }\n  }\n\n/* ==========  External Price Queries ========== */\n  /**\n   * @dev Get the amount of WETH the contract will credit a user\n   * for providing `amountIn` of `token`.\n   *\n   * Note: If `amountIn` is greater than the desired amount of\n   * `token`, this will calculate the output using the desired\n   * amount instead of `amountIn`.\n   */\n  function getCreditForTokens(address token, uint256 amountIn)\n    external\n    view\n    override\n    returns (uint144 amountOut)\n  {\n    uint256 desiredAmount = _remainingDesiredAmounts[token];\n    require(desiredAmount > 0, \"ERR_NOT_NEEDED\");\n    if (amountIn > desiredAmount) {\n      amountIn = desiredAmount;\n    }\n    uint144 averageWethValue = oracle.computeAverageEthForTokens(\n      token,\n      amountIn,\n      SHORT_TWAP_MIN_TIME_ELAPSED,\n      SHORT_TWAP_MAX_TIME_ELAPSED\n    );\n    amountOut = averageWethValue;\n  }\n\n/* ==========  Internal Claims Functions  ========== */\n\n  /**\n   * @dev Claims pool tokens owed to `account` based on their\n   * proportion of the total credit.\n   * Note: Must be called in a function with the `_finished` modifier.\n   * Note: Must be called in a function with the `_lock_` modifier.\n   */\n  function _claimTokens(address account) internal {\n    uint256 credit = _credits[account];\n    require(credit > 0, \"ERR_NULL_CREDIT\");\n    uint256 amountOut = (TOKENS_MINTED.mul(credit)).div(_totalCredit);\n    _credits[account] = 0;\n    IERC20(_poolAddress).safeTransfer(account, amountOut);\n    emit TokensClaimed(account, amountOut);\n  }\n}\n\n\ninterface PoolController {\n  function finishPreparedIndexPool(\n    address poolAddress,\n    address[] calldata tokens,\n    uint256[] calldata balances\n  ) external;\n}"
    }
  },
  "settings": {
    "metadata": {
      "useLiteralContent": false
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "id",
          "ast"
        ]
      }
    }
  }
}