{
  "language": "Solidity",
  "sources": {
    "temp-contracts/interfaces/IIndexPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\n\ninterface IIndexPool {\n  /**\n   * @dev Token record data structure\n   * @param bound is token bound to pool\n   * @param ready has token been initialized\n   * @param lastDenormUpdate timestamp of last denorm change\n   * @param denorm denormalized weight\n   * @param desiredDenorm desired denormalized weight (used for incremental changes)\n   * @param index index of address in tokens array\n   * @param balance token balance\n   */\n  struct Record {\n    bool bound;\n    bool ready;\n    uint40 lastDenormUpdate;\n    uint96 denorm;\n    uint96 desiredDenorm;\n    uint8 index;\n    uint256 balance;\n  }\n\n  event LOG_SWAP(\n    address indexed caller,\n    address indexed tokenIn,\n    address indexed tokenOut,\n    uint256 tokenAmountIn,\n    uint256 tokenAmountOut\n  );\n\n  event LOG_JOIN(\n    address indexed caller,\n    address indexed tokenIn,\n    uint256 tokenAmountIn\n  );\n\n  event LOG_EXIT(\n    address indexed caller,\n    address indexed tokenOut,\n    uint256 tokenAmountOut\n  );\n\n  event LOG_DENORM_UPDATED(address indexed token, uint256 newDenorm);\n\n  event LOG_DESIRED_DENORM_SET(address indexed token, uint256 desiredDenorm);\n\n  event LOG_TOKEN_REMOVED(address token);\n\n  event LOG_TOKEN_ADDED(\n    address indexed token,\n    uint256 desiredDenorm,\n    uint256 minimumBalance\n  );\n\n  event LOG_MINIMUM_BALANCE_UPDATED(address token, uint256 minimumBalance);\n\n  event LOG_TOKEN_READY(address indexed token);\n\n  event LOG_PUBLIC_SWAP_ENABLED();\n\n  event LOG_MAX_TOKENS_UPDATED(uint256 maxPoolTokens);\n\n  event LOG_SWAP_FEE_UPDATED(uint256 swapFee);\n\n  function configure(\n    address controller,\n    string calldata name,\n    string calldata symbol\n  ) external;\n\n  function initialize(\n    address[] calldata tokens,\n    uint256[] calldata balances,\n    uint96[] calldata denorms,\n    address tokenProvider,\n    address unbindHandler\n  ) external;\n\n  function setMaxPoolTokens(uint256 maxPoolTokens) external;\n\n  function setSwapFee(uint256 swapFee) external;\n\n  function reweighTokens(\n    address[] calldata tokens,\n    uint96[] calldata desiredDenorms\n  ) external;\n\n  function reindexTokens(\n    address[] calldata tokens,\n    uint96[] calldata desiredDenorms,\n    uint256[] calldata minimumBalances\n  ) external;\n\n  function setMinimumBalance(address token, uint256 minimumBalance) external;\n\n  function joinPool(uint256 poolAmountOut, uint256[] calldata maxAmountsIn) external;\n\n  function joinswapExternAmountIn(\n    address tokenIn,\n    uint256 tokenAmountIn,\n    uint256 minPoolAmountOut\n  ) external returns (uint256/* poolAmountOut */);\n\n  function joinswapPoolAmountOut(\n    address tokenIn,\n    uint256 poolAmountOut,\n    uint256 maxAmountIn\n  ) external returns (uint256/* tokenAmountIn */);\n\n  function exitPool(uint256 poolAmountIn, uint256[] calldata minAmountsOut) external;\n\n  function exitswapPoolAmountIn(\n    address tokenOut,\n    uint256 poolAmountIn,\n    uint256 minAmountOut\n  )\n    external returns (uint256/* tokenAmountOut */);\n\n  function exitswapExternAmountOut(\n    address tokenOut,\n    uint256 tokenAmountOut,\n    uint256 maxPoolAmountIn\n  ) external returns (uint256/* poolAmountIn */);\n\n  function gulp(address token) external;\n\n  function flashBorrow(\n    address recipient,\n    address token,\n    uint256 amount,\n    bytes calldata data\n  ) external;\n\n  function swapExactAmountIn(\n    address tokenIn,\n    uint256 tokenAmountIn,\n    address tokenOut,\n    uint256 minAmountOut,\n    uint256 maxPrice\n  ) external returns (uint256/* tokenAmountOut */, uint256/* spotPriceAfter */);\n\n  function swapExactAmountOut(\n    address tokenIn,\n    uint256 maxAmountIn,\n    address tokenOut,\n    uint256 tokenAmountOut,\n    uint256 maxPrice\n  ) external returns (uint256 /* tokenAmountIn */, uint256 /* spotPriceAfter */);\n\n  function isPublicSwap() external view returns (bool);\n\n  function getSwapFee() external view returns (uint256/* swapFee */);\n\n  function getController() external view returns (address);\n\n  function getMaxPoolTokens() external view returns (uint256);\n\n  function isBound(address t) external view returns (bool);\n\n  function getNumTokens() external view returns (uint256);\n\n  function getCurrentTokens() external view returns (address[] memory tokens);\n\n  function getCurrentDesiredTokens() external view returns (address[] memory tokens);\n\n  function getDenormalizedWeight(address token) external view returns (uint256/* denorm */);\n\n  function getTokenRecord(address token) external view returns (Record memory record);\n\n  function extrapolatePoolValueFromToken() external view returns (address/* token */, uint256/* extrapolatedValue */);\n\n  function getTotalDenormalizedWeight() external view returns (uint256);\n\n  function getBalance(address token) external view returns (uint256);\n\n  function getMinimumBalance(address token) external view returns (uint256);\n\n  function getUsedBalance(address token) external view returns (uint256);\n\n  function getSpotPrice(address tokenIn, address tokenOut) external view returns (uint256);\n}"
    },
    "temp-contracts/interfaces/IPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\n\nimport \"@indexed-finance/proxies/contracts/interfaces/IDelegateCallProxyManager.sol\";\n\n\ninterface IPoolFactory {\n/* ========== Events ========== */\n\n  event NewPool(address pool, address controller, bytes32 implementationID);\n\n/* ========== Mutative ========== */\n\n  function approvePoolController(address controller) external;\n\n  function disapprovePoolController(address controller) external;\n\n  function deployPool(bytes32 implementationID, bytes32 controllerSalt) external returns (address);\n\n/* ========== Views ========== */\n\n  function proxyManager() external view returns (IDelegateCallProxyManager);\n\n  function isApprovedController(address) external view returns (bool);\n\n  function getPoolImplementationID(address) external view returns (bytes32);\n\n  function isRecognizedPool(address pool) external view returns (bool);\n\n  function computePoolAddress(\n    bytes32 implementationID,\n    address controller,\n    bytes32 controllerSalt\n  ) external view returns (address);\n}"
    },
    "@indexed-finance/proxies/contracts/interfaces/IDelegateCallProxyManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\n\n\n/**\n * @dev Contract that manages deployment and upgrades of delegatecall proxies.\n *\n * An implementation identifier can be created on the proxy manager which is\n * used to specify the logic address for a particular contract type, and to\n * upgrade the implementation as needed.\n *\n * A one-to-one proxy is a single proxy contract with an upgradeable implementation\n * address.\n *\n * A many-to-one proxy is a single upgradeable implementation address that may be\n * used by many proxy contracts.\n */\ninterface IDelegateCallProxyManager {\n/* ==========  Events  ========== */\n\n  event DeploymentApprovalGranted(address deployer);\n  event DeploymentApprovalRevoked(address deployer);\n\n  event ManyToOne_ImplementationCreated(\n    bytes32 implementationID,\n    address implementationAddress\n  );\n\n  event ManyToOne_ImplementationUpdated(\n    bytes32 implementationID,\n    address implementationAddress\n  );\n\n  event ManyToOne_ProxyDeployed(\n    bytes32 implementationID,\n    address proxyAddress\n  );\n\n  event OneToOne_ProxyDeployed(\n    address proxyAddress,\n    address implementationAddress\n  );\n\n  event OneToOne_ImplementationUpdated(\n    address proxyAddress,\n    address implementationAddress\n  );\n\n/* ==========  Controls  ========== */\n\n  /**\n   * @dev Allows `deployer` to deploy many-to-one proxies.\n   */\n  function approveDeployer(address deployer) external;\n\n  /**\n   * @dev Prevents `deployer` from deploying many-to-one proxies.\n   */\n  function revokeDeployerApproval(address deployer) external;\n\n/* ==========  Implementation Management  ========== */\n\n  /**\n   * @dev Creates a many-to-one proxy relationship.\n   *\n   * Deploys an implementation holder contract which stores the\n   * implementation address for many proxies. The implementation\n   * address can be updated on the holder to change the runtime\n   * code used by all its proxies.\n   *\n   * @param implementationID ID for the implementation, used to identify the\n   * proxies that use it. Also used as the salt in the create2 call when\n   * deploying the implementation holder contract.\n   * @param implementation Address with the runtime code the proxies\n   * should use.\n   */\n  function createManyToOneProxyRelationship(\n    bytes32 implementationID,\n    address implementation\n  ) external;\n\n  /**\n   * @dev Lock the current implementation for `proxyAddress` so that it can never be upgraded again.\n   */\n  function lockImplementationManyToOne(bytes32 implementationID) external;\n\n  /**\n   * @dev Lock the current implementation for `proxyAddress` so that it can never be upgraded again.\n   */\n  function lockImplementationOneToOne(address proxyAddress) external;\n\n  /**\n   * @dev Updates the implementation address for a many-to-one\n   * proxy relationship.\n   *\n   * @param implementationID Identifier for the implementation.\n   * @param implementation Address with the runtime code the proxies\n   * should use.\n   */\n  function setImplementationAddressManyToOne(\n    bytes32 implementationID,\n    address implementation\n  ) external;\n\n  /**\n   * @dev Updates the implementation address for a one-to-one proxy.\n   *\n   * Note: This could work for many-to-one as well if the caller\n   * provides the implementation holder address in place of the\n   * proxy address, as they use the same access control and update\n   * mechanism.\n   *\n   * @param proxyAddress Address of the deployed proxy\n   * @param implementation Address with the runtime code for\n   * the proxy to use.\n   */\n  function setImplementationAddressOneToOne(\n    address proxyAddress,\n    address implementation\n  ) external;\n\n/* ==========  Proxy Deployment  ========== */\n\n  /**\n   * @dev Deploy a proxy contract with a one-to-one relationship\n   * with its implementation.\n   *\n   * The proxy will have its own implementation address which can\n   * be updated by the proxy manager.\n   *\n   * @param suppliedSalt Salt provided by the account requesting deployment.\n   * @param implementation Address of the contract with the runtime\n   * code that the proxy should use.\n   */\n  function deployProxyOneToOne(\n    bytes32 suppliedSalt,\n    address implementation\n  ) external returns(address proxyAddress);\n\n  /**\n   * @dev Deploy a proxy with a many-to-one relationship with its implemenation.\n   *\n   * The proxy will call the implementation holder for every transaction to\n   * determine the address to use in calls.\n   *\n   * @param implementationID Identifier for the proxy's implementation.\n   * @param suppliedSalt Salt provided by the account requesting deployment.\n   */\n  function deployProxyManyToOne(\n    bytes32 implementationID,\n    bytes32 suppliedSalt\n  ) external returns(address proxyAddress);\n\n/* ==========  Queries  ========== */\n\n  /**\n   * @dev Returns a boolean stating whether `implementationID` is locked.\n   */\n  function isImplementationLocked(bytes32 implementationID) external view returns (bool);\n\n  /**\n   * @dev Returns a boolean stating whether `proxyAddress` is locked.\n   */\n  function isImplementationLocked(address proxyAddress) external view returns (bool);\n\n  /**\n   * @dev Returns a boolean stating whether `deployer` is allowed to deploy many-to-one\n   * proxies.\n   */\n  function isApprovedDeployer(address deployer) external view returns (bool);\n\n  /**\n   * @dev Queries the temporary storage value `_implementationHolder`.\n   * This is used in the constructor of the many-to-one proxy contract\n   * so that the create2 address is static (adding constructor arguments\n   * would change the codehash) and the implementation holder can be\n   * stored as a constant.\n   */\n  function getImplementationHolder() external view returns (address);\n\n  /**\n   * @dev Returns the address of the implementation holder contract\n   * for `implementationID`.\n   */\n  function getImplementationHolder(bytes32 implementationID) external view returns (address);\n\n  /**\n   * @dev Computes the create2 address for a one-to-one proxy requested\n   * by `originator` using `suppliedSalt`.\n   *\n   * @param originator Address of the account requesting deployment.\n   * @param suppliedSalt Salt provided by the account requesting deployment.\n   */\n  function computeProxyAddressOneToOne(\n    address originator,\n    bytes32 suppliedSalt\n  ) external view returns (address);\n\n  /**\n   * @dev Computes the create2 address for a many-to-one proxy for the\n   * implementation `implementationID` requested by `originator` using\n   * `suppliedSalt`.\n   *\n   * @param originator Address of the account requesting deployment.\n   * @param implementationID The identifier for the contract implementation.\n   * @param suppliedSalt Salt provided by the account requesting deployment.\n  */\n  function computeProxyAddressManyToOne(\n    address originator,\n    bytes32 implementationID,\n    bytes32 suppliedSalt\n  ) external view returns (address);\n\n  /**\n   * @dev Computes the create2 address of the implementation holder\n   * for `implementationID`.\n   *\n   * @param implementationID The identifier for the contract implementation.\n  */\n  function computeHolderAddressManyToOne(bytes32 implementationID) external view returns (address);\n}"
    },
    "temp-contracts/interfaces/IPoolInitializer.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\n\n\ninterface IPoolInitializer {\n/* ========== Events ========== */\n\n  event TokensContributed(\n    address from,\n    address token,\n    uint256 amount,\n    uint256 credit\n  );\n\n/* ========== Mutative ========== */\n\n  function initialize(\n    address poolAddress,\n    address[] calldata tokens,\n    uint256[] calldata amounts\n  ) external;\n\n  function finish() external;\n\n  function claimTokens() external;\n\n  function claimTokens(address account) external;\n\n  function claimTokens(address[] calldata accounts) external;\n\n  function contributeTokens(\n    address token,\n    uint256 amountIn,\n    uint256 minimumCredit\n  ) external returns (uint256);\n\n  function contributeTokens(\n    address[] calldata tokens,\n    uint256[] calldata amountsIn,\n    uint256 minimumCredit\n  ) external returns (uint256);\n\n  function updatePrices() external;\n\n/* ========== Views ========== */\n\n  function isFinished() external view returns (bool);\n\n  function getTotalCredit() external view returns (uint256);\n\n  function getCreditOf(address account) external view returns (uint256);\n\n  function getDesiredTokens() external view returns (address[] memory);\n\n  function getDesiredAmount(address token) external view returns (uint256);\n\n  function getDesiredAmounts(address[] calldata tokens) external view returns (uint256[] memory);\n\n  function getCreditForTokens(address token, uint256 amountIn) external view returns (uint144);\n}"
    },
    "temp-contracts/interfaces/IUnboundTokenSeller.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\n\ninterface IUnboundTokenSeller {\n/* ========== Events ========== */\n\n  event PremiumPercentSet(uint8 premium);\n\n  event NewTokensToSell(address indexed token, uint256 amountReceived);\n\n  event SwappedTokens(\n    address indexed tokenSold,\n    address indexed tokenBought,\n    uint256 soldAmount,\n    uint256 boughtAmount\n  );\n\n/* ========== Mutative ========== */\n\n  function initialize(address pool, uint8 premiumPercent) external;\n\n  function handleUnbindToken(address token, uint256 amount) external;\n\n  function setPremiumPercent(uint8 premiumPercent) external;\n\n  function executeSwapTokensForExactTokens(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountOut,\n    address[] calldata path\n  ) external returns (uint256);\n\n  function executeSwapExactTokensForTokens(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountIn,\n    address[] calldata path\n  ) external returns (uint256);\n\n  function swapExactTokensForTokens(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountIn,\n    uint256 minAmountOut\n  ) external returns (uint256);\n\n  function swapTokensForExactTokens(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountOut,\n    uint256 maxAmountIn\n  ) external returns (uint256);\n\n/* ========== Views ========== */\n\n  function getPremiumPercent() external view returns (uint8);\n\n  function calcInGivenOut(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountOut\n  ) external view returns (uint256);\n\n  function calcOutGivenIn(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountIn\n  ) external view returns (uint256);\n}"
    },
    "temp-contracts/lib/Babylonian.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.0;\n\n\n/************************************************************************************************\nOriginally from https://github.com/Uniswap/uniswap-lib/blob/master/contracts/libraries/Babylonian.sol\n\nThis source code has been modified from the original, which was copied from the github repository\nat commit hash 9642a0705fdaf36b477354a4167a8cd765250860.\n\nSubject to the GPL-3.0 license\n*************************************************************************************************/\n\n\n// computes square roots using the babylonian method\n// https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\nlibrary Babylonian {\n  function sqrt(uint y) internal pure returns (uint z) {\n    if (y > 3) {\n      z = y;\n      uint x = (y + 1) / 2;\n      while (x < z) {\n        z = x;\n        x = (y / x + x) / 2;\n      }\n    } else if (y != 0) {\n      z = 1;\n    }\n    // else z = 0\n  }\n}\n"
    },
    "temp-contracts/lib/MCapSqrtLibrary.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\n/* ========== External Interfaces ========== */\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/* ========== External Libraries ========== */\nimport \"@indexed-finance/uniswap-v2-oracle/contracts/lib/PriceLibrary.sol\";\nimport \"@indexed-finance/uniswap-v2-oracle/contracts/lib/FixedPoint.sol\";\n\n/* ========== Internal Libraries ========== */\nimport \"./Babylonian.sol\";\n\n\nlibrary MCapSqrtLibrary {\n  using Babylonian for uint256;\n  using FixedPoint for FixedPoint.uq112x112;\n  using FixedPoint for FixedPoint.uq144x112;\n  using PriceLibrary for PriceLibrary.TwoWayAveragePrice;\n\n  /**\n   * @dev Compute the average market cap of a token by extrapolating the\n   * average price to the token's total supply.\n   * @param token Address of the ERC20 token\n   * @param averagePrice Two-way average price of the token (token-weth & weth-token).\n   * @return Extrapolated average market cap.\n   */\n  function computeAverageMarketCap(\n    address token,\n    PriceLibrary.TwoWayAveragePrice memory averagePrice\n  ) internal view returns (uint144) {\n    uint256 totalSupply = IERC20(token).totalSupply();\n    return averagePrice.computeAverageEthForTokens(totalSupply);\n  }\n\n  /**\n   * @dev Calculate the square roots of the market caps of the indexed tokens.\n   * @param tokens Array of ERC20 tokens to get the market cap square roots for.\n   * @param averagePrices Array of two-way average prices of each token.\n   *  - Must be in the same order as the tokens array.\n   * @return sqrts Array of market cap square roots for the provided tokens.\n   */\n  function computeMarketCapSqrts(\n    address[] memory tokens,\n    PriceLibrary.TwoWayAveragePrice[] memory averagePrices\n  ) internal view returns (uint112[] memory sqrts) {\n    uint256 len = tokens.length;\n    sqrts = new uint112[](len);\n    for (uint256 i = 0; i < len; i++) {\n      uint256 marketCap = computeAverageMarketCap(tokens[i], averagePrices[i]);\n      sqrts[i] = uint112(marketCap.sqrt());\n    }\n  }\n\n    /**\n   * @dev Calculate the weights of the provided tokens.\n   * The weight of a token is the square root of its market cap\n   * divided by the sum of market cap square roots.\n   * @param tokens Array of ERC20 tokens to weigh\n   * @param averagePrices Array of average prices from UniSwap for the tokens array.\n   * @return weights Array of token weights represented as fractions of the sum of roots.\n   */\n  function computeTokenWeights(\n    address[] memory tokens,\n    PriceLibrary.TwoWayAveragePrice[] memory averagePrices\n  ) internal view returns (FixedPoint.uq112x112[] memory weights) {\n    // Get the square roots of token market caps\n    uint112[] memory sqrts = computeMarketCapSqrts(tokens, averagePrices);\n    uint112 rootSum;\n    uint256 len = sqrts.length;\n    // Calculate the sum of square roots\n    // Will not overflow - would need 72057594037927940 tokens in the index\n    // before the sum of sqrts of a uint112 could overflow\n    for (uint256 i = 0; i < len; i++) rootSum += sqrts[i];\n    // Initialize the array of weights\n    weights = new FixedPoint.uq112x112[](len);\n    // Calculate the token weights as fractions of the root sum.\n    for (uint256 i = 0; i < len; i++) {\n      weights[i] = FixedPoint.fraction(sqrts[i], rootSum);\n    }\n  }\n\n  /**\n   * @dev Computes the weighted balance of a token relative to the\n   * total value of the index. Multiplies the total value by the weight,\n   * then multiplies by the reciprocal of the price (equivalent to dividing\n   * by price, but without rounding the price).\n   * @param totalValue Total value of the index in the stablecoin\n   * @param weight Fraction of the total value that should be held in the token.\n   * @param averagePrice Two-way average price of the token.\n   * @return weightedBalance Desired balance of the token based on the weighted value.\n   */\n  function computeWeightedBalance(\n    uint144 totalValue,\n    FixedPoint.uq112x112 memory weight,\n    PriceLibrary.TwoWayAveragePrice memory averagePrice\n  ) internal pure returns (uint144 weightedBalance) {\n    uint144 desiredWethValue = weight.mul(totalValue).decode144();\n    // Multiply by reciprocal to avoid rounding in intermediary steps.\n    return averagePrice.computeAverageTokensForEth(desiredWethValue);\n  }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@indexed-finance/uniswap-v2-oracle/contracts/lib/PriceLibrary.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\n/* ==========  Internal Libraries  ========== */\nimport \"./FixedPoint.sol\";\nimport \"./UniswapV2OracleLibrary.sol\";\nimport \"./UniswapV2Library.sol\";\n\n\nlibrary PriceLibrary {\n  using FixedPoint for FixedPoint.uq112x112;\n  using FixedPoint for FixedPoint.uq144x112;\n\n/* ========= Structs ========= */\n\n  struct PriceObservation {\n    uint32 timestamp;\n    uint224 priceCumulativeLast;\n    uint224 ethPriceCumulativeLast;\n  }\n\n  /**\n   * @dev Average prices for a token in terms of weth and weth in terms of the token.\n   *\n   * Note: The average weth price is not equivalent to the reciprocal of the average\n   * token price. See the UniSwap whitepaper for more info.\n   */\n  struct TwoWayAveragePrice {\n    uint224 priceAverage;\n    uint224 ethPriceAverage;\n  }\n\n/* ========= View Functions ========= */\n\n  function pairInitialized(\n    address uniswapFactory,\n    address token,\n    address weth\n  )\n    internal\n    view\n    returns (bool)\n  {\n    address pair = UniswapV2Library.pairFor(uniswapFactory, token, weth);\n    (uint112 reserve0, uint112 reserve1,) = IUniswapV2Pair(pair).getReserves();\n    return reserve0 != 0 && reserve1 != 0;\n  }\n\n  function observePrice(\n    address uniswapFactory,\n    address tokenIn,\n    address quoteToken\n  )\n    internal\n    view\n    returns (uint32 /* timestamp */, uint224 /* priceCumulativeLast */)\n  {\n    (address token0, address token1) = UniswapV2Library.sortTokens(tokenIn, quoteToken);\n    address pair = UniswapV2Library.calculatePair(uniswapFactory, token0, token1);\n    if (token0 == tokenIn) {\n      (uint256 price0Cumulative, uint32 blockTimestamp) = UniswapV2OracleLibrary.currentCumulativePrice0(pair);\n      return (blockTimestamp, uint224(price0Cumulative));\n    } else {\n      (uint256 price1Cumulative, uint32 blockTimestamp) = UniswapV2OracleLibrary.currentCumulativePrice1(pair);\n      return (blockTimestamp, uint224(price1Cumulative));\n    }\n  }\n\n  /**\n   * @dev Query the current cumulative price of a token in terms of weth\n   * and the current cumulative price of weth in terms of the token.\n   */\n  function observeTwoWayPrice(\n    address uniswapFactory,\n    address token,\n    address weth\n  ) internal view returns (PriceObservation memory) {\n    (address token0, address token1) = UniswapV2Library.sortTokens(token, weth);\n    address pair = UniswapV2Library.calculatePair(uniswapFactory, token0, token1);\n    // Get the sorted token prices\n    (\n      uint256 price0Cumulative,\n      uint256 price1Cumulative,\n      uint32 blockTimestamp\n    ) = UniswapV2OracleLibrary.currentCumulativePrices(pair);\n    // Check which token is weth and which is the token,\n    // then build the price observation.\n    if (token0 == token) {\n      return PriceObservation({\n        timestamp: blockTimestamp,\n        priceCumulativeLast: uint224(price0Cumulative),\n        ethPriceCumulativeLast: uint224(price1Cumulative)\n      });\n    } else {\n      return PriceObservation({\n        timestamp: blockTimestamp,\n        priceCumulativeLast: uint224(price1Cumulative),\n        ethPriceCumulativeLast: uint224(price0Cumulative)\n      });\n    }\n  }\n\n/* ========= Utility Functions ========= */\n\n  /**\n   * @dev Computes the average price of a token in terms of weth\n   * and the average price of weth in terms of a token using two\n   * price observations.\n   */\n  function computeTwoWayAveragePrice(\n    PriceObservation memory observation1,\n    PriceObservation memory observation2\n  ) internal pure returns (TwoWayAveragePrice memory) {\n    uint32 timeElapsed = uint32(observation2.timestamp - observation1.timestamp);\n    FixedPoint.uq112x112 memory priceAverage = UniswapV2OracleLibrary.computeAveragePrice(\n      observation1.priceCumulativeLast,\n      observation2.priceCumulativeLast,\n      timeElapsed\n    );\n    FixedPoint.uq112x112 memory ethPriceAverage = UniswapV2OracleLibrary.computeAveragePrice(\n      observation1.ethPriceCumulativeLast,\n      observation2.ethPriceCumulativeLast,\n      timeElapsed\n    );\n    return TwoWayAveragePrice({\n      priceAverage: priceAverage._x,\n      ethPriceAverage: ethPriceAverage._x\n    });\n  }\n\n  function computeAveragePrice(\n    uint32 timestampStart,\n    uint224 priceCumulativeStart,\n    uint32 timestampEnd,\n    uint224 priceCumulativeEnd\n  ) internal pure returns (FixedPoint.uq112x112 memory) {\n    return UniswapV2OracleLibrary.computeAveragePrice(\n      priceCumulativeStart,\n      priceCumulativeEnd,\n      uint32(timestampEnd - timestampStart)\n    );\n  }\n\n  /**\n   * @dev Computes the average price of the token the price observations\n   * are for in terms of weth.\n   */\n  function computeAverageTokenPrice(\n    PriceObservation memory observation1,\n    PriceObservation memory observation2\n  ) internal pure returns (FixedPoint.uq112x112 memory) {\n    return UniswapV2OracleLibrary.computeAveragePrice(\n      observation1.priceCumulativeLast,\n      observation2.priceCumulativeLast,\n      uint32(observation2.timestamp - observation1.timestamp)\n    );\n  }\n\n  /**\n   * @dev Computes the average price of weth in terms of the token\n   * the price observations are for.\n   */\n  function computeAverageEthPrice(\n    PriceObservation memory observation1,\n    PriceObservation memory observation2\n  ) internal pure returns (FixedPoint.uq112x112 memory) {\n    return UniswapV2OracleLibrary.computeAveragePrice(\n      observation1.ethPriceCumulativeLast,\n      observation2.ethPriceCumulativeLast,\n      uint32(observation2.timestamp - observation1.timestamp)\n    );\n  }\n\n  /**\n   * @dev Compute the average value in weth of `tokenAmount` of the\n   * token that the average price values are for.\n   */\n  function computeAverageEthForTokens(\n    TwoWayAveragePrice memory prices,\n    uint256 tokenAmount\n  ) internal pure returns (uint144) {\n    return FixedPoint.uq112x112(prices.priceAverage).mul(tokenAmount).decode144();\n  }\n\n  /**\n   * @dev Compute the average value of `wethAmount` weth in terms of\n   * the token that the average price values are for.\n   */\n  function computeAverageTokensForEth(\n    TwoWayAveragePrice memory prices,\n    uint256 wethAmount\n  ) internal pure returns (uint144) {\n    return FixedPoint.uq112x112(prices.ethPriceAverage).mul(wethAmount).decode144();\n  }\n}"
    },
    "@indexed-finance/uniswap-v2-oracle/contracts/lib/FixedPoint.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\n\n\n/************************************************************************************************\nFrom https://github.com/Uniswap/uniswap-lib/blob/master/contracts/libraries/FixedPoint.sol\n\nCopied from the github repository at commit hash 9642a0705fdaf36b477354a4167a8cd765250860.\n\nModifications:\n- Removed `sqrt` function\n\nSubject to the GPL-3.0 license\n*************************************************************************************************/\n\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\nlibrary FixedPoint {\n  // range: [0, 2**112 - 1]\n  // resolution: 1 / 2**112\n  struct uq112x112 {\n    uint224 _x;\n  }\n\n  // range: [0, 2**144 - 1]\n  // resolution: 1 / 2**112\n  struct uq144x112 {\n    uint _x;\n  }\n\n  uint8 private constant RESOLUTION = 112;\n  uint private constant Q112 = uint(1) << RESOLUTION;\n  uint private constant Q224 = Q112 << RESOLUTION;\n\n  // encode a uint112 as a UQ112x112\n  function encode(uint112 x) internal pure returns (uq112x112 memory) {\n    return uq112x112(uint224(x) << RESOLUTION);\n  }\n\n  // encodes a uint144 as a UQ144x112\n  function encode144(uint144 x) internal pure returns (uq144x112 memory) {\n    return uq144x112(uint256(x) << RESOLUTION);\n  }\n\n  // divide a UQ112x112 by a uint112, returning a UQ112x112\n  function div(uq112x112 memory self, uint112 x) internal pure returns (uq112x112 memory) {\n    require(x != 0, \"FixedPoint: DIV_BY_ZERO\");\n    return uq112x112(self._x / uint224(x));\n  }\n\n  // multiply a UQ112x112 by a uint, returning a UQ144x112\n  // reverts on overflow\n  function mul(uq112x112 memory self, uint y) internal pure returns (uq144x112 memory) {\n    uint z;\n    require(\n      y == 0 || (z = uint(self._x) * y) / y == uint(self._x),\n      \"FixedPoint: MULTIPLICATION_OVERFLOW\"\n    );\n    return uq144x112(z);\n  }\n\n  // returns a UQ112x112 which represents the ratio of the numerator to the denominator\n  // equivalent to encode(numerator).div(denominator)\n  function fraction(uint112 numerator, uint112 denominator) internal pure returns (uq112x112 memory) {\n    require(denominator > 0, \"FixedPoint: DIV_BY_ZERO\");\n    return uq112x112((uint224(numerator) << RESOLUTION) / denominator);\n  }\n\n  // decode a UQ112x112 into a uint112 by truncating after the radix point\n  function decode(uq112x112 memory self) internal pure returns (uint112) {\n    return uint112(self._x >> RESOLUTION);\n  }\n\n  // decode a UQ144x112 into a uint144 by truncating after the radix point\n  function decode144(uq144x112 memory self) internal pure returns (uint144) {\n    return uint144(self._x >> RESOLUTION);\n  }\n\n  // take the reciprocal of a UQ112x112\n  function reciprocal(uq112x112 memory self) internal pure returns (uq112x112 memory) {\n    require(self._x != 0, \"FixedPoint: ZERO_RECIPROCAL\");\n    return uq112x112(uint224(Q224 / self._x));\n  }\n}"
    },
    "@indexed-finance/uniswap-v2-oracle/contracts/lib/UniswapV2OracleLibrary.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\n\n/* ==========  Internal Interfaces  ========== */\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\n\n/* ==========  Internal Libraries  ========== */\nimport \"./FixedPoint.sol\";\n\n\n/************************************************************************************************\nOriginally from https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/libraries/UniswapV2OracleLibrary.sol\n\nThis source code has been modified from the original, which was copied from the github repository\nat commit hash 6d03bede0a97c72323fa1c379ed3fdf7231d0b26.\n\nSubject to the GPL-3.0 license\n*************************************************************************************************/\n\n\n// library with helper methods for oracles that are concerned with computing average prices\nlibrary UniswapV2OracleLibrary {\n  using FixedPoint for *;\n\n  // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\n  function currentBlockTimestamp() internal view returns (uint32) {\n    return uint32(block.timestamp % 2**32);\n  }\n\n  // produces the cumulative prices using counterfactuals to save gas and avoid a call to sync.\n  function currentCumulativePrices(address pair)\n    internal\n    view\n    returns (\n      uint256 price0Cumulative,\n      uint256 price1Cumulative,\n      uint32 blockTimestamp\n    )\n  {\n    blockTimestamp = currentBlockTimestamp();\n    price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\n    price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\n\n    // if time has elapsed since the last update on the pair, mock the accumulated price values\n    (\n      uint112 reserve0,\n      uint112 reserve1,\n      uint32 blockTimestampLast\n    ) = IUniswapV2Pair(pair).getReserves();\n    require(\n      reserve0 != 0 && reserve1 != 0,\n      \"UniswapV2OracleLibrary::currentCumulativePrices: Pair has no reserves.\"\n    );\n    if (blockTimestampLast != blockTimestamp) {\n      // subtraction overflow is desired\n      uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n      // addition overflow is desired\n      // counterfactual\n      price0Cumulative += (\n        uint256(FixedPoint.fraction(reserve1, reserve0)._x) *\n        timeElapsed\n      );\n      // counterfactual\n      price1Cumulative += (\n        uint256(FixedPoint.fraction(reserve0, reserve1)._x) *\n        timeElapsed\n      );\n    }\n  }\n\n  // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\n  // only gets the first price\n  function currentCumulativePrice0(address pair)\n    internal\n    view\n    returns (uint256 price0Cumulative, uint32 blockTimestamp)\n  {\n    blockTimestamp = currentBlockTimestamp();\n    price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\n\n    // if time has elapsed since the last update on the pair, mock the accumulated price values\n    (\n      uint112 reserve0,\n      uint112 reserve1,\n      uint32 blockTimestampLast\n    ) = IUniswapV2Pair(pair).getReserves();\n    require(\n      reserve0 != 0 && reserve1 != 0,\n      \"UniswapV2OracleLibrary::currentCumulativePrice0: Pair has no reserves.\"\n    );\n    if (blockTimestampLast != blockTimestamp) {\n      // subtraction overflow is desired\n      uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n      // addition overflow is desired\n      // counterfactual\n      price0Cumulative += (\n        uint256(FixedPoint.fraction(reserve1, reserve0)._x) *\n        timeElapsed\n      );\n    }\n  }\n\n  // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\n  // only gets the second price\n  function currentCumulativePrice1(address pair)\n    internal\n    view\n    returns (uint256 price1Cumulative, uint32 blockTimestamp)\n  {\n    blockTimestamp = currentBlockTimestamp();\n    price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\n\n    // if time has elapsed since the last update on the pair, mock the accumulated price values\n    (\n      uint112 reserve0,\n      uint112 reserve1,\n      uint32 blockTimestampLast\n    ) = IUniswapV2Pair(pair).getReserves();\n    require(\n      reserve0 != 0 && reserve1 != 0,\n      \"UniswapV2OracleLibrary::currentCumulativePrice1: Pair has no reserves.\"\n    );\n    if (blockTimestampLast != blockTimestamp) {\n      // subtraction overflow is desired\n      uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n      // addition overflow is desired\n      // counterfactual\n      price1Cumulative += (\n        uint256(FixedPoint.fraction(reserve0, reserve1)._x) *\n        timeElapsed\n      );\n    }\n  }\n\n  function computeAveragePrice(\n    uint224 priceCumulativeStart,\n    uint224 priceCumulativeEnd,\n    uint32 timeElapsed\n  ) internal pure returns (FixedPoint.uq112x112 memory priceAverage) {\n    // overflow is desired.\n    priceAverage = FixedPoint.uq112x112(\n      uint224((priceCumulativeEnd - priceCumulativeStart) / timeElapsed)\n    );\n  }\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "@indexed-finance/uniswap-v2-oracle/contracts/lib/UniswapV2Library.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\n\n/************************************************************************************************\nOriginally from https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/libraries/UniswapV2Library.sol\n\nThis source code has been modified from the original, which was copied from the github repository\nat commit hash 87edfdcaf49ccc52591502993db4c8c08ea9eec0.\n\nSubject to the GPL-3.0 license\n*************************************************************************************************/\n\n\nlibrary UniswapV2Library {\n  // returns sorted token addresses, used to handle return values from pairs sorted in this order\n  function sortTokens(address tokenA, address tokenB)\n    internal\n    pure\n    returns (address token0, address token1)\n  {\n    require(tokenA != tokenB, \"UniswapV2Library: IDENTICAL_ADDRESSES\");\n    (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n    require(token0 != address(0), \"UniswapV2Library: ZERO_ADDRESS\");\n  }\n\n  function calculatePair(\n    address factory,\n    address token0,\n    address token1\n  ) internal pure returns (address pair) {\n    pair = address(\n      uint256(\n        keccak256(\n          abi.encodePacked(\n            hex\"ff\",\n            factory,\n            keccak256(abi.encodePacked(token0, token1)),\n            hex\"96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f\" // init code hash\n          )\n        )\n      )\n    );\n  }\n\n  // calculates the CREATE2 address for a pair without making any external calls\n  function pairFor(\n    address factory,\n    address tokenA,\n    address tokenB\n  ) internal pure returns (address pair) {\n    (address token0, address token1) = sortTokens(tokenA, tokenB);\n    pair = calculatePair(factory, token0, token1);\n  }\n}\n"
    },
    "temp-contracts/MarketCapSortedTokenCategories.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\n/* ========== External Interfaces ========== */\nimport \"@indexed-finance/uniswap-v2-oracle/contracts/interfaces/IIndexedUniswapV2Oracle.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/* ========== Internal Inheritance ========== */\nimport \"./OwnableProxy.sol\";\n\n\n/**\n * @title MarketCapSortedCategories\n * @author d1ll0n\n *\n * @dev This contract stores token categories created by the contract owner.\n * Token categories are sorted by their fully diluted market caps, which is\n * extrapolated by multiplying each token's total supply by its moving\n * average weth price on UniSwap.\n *\n * Categories are periodically sorted, ranking their tokens in descending order by\n * market cap.\n *\n * CRITERIA\n * ===============\n * To be added to a category, a token should meet the following requirements in addition\n * to any other criteria for the particular category:\n *\n * 1. The token is at least a week old.\n * 2. The token complies with the ERC20 standard (boolean return values not required)\n * 3. No major vulnerabilities have been discovered in the token contract.\n * 4. The token does not have a deflationary supply model.\n * 5. The token's supply can not be arbitrarily inflated or deflated maliciously.\n * 5.a. The control model should be considered if the supply can be modified arbitrarily.\n * ===============\n */\ncontract MarketCapSortedTokenCategories is OwnableProxy {\n/* ==========  Constants  ========== */\n\n  // TWAP parameters for capturing long-term price trends\n  uint32 internal constant LONG_TWAP_MIN_TIME_ELAPSED = 0;\n  uint32 internal constant LONG_TWAP_MAX_TIME_ELAPSED = 7 days;\n\n  // TWAP parameters for assessing current price\n  uint32 internal constant SHORT_TWAP_MIN_TIME_ELAPSED = 0;\n  uint32 internal constant SHORT_TWAP_MAX_TIME_ELAPSED = 7 days;\n\n  // Maximum time between a category being sorted and a query for the top n tokens\n  uint256 internal constant MAX_SORT_DELAY = 1 days;\n\n  // Maximum number of tokens in a category\n  uint256 internal constant MAX_CATEGORY_TOKENS = 25;\n\n  // Long term price oracle\n  IIndexedUniswapV2Oracle public immutable oracle;\n\n/* ==========  Events  ========== */\n\n  /** @dev Emitted when a new category is created. */\n  event CategoryAdded(uint256 categoryID, bytes32 metadataHash);\n\n  /** @dev Emitted when a category is sorted. */\n  event CategorySorted(uint256 categoryID);\n\n  /** @dev Emitted when a token is added to a category. */\n  event TokenAdded(address token, uint256 categoryID);\n\n/* ==========  Storage  ========== */\n\n  // Number of categories that exist.\n  uint256 public categoryIndex;\n  // Array of tokens for each category.\n  mapping(uint256 => address[]) internal _categoryTokens;\n  mapping(uint256 => mapping(address => bool)) internal _isCategoryToken;\n  // Last time a category was sorted\n  mapping(uint256 => uint256) internal _lastCategoryUpdate;\n\n/* ========== Modifiers ========== */\n\n  modifier validCategory(uint256 categoryID) {\n    require(categoryID <= categoryIndex && categoryID > 0, \"ERR_CATEGORY_ID\");\n    _;\n  }\n\n/* ==========  Constructor  ========== */\n\n  /**\n   * @dev Deploy the controller and configure the addresses\n   * of the related contracts.\n   */\n  constructor(IIndexedUniswapV2Oracle _oracle) public OwnableProxy() {\n    oracle = _oracle;\n  }\n\n/* ==========  Initializer  ========== */\n\n  /**\n   * @dev Initialize the categories with the owner address.\n   * This sets up the contract which is deployed as a singleton proxy.\n   */\n  function initialize() public virtual {\n    _initializeOwnership();\n  }\n\n/* ==========  Category Management  ========== */\n\n  /**\n   * @dev Updates the prices on the oracle for all the tokens in a category.\n   */\n  function updateCategoryPrices(uint256 categoryID) external validCategory(categoryID) returns (bool[] memory pricesUpdated) {\n    address[] memory tokens = _categoryTokens[categoryID];\n    pricesUpdated = oracle.updatePrices(tokens);\n  }\n\n  /**\n   * @dev Creates a new token category.\n   * @param metadataHash Hash of metadata about the token category\n   * which can be distributed on IPFS.\n   */\n  function createCategory(bytes32 metadataHash) external onlyOwner {\n    uint256 categoryID = ++categoryIndex;\n    emit CategoryAdded(categoryID, metadataHash);\n  }\n\n  /**\n   * @dev Adds a new token to a category.\n   *\n   * @param categoryID Category identifier.\n   * @param token Token to add to the category.\n   */\n  function addToken(uint256 categoryID, address token) external onlyOwner validCategory(categoryID) {\n    require(\n      _categoryTokens[categoryID].length < MAX_CATEGORY_TOKENS,\n      \"ERR_MAX_CATEGORY_TOKENS\"\n    );\n    _addToken(categoryID, token);\n    oracle.updatePrice(token);\n    // Decrement the timestamp for the last category update to ensure\n    // that the new token is sorted before the category's top tokens\n    // can be queried.\n    _lastCategoryUpdate[categoryID] -= MAX_SORT_DELAY;\n  }\n\n  /**\n   * @dev Add tokens to a category.\n   * @param categoryID Category identifier.\n   * @param tokens Array of tokens to add to the category.\n   */\n  function addTokens(uint256 categoryID, address[] calldata tokens)\n    external\n    onlyOwner\n    validCategory(categoryID)\n  {\n    require(\n      _categoryTokens[categoryID].length + tokens.length <= MAX_CATEGORY_TOKENS,\n      \"ERR_MAX_CATEGORY_TOKENS\"\n    );\n    for (uint256 i = 0; i < tokens.length; i++) {\n      _addToken(categoryID, tokens[i]);\n    }\n    oracle.updatePrices(tokens);\n    // Decrement the timestamp for the last category update to ensure\n    // that the new tokens are sorted before the category's top tokens\n    // can be queried.\n    _lastCategoryUpdate[categoryID] -= MAX_SORT_DELAY;\n  }\n\n  /**\n   * @dev Remove token from a category.\n   * @param categoryID Category identifier.\n   * @param token Token to remove from the category.\n   */\n  function removeToken(uint256 categoryID, address token) external onlyOwner validCategory(categoryID) {\n    uint256 i = 0;\n    uint256 len = _categoryTokens[categoryID].length;\n    require(len > 0, \"ERR_EMPTY_CATEGORY\");\n    require(_isCategoryToken[categoryID][token], \"ERR_TOKEN_NOT_BOUND\");\n    _isCategoryToken[categoryID][token] = false;\n    for (; i < len; i++) {\n      if (_categoryTokens[categoryID][i] == token) {\n        uint256 last = len - 1;\n        if (i != last) {\n          address lastToken = _categoryTokens[categoryID][last];\n          _categoryTokens[categoryID][i] = lastToken;\n        }\n        _lastCategoryUpdate[categoryID] -= MAX_SORT_DELAY;\n        _categoryTokens[categoryID].pop();\n        return;\n      }\n    }\n    // This will never occur.\n    revert(\"ERR_NOT_FOUND\");\n  }\n\n  /**\n   * @dev Sorts a category's tokens in descending order by market cap.\n   * Note: Uses in-memory insertion sort.\n   *\n   * @param categoryID Category to sort\n   */\n  function orderCategoryTokensByMarketCap(uint256 categoryID) external validCategory(categoryID) {\n    address[] memory categoryTokens = _categoryTokens[categoryID];\n    uint256 len = categoryTokens.length;\n    uint144[] memory marketCaps = computeAverageMarketCaps(categoryTokens);\n    for (uint256 i = 1; i < len; i++) {\n      uint144 cap = marketCaps[i];\n      address token = categoryTokens[i];\n      uint256 j = i - 1;\n      while (int(j) >= 0 && marketCaps[j] < cap) {\n        marketCaps[j + 1] = marketCaps[j];\n        categoryTokens[j + 1] = categoryTokens[j];\n        j--;\n      }\n      marketCaps[j + 1] = cap;\n      categoryTokens[j + 1] = token;\n    }\n    _categoryTokens[categoryID] = categoryTokens;\n    \n    _lastCategoryUpdate[categoryID] = now;\n    emit CategorySorted(categoryID);\n  }\n\n/* ==========  Market Cap Queries  ========== */\n\n  /**\n   * @dev Compute the average market cap of a token in weth.\n   * Queries the average amount of ether that the total supply is worth\n   * using the recent moving average price.\n   */\n  function computeAverageMarketCap(address token)\n    public\n    view\n    returns (uint144)\n  {\n    uint256 totalSupply = IERC20(token).totalSupply();\n    return oracle.computeAverageEthForTokens(\n      token,\n      totalSupply,\n      LONG_TWAP_MIN_TIME_ELAPSED,\n      LONG_TWAP_MAX_TIME_ELAPSED\n    ); \n  }\n\n  /**\n   * @dev Returns the average market cap for each token.\n   */\n  function computeAverageMarketCaps(address[] memory tokens)\n    public\n    view\n    returns (uint144[] memory marketCaps)\n  {\n    uint256 len = tokens.length;\n    uint256[] memory totalSupplies = new uint256[](len);\n    for (uint256 i = 0; i < len; i++) {\n      totalSupplies[i] = IERC20(tokens[i]).totalSupply();\n    }\n    marketCaps = oracle.computeAverageEthForTokens(\n      tokens,\n      totalSupplies,\n      LONG_TWAP_MIN_TIME_ELAPSED,\n      LONG_TWAP_MAX_TIME_ELAPSED\n    );\n  }\n\n/* ==========  Category Queries  ========== */\n\n  /**\n   * @dev Returns a boolean stating whether a category exists.\n   */\n  function hasCategory(uint256 categoryID) external view returns (bool) {\n    return categoryID <= categoryIndex && categoryID > 0;\n  }\n\n  /**\n   * @dev Returns the timestamp of the last time the category was sorted.\n   */\n  function getLastCategoryUpdate(uint256 categoryID)\n    external\n    view\n    validCategory(categoryID)\n    returns (uint256)\n  {\n    return _lastCategoryUpdate[categoryID];\n  }\n\n  /**\n   * @dev Returns boolean stating whether `token` is a member of the category `categoryID`.\n   */\n  function isTokenInCategory(uint256 categoryID, address token)\n    external\n    view\n    validCategory(categoryID)\n    returns (bool)\n  {\n    return _isCategoryToken[categoryID][token];\n  }\n\n  /**\n   * @dev Returns the array of tokens in a category.\n   */\n  function getCategoryTokens(uint256 categoryID)\n    external\n    view\n    validCategory(categoryID)\n    returns (address[] memory tokens)\n  {\n    address[] storage _tokens = _categoryTokens[categoryID];\n    tokens = new address[](_tokens.length);\n    for (uint256 i = 0; i < tokens.length; i++) {\n      tokens[i] = _tokens[i];\n    }\n  }\n\n  /**\n   * @dev Returns the fully diluted market caps for the tokens in a category.\n   */\n  function getCategoryMarketCaps(uint256 categoryID)\n    external\n    view\n    validCategory(categoryID)\n    returns (uint144[] memory marketCaps)\n  {\n    return computeAverageMarketCaps(_categoryTokens[categoryID]);\n  }\n\n  /**\n   * @dev Get the top `num` tokens in a category.\n   *\n   * Note: The category must have been sorted by market cap\n   * in the last `MAX_SORT_DELAY` seconds.\n   */\n  function getTopCategoryTokens(uint256 categoryID, uint256 num)\n    public\n    view\n    validCategory(categoryID)\n    returns (address[] memory tokens)\n  {\n    address[] storage categoryTokens = _categoryTokens[categoryID];\n    require(num <= categoryTokens.length, \"ERR_CATEGORY_SIZE\");\n    require(\n      now - _lastCategoryUpdate[categoryID] <= MAX_SORT_DELAY,\n      \"ERR_CATEGORY_NOT_READY\"\n    );\n    tokens = new address[](num);\n    for (uint256 i = 0; i < num; i++) tokens[i] = categoryTokens[i];\n  }\n\n/* ==========  Category Utility Functions  ========== */\n\n  /**\n   * @dev Adds a new token to a category.\n   */\n  function _addToken(uint256 categoryID, address token) internal {\n    require(!_isCategoryToken[categoryID][token], \"ERR_TOKEN_BOUND\");\n    _isCategoryToken[categoryID][token] = true;\n    _categoryTokens[categoryID].push(token);\n    emit TokenAdded(token, categoryID);\n  }\n}"
    },
    "@indexed-finance/uniswap-v2-oracle/contracts/interfaces/IIndexedUniswapV2Oracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\n/* ==========  Libraries  ========== */\nimport \"../lib/PriceLibrary.sol\";\nimport \"../lib/FixedPoint.sol\";\n\n\ninterface IIndexedUniswapV2Oracle {\n/* ==========  Mutative Functions  ========== */\n\n  function updatePrice(address token) external returns (bool);\n\n  function updatePrices(address[] calldata tokens) external returns (bool[] memory);\n\n/* ==========  Meta Price Queries  ========== */\n\n  function hasPriceObservationInWindow(address token, uint256 priceKey) external view returns (bool);\n\n  function getPriceObservationInWindow(\n    address token, uint256 priceKey\n  ) external view returns (PriceLibrary.PriceObservation memory);\n\n  function getPriceObservationsInRange(\n    address token, uint256 timeFrom, uint256 timeTo\n  ) external view returns (PriceLibrary.PriceObservation[] memory prices);\n\n/* ==========  Price Update Queries  ========== */\n\n  function canUpdatePrice(address token) external view returns (bool);\n\n  function canUpdatePrices(address[] calldata tokens) external view returns (bool[] memory);\n\n/* ==========  Price Queries: Singular  ========== */\n\n  function computeTwoWayAveragePrice(\n    address token, uint256 minTimeElapsed, uint256 maxTimeElapsed\n  ) external view returns (PriceLibrary.TwoWayAveragePrice memory);\n\n  function computeAverageTokenPrice(\n    address token, uint256 minTimeElapsed, uint256 maxTimeElapsed\n  ) external view returns (FixedPoint.uq112x112 memory);\n\n  function computeAverageEthPrice(\n    address token, uint256 minTimeElapsed, uint256 maxTimeElapsed\n  ) external view returns (FixedPoint.uq112x112 memory);\n\n/* ==========  Price Queries: Multiple  ========== */\n\n  function computeTwoWayAveragePrices(\n    address[] calldata tokens,\n    uint256 minTimeElapsed,\n    uint256 maxTimeElapsed\n  ) external view returns (PriceLibrary.TwoWayAveragePrice[] memory);\n\n  function computeAverageTokenPrices(\n    address[] calldata tokens,\n    uint256 minTimeElapsed,\n    uint256 maxTimeElapsed\n  ) external view returns (FixedPoint.uq112x112[] memory);\n\n  function computeAverageEthPrices(\n    address[] calldata tokens,\n    uint256 minTimeElapsed,\n    uint256 maxTimeElapsed\n  ) external view returns (FixedPoint.uq112x112[] memory);\n\n/* ==========  Value Queries: Singular  ========== */\n\n  function computeAverageEthForTokens(\n    address token,\n    uint256 tokenAmount,\n    uint256 minTimeElapsed,\n    uint256 maxTimeElapsed\n  ) external view returns (uint144);\n\n  function computeAverageTokensForEth(\n    address token,\n    uint256 wethAmount,\n    uint256 minTimeElapsed,\n    uint256 maxTimeElapsed\n  ) external view returns (uint144);\n\n/* ==========  Value Queries: Multiple  ========== */\n\n  function computeAverageEthForTokens(\n    address[] calldata tokens,\n    uint256[] calldata tokenAmounts,\n    uint256 minTimeElapsed,\n    uint256 maxTimeElapsed\n  ) external view returns (uint144[] memory);\n\n  function computeAverageTokensForEth(\n    address[] calldata tokens,\n    uint256[] calldata wethAmounts,\n    uint256 minTimeElapsed,\n    uint256 maxTimeElapsed\n  ) external view returns (uint144[] memory);\n}"
    },
    "temp-contracts/OwnableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/GSN/Context.sol\";\n\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This is a modified implementation of OpenZeppelin's Ownable.sol.\n * The modifications allow the contract to be inherited by a proxy's logic contract.\n * Any owner-only functions on the base implementation will be unusable.\n *\n * By default, the owner account will be a null address which can be set by the\n * first call to {initializeOwner}. This can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner. It also makes the function {initializeOwner} available to be used\n * in the initialization function for the inherited contract.\n *\n * Note: This contract should only be inherited by proxy implementation contracts\n * where the implementation will only ever be used as the logic address for proxies.\n * The constructor permanently locks the owner of the implementation contract, but the\n * owner of the proxies can be configured by the first caller.\n */\ncontract OwnableProxy is Context {\n  address private _owner;\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  constructor() public {\n    _owner = address(1);\n    emit OwnershipTransferred(address(0), address(1));\n  }\n\n  /**\n   * @dev Returns the address of the current owner.\n   */\n  function owner() public view returns (address) {\n    return _owner;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n    _;\n  }\n\n  /**\n   * @dev Leaves the contract without owner. It will not be possible to call\n   * `onlyOwner` functions anymore. Can only be called by the current owner.\n   *\n   * NOTE: Renouncing ownership will leave the contract without an owner,\n   * thereby removing any functionality that is only available to the owner.\n   */\n  function renounceOwnership() public virtual onlyOwner {\n    // Modified from OZ contract - sets owner to address(1) to prevent\n    // _initializeOwnership from being called after ownership is revoked.\n    emit OwnershipTransferred(_owner, address(1));\n    _owner = address(1);\n  }\n\n  /**\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\n   * Can only be called by the current owner.\n   */\n  function transferOwnership(address newOwner) public virtual onlyOwner {\n    require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n    emit OwnershipTransferred(_owner, newOwner);\n    _owner = newOwner;\n  }\n\n  /**\n   * @dev Initializes the contract setting the initializer as the initial owner.\n   * Note: Owner address must be zero.\n   */\n  function _initializeOwnership() internal {\n    require(_owner == address(0), \"Ownable: owner has already been initialized\");\n    address msgSender = _msgSender();\n    _owner = msgSender;\n    emit OwnershipTransferred(address(0), msgSender);\n  }\n\n  /**\n   * @dev Initializes the contract setting the owner to an invalid address.\n   * This ensures that the contract can never be owned, and should only be used\n   * in the constructor of a proxy's implementation contract.\n   * Note: Owner address must be zero.\n   */\n  function _lockImplementationOwner() internal {\n    require(_owner == address(0), \"Ownable: owner has already been initialized\");\n    emit OwnershipTransferred(address(0), address(1));\n    _owner = address(1);\n  }\n}\n"
    },
    "@openzeppelin/contracts/GSN/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "temp-contracts/MarketCapSqrtController.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\n/* ========== External Interfaces ========== */\nimport \"@indexed-finance/uniswap-v2-oracle/contracts/interfaces/IIndexedUniswapV2Oracle.sol\";\nimport \"@indexed-finance/proxies/contracts/interfaces/IDelegateCallProxyManager.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/* ========== External Libraries ========== */\nimport \"@indexed-finance/uniswap-v2-oracle/contracts/lib/PriceLibrary.sol\";\nimport \"@indexed-finance/uniswap-v2-oracle/contracts/lib/FixedPoint.sol\";\nimport \"@indexed-finance/proxies/contracts/SaltyLib.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n/* ========== Internal Interfaces ========== */\nimport \"./interfaces/IIndexPool.sol\";\nimport \"./interfaces/IPoolFactory.sol\";\nimport \"./interfaces/IPoolInitializer.sol\";\nimport \"./interfaces/IUnboundTokenSeller.sol\";\n\n/* ========== Internal Libraries ========== */\nimport \"./lib/MCapSqrtLibrary.sol\";\n\n/* ========== Internal Inheritance ========== */\nimport \"./MarketCapSortedTokenCategories.sol\";\n\n\n/**\n * @title MarketCapSqrtController\n * @author d1ll0n\n * @dev This contract implements the market cap square root index management strategy.\n *\n * Index pools have a defined size which is used to select the top tokens from the pool's\n * category.\n *\n * REBALANCING\n * ===============\n * Every 1 weeks, pools are either re-weighed or re-indexed.\n * They are re-indexed once for every three re-weighs.\n *\n * Re-indexing involves selecting the top tokens from the pool's category and weighing them\n * by the square root of their market caps.\n * Re-weighing involves weighing the tokens which are already indexed by the pool by the\n * square root of their market caps.\n * When a pool is re-weighed, only the tokens with a desired weight above 0 are included.\n * ===============\n */\ncontract MarketCapSqrtController is MarketCapSortedTokenCategories {\n  using FixedPoint for FixedPoint.uq112x112;\n  using FixedPoint for FixedPoint.uq144x112;\n  using SafeMath for uint256;\n  using PriceLibrary for PriceLibrary.TwoWayAveragePrice;\n\n/* ==========  Constants  ========== */\n  // Minimum number of tokens in an index.\n  uint256 internal constant MIN_INDEX_SIZE = 2;\n\n  // Maximum number of tokens in an index.\n  uint256 internal constant MAX_INDEX_SIZE = 10;\n\n  // Identifier for the pool initializer implementation on the proxy manager.\n  bytes32 internal constant INITIALIZER_IMPLEMENTATION_ID = keccak256(\"PoolInitializer.sol\");\n\n  // Identifier for the unbound token seller implementation on the proxy manager.\n  bytes32 internal constant SELLER_IMPLEMENTATION_ID = keccak256(\"UnboundTokenSeller.sol\");\n\n  // Identifier for the index pool implementation on the proxy manager.\n  bytes32 internal constant POOL_IMPLEMENTATION_ID = keccak256(\"IndexPool.sol\");\n\n  // Default total weight for a pool.\n  uint256 internal constant WEIGHT_MULTIPLIER = 25e18;\n\n  // Time between reweigh/reindex calls.\n  uint256 internal constant POOL_REWEIGH_DELAY = 1 minutes;\n\n  // The number of reweighs which occur before a pool is re-indexed.\n  uint256 internal constant REWEIGHS_BEFORE_REINDEX = 3;\n\n  // Pool factory contract\n  IPoolFactory internal immutable _factory;\n\n  // Proxy manager & factory\n  IDelegateCallProxyManager internal immutable _proxyManager;\n\n/* ==========  Events  ========== */\n\n  /** @dev Emitted when a pool is initialized and made public. */\n  event PoolInitialized(\n    address pool,\n    address unboundTokenSeller,\n    uint256 categoryID,\n    uint256 indexSize\n  );\n\n  /** @dev Emitted when a pool and its initializer are deployed. */\n  event NewPoolInitializer(\n    address pool,\n    address initializer,\n    uint256 categoryID,\n    uint256 indexSize\n  );\n\n/* ==========  Structs  ========== */\n\n  /**\n   * @dev Data structure with metadata about an index pool.\n   *\n   * Includes the number of times a pool has been either reweighed\n   * or re-indexed, as well as the timestamp of the last such action.\n   *\n   * To reweigh or re-index, the last update must have occurred at\n   * least `POOL_REWEIGH_DELAY` seconds ago.\n   *\n   * If `++index % REWEIGHS_BEFORE_REINDEX + 1` is 0, the pool will\n   * re-index, otherwise it will reweigh.\n   *\n   * The struct fields are assigned their respective integer sizes so\n   * that solc can pack the entire struct into a single storage slot.\n   * `reweighIndex` is intended to overflow, `categoryID` will never\n   * reach 2**16, `indexSize` is capped at 10 and it is unlikely that\n   * this protocol will be in use in the year 292277026596 (unix time\n   * for 2**64 - 1).\n   *\n   * @param initialized Whether the pool has been initialized with the\n   * starting balances.\n   * @param categoryID Category identifier for the pool.\n   * @param indexSize Number of tokens the pool should hold.\n   * @param reweighIndex Number of times the pool has either re-weighed\n   * or re-indexed.\n   * @param lastReweigh Timestamp of last pool re-weigh or re-index.\n   */\n  struct IndexPoolMeta {\n    bool initialized;\n    uint16 categoryID;\n    uint8 indexSize;\n    uint8 reweighIndex;\n    uint64 lastReweigh;\n  }\n\n/* ==========  Storage  ========== */\n\n  // Default slippage rate for token seller contracts.\n  uint8 public defaultSellerPremium;\n\n  // Metadata about index pools\n  mapping(address => IndexPoolMeta) internal _poolMeta;\n\n/* ========== Modifiers ========== */\n\n  modifier _havePool(address pool) {\n    require(_poolMeta[pool].initialized, \"ERR_POOL_NOT_FOUND\");\n    _;\n  }\n\n/* ==========  Constructor  ========== */\n\n  /**\n   * @dev Deploy the controller and configure the addresses\n   * of the related contracts.\n   */\n  constructor(\n    IIndexedUniswapV2Oracle oracle,\n    IPoolFactory factory,\n    IDelegateCallProxyManager proxyManager\n  )\n    public\n    MarketCapSortedTokenCategories(oracle)\n  {\n    _factory = factory;\n    _proxyManager = proxyManager;\n  }\n\n/* ==========  Initializer  ========== */\n\n  /**\n   * @dev Initialize the controller with the owner address and default seller premium.\n   * This sets up the controller which is deployed as a singleton proxy.\n   */\n  function initialize() public override {\n    defaultSellerPremium = 2;\n    super.initialize();\n  }\n\n/* ==========  Pool Deployment  ========== */\n\n  /**\n   * @dev Deploys an index pool and a pool initializer.\n   * The initializer contract is a pool with specific token\n   * balance targets which gives pool tokens in the finished\n   * pool to users who provide the underlying tokens needed\n   * to initialize it.\n   */\n  function prepareIndexPool(\n    uint256 categoryID,\n    uint256 indexSize,\n    uint256 initialWethValue,\n    string calldata name,\n    string calldata symbol\n  )\n    external\n    onlyOwner\n    returns (address poolAddress, address initializerAddress)\n  {\n    require(indexSize >= MIN_INDEX_SIZE, \"ERR_MIN_INDEX_SIZE\");\n    require(indexSize <= MAX_INDEX_SIZE, \"ERR_MAX_INDEX_SIZE\");\n    require(initialWethValue < uint144(-1), \"ERR_MAX_UINT144\");\n\n    poolAddress = _factory.deployPool(\n      POOL_IMPLEMENTATION_ID,\n      keccak256(abi.encodePacked(categoryID, indexSize))\n    );\n    IIndexPool(poolAddress).configure(address(this), name, symbol);\n\n    _poolMeta[poolAddress] = IndexPoolMeta({\n      initialized: false,\n      categoryID: uint16(categoryID),\n      indexSize: uint8(indexSize),\n      lastReweigh: 0,\n      reweighIndex: 0\n    });\n\n    initializerAddress = _proxyManager.deployProxyManyToOne(\n      INITIALIZER_IMPLEMENTATION_ID,\n      keccak256(abi.encodePacked(poolAddress))\n    );\n\n    IPoolInitializer initializer = IPoolInitializer(initializerAddress);\n\n    // Get the initial tokens and balances for the pool.\n    (\n      address[] memory tokens,\n      uint256[] memory balances\n    ) = getInitialTokensAndBalances(categoryID, indexSize, uint144(initialWethValue));\n\n    initializer.initialize(poolAddress, tokens, balances);\n\n    emit NewPoolInitializer(\n      poolAddress,\n      initializerAddress,\n      categoryID,\n      indexSize\n    );\n  }\n\n  /**\n   * @dev Initializes a pool which has been deployed but not initialized\n   * and transfers the underlying tokens from the initialization pool to\n   * the actual pool.\n   */\n  function finishPreparedIndexPool(\n    address poolAddress,\n    address[] calldata tokens,\n    uint256[] calldata balances\n  ) external {\n    require(\n      msg.sender == computeInitializerAddress(poolAddress),\n      \"ERR_NOT_PRE_DEPLOY_POOL\"\n    );\n    uint256 len = tokens.length;\n    require(balances.length == len, \"ERR_ARR_LEN\");\n\n    IndexPoolMeta memory meta = _poolMeta[poolAddress];\n    require(!meta.initialized, \"ERR_INITIALIZED\");\n    uint96[] memory denormalizedWeights = new uint96[](len);\n    uint256 valueSum;\n    uint144[] memory ethValues = oracle.computeAverageEthForTokens(\n      tokens,\n      balances,\n      SHORT_TWAP_MIN_TIME_ELAPSED,\n      SHORT_TWAP_MAX_TIME_ELAPSED\n    );\n    for (uint256 i = 0; i < len; i++) {\n      valueSum = valueSum.add(ethValues[i]);\n    }\n    for (uint256 i = 0; i < len; i++) {\n      denormalizedWeights[i] = _denormalizeFractionalWeight(\n        FixedPoint.fraction(uint112(ethValues[i]), uint112(valueSum))\n      );\n    }\n\n    address sellerAddress = _proxyManager.deployProxyManyToOne(\n      SELLER_IMPLEMENTATION_ID,\n      keccak256(abi.encodePacked(poolAddress))\n    );\n\n    IIndexPool(poolAddress).initialize(\n      tokens,\n      balances,\n      denormalizedWeights,\n      msg.sender,\n      sellerAddress\n    );\n\n    IUnboundTokenSeller(sellerAddress).initialize(\n      poolAddress,\n      defaultSellerPremium\n    );\n\n    meta.lastReweigh = uint64(now);\n    meta.initialized = true;\n    _poolMeta[poolAddress] = meta;\n\n    emit PoolInitialized(\n      poolAddress,\n      sellerAddress,\n      meta.categoryID,\n      meta.indexSize\n    );\n  }\n\n/* ==========  Pool Management  ========== */\n\n  /**\n   * @dev Sets the default premium rate for token seller contracts.\n   */\n  function setDefaultSellerPremium(\n    uint8 _defaultSellerPremium\n  ) external onlyOwner {\n    require(_defaultSellerPremium > 0 && _defaultSellerPremium < 20, \"ERR_PREMIUM\");\n    defaultSellerPremium = _defaultSellerPremium;\n  }\n\n  /**\n   * @dev Set the premium rate on `sellerAddress` to the given rate.\n   */\n  function updateSellerPremium(address tokenSeller, uint8 premiumPercent) external onlyOwner {\n    require(premiumPercent > 0 && premiumPercent < 20, \"ERR_PREMIUM\");\n    IUnboundTokenSeller(tokenSeller).setPremiumPercent(premiumPercent);\n  }\n\n  /**\n   * @dev Sets the maximum number of pool tokens that can be minted\n   * for a particular pool.\n   *\n   * This value will be used in the alpha to limit the maximum damage\n   * that can be caused by a catastrophic error. It can be gradually\n   * increased as the pool continues to not be exploited.\n   *\n   * If it is set to 0, the limit will be removed.\n   *\n   * @param poolAddress Address of the pool to set the limit on.\n   * @param maxPoolTokens Maximum LP tokens the pool can mint.\n   */\n  function setMaxPoolTokens(\n    address poolAddress,\n    uint256 maxPoolTokens\n  ) external onlyOwner _havePool(poolAddress) {\n    IIndexPool(poolAddress).setMaxPoolTokens(maxPoolTokens);\n  }\n\n  /**\n   * @dev Sets the swap fee on an index pool.\n   */\n  function setSwapFee(address poolAddress, uint256 swapFee) external onlyOwner _havePool(poolAddress) {\n    IIndexPool(poolAddress).setSwapFee(swapFee);\n  }\n\n  /**\n   * @dev Updates the minimum balance of an uninitialized token, which is\n   * useful when the token's price on the pool is too low relative to\n   * external prices for people to trade it in.\n   */\n  function updateMinimumBalance(IIndexPool pool, address tokenAddress) external _havePool(address(pool)) {\n    IIndexPool.Record memory record = pool.getTokenRecord(tokenAddress);\n    require(!record.ready, \"ERR_TOKEN_READY\");\n    uint256 poolValue = _estimatePoolValue(pool);\n    PriceLibrary.TwoWayAveragePrice memory price = oracle.computeTwoWayAveragePrice(\n      tokenAddress,\n      SHORT_TWAP_MIN_TIME_ELAPSED,\n      SHORT_TWAP_MAX_TIME_ELAPSED\n    );\n    uint256 minimumBalance = price.computeAverageTokensForEth(poolValue) / 100;\n    pool.setMinimumBalance(tokenAddress, minimumBalance);\n  }\n\n/* ==========  Pool Rebalance Actions  ========== */\n\n  /**\n   * @dev Re-indexes a pool by setting the underlying assets to the top\n   * tokens in its category by market cap.\n   */\n  function reindexPool(address poolAddress) external {\n    IndexPoolMeta memory meta = _poolMeta[poolAddress];\n    require(meta.initialized, \"ERR_POOL_NOT_FOUND\");\n    require(\n      now - meta.lastReweigh >= POOL_REWEIGH_DELAY,\n      \"ERR_POOL_REWEIGH_DELAY\"\n    );\n    require(\n      (++meta.reweighIndex % (REWEIGHS_BEFORE_REINDEX + 1)) == 0,\n      \"ERR_REWEIGH_INDEX\"\n    );\n    uint256 size = meta.indexSize;\n    address[] memory tokens = getTopCategoryTokens(meta.categoryID, size);\n  \n    PriceLibrary.TwoWayAveragePrice[] memory prices = oracle.computeTwoWayAveragePrices(\n      tokens,\n      LONG_TWAP_MIN_TIME_ELAPSED,\n      LONG_TWAP_MAX_TIME_ELAPSED\n    );\n    FixedPoint.uq112x112[] memory weights = MCapSqrtLibrary.computeTokenWeights(tokens, prices);\n\n    uint256[] memory minimumBalances = new uint256[](size);\n    uint96[] memory denormalizedWeights = new uint96[](size);\n    uint144 totalValue = _estimatePoolValue(IIndexPool(poolAddress));\n\n    for (uint256 i = 0; i < size; i++) {\n      // The minimum balance is the number of tokens worth the minimum weight\n      // of the pool. The minimum weight is 1/100, so we divide the total value\n      // by 100 to get the desired weth value, then multiply by the price of eth\n      // in terms of that token to get the minimum balance.\n      minimumBalances[i] = prices[i].computeAverageTokensForEth(totalValue) / 100;\n      denormalizedWeights[i] = _denormalizeFractionalWeight(weights[i]);\n    }\n\n    meta.lastReweigh = uint64(now);\n    _poolMeta[poolAddress] = meta;\n\n    IIndexPool(poolAddress).reindexTokens(\n      tokens,\n      denormalizedWeights,\n      minimumBalances\n    );\n  }\n\n  /**\n   * @dev Reweighs the assets in a pool by market cap and sets the\n   * desired new weights, which will be adjusted over time.\n   */\n  function reweighPool(address poolAddress) external {\n    IndexPoolMeta memory meta = _poolMeta[poolAddress];\n    require(meta.initialized, \"ERR_POOL_NOT_FOUND\");\n\n    require(\n      now - meta.lastReweigh >= POOL_REWEIGH_DELAY,\n      \"ERR_POOL_REWEIGH_DELAY\"\n    );\n\n    require(\n      (++meta.reweighIndex % (REWEIGHS_BEFORE_REINDEX + 1)) != 0,\n      \"ERR_REWEIGH_INDEX\"\n    );\n\n    address[] memory tokens = IIndexPool(poolAddress).getCurrentDesiredTokens();\n    PriceLibrary.TwoWayAveragePrice[] memory prices = oracle.computeTwoWayAveragePrices(\n      tokens,\n      LONG_TWAP_MIN_TIME_ELAPSED,\n      LONG_TWAP_MAX_TIME_ELAPSED\n    );\n    FixedPoint.uq112x112[] memory weights = MCapSqrtLibrary.computeTokenWeights(tokens, prices);\n    uint96[] memory denormalizedWeights = new uint96[](tokens.length);\n\n    for (uint256 i = 0; i < tokens.length; i++) {\n      denormalizedWeights[i] = _denormalizeFractionalWeight(weights[i]);\n    }\n\n    meta.lastReweigh = uint64(now);\n    _poolMeta[poolAddress] = meta;\n    IIndexPool(poolAddress).reweighTokens(tokens, denormalizedWeights);\n  }\n\n/* ==========  Pool Queries  ========== */\n\n  /**\n   * @dev Compute the create2 address for a pool initializer.\n   */\n  function computeInitializerAddress(address poolAddress)\n    public\n    view\n    returns (address initializerAddress)\n  {\n    initializerAddress = SaltyLib.computeProxyAddressManyToOne(\n      address(_proxyManager),\n      address(this),\n      INITIALIZER_IMPLEMENTATION_ID,\n      keccak256(abi.encodePacked(poolAddress))\n    );\n  }\n\n  /**\n   * @dev Compute the create2 address for a pool's unbound token seller.\n   */\n  function computeSellerAddress(address poolAddress)\n    public\n    view\n    returns (address sellerAddress)\n  {\n    sellerAddress = SaltyLib.computeProxyAddressManyToOne(\n      address(_proxyManager),\n      address(this),\n      SELLER_IMPLEMENTATION_ID,\n      keccak256(abi.encodePacked(poolAddress))\n    );\n  }\n\n  /**\n   * @dev Compute the create2 address for a pool.\n   */\n  function computePoolAddress(uint256 categoryID, uint256 indexSize)\n    public\n    view\n    returns (address poolAddress)\n  {\n    poolAddress = SaltyLib.computeProxyAddressManyToOne(\n      address(_proxyManager),\n      address(_factory),\n      POOL_IMPLEMENTATION_ID,\n      keccak256(abi.encodePacked(\n        address(this),\n        keccak256(abi.encodePacked(categoryID, indexSize))\n      ))\n    );\n  }\n\n  /**\n   * @dev Queries the top `indexSize` tokens in a category from the market oracle,\n   * computes their relative weights by market cap square root and determines\n   * the weighted balance of each token to meet a specified total value.\n   */\n  function getInitialTokensAndBalances(\n    uint256 categoryID,\n    uint256 indexSize,\n    uint144 wethValue\n  )\n    public\n    view\n    returns (\n      address[] memory tokens,\n      uint256[] memory balances\n    )\n  {\n    tokens = getTopCategoryTokens(categoryID, indexSize);\n    PriceLibrary.TwoWayAveragePrice[] memory prices = oracle.computeTwoWayAveragePrices(\n      tokens,\n      LONG_TWAP_MIN_TIME_ELAPSED,\n      LONG_TWAP_MAX_TIME_ELAPSED\n    );\n    FixedPoint.uq112x112[] memory weights = MCapSqrtLibrary.computeTokenWeights(tokens, prices);\n    balances = new uint256[](indexSize);\n    for (uint256 i = 0; i < indexSize; i++) {\n      balances[i] = MCapSqrtLibrary.computeWeightedBalance(wethValue, weights[i], prices[i]);\n    }\n  }\n\n/* ==========  Internal Pool Utility Functions  ========== */\n\n  /**\n   * @dev Estimate the total value of a pool by taking its first token's\n   * \"virtual balance\" (balance * (totalWeight/weight)) and multiplying\n   * by that token's average ether price from UniSwap.\n   */\n  function _estimatePoolValue(IIndexPool pool) internal view returns (uint144) {\n    (address token, uint256 value) = pool.extrapolatePoolValueFromToken();\n    return oracle.computeAverageEthForTokens(\n      token,\n      value,\n      SHORT_TWAP_MIN_TIME_ELAPSED,\n      SHORT_TWAP_MAX_TIME_ELAPSED\n    );\n  }\n\n/* ==========  General Utility Functions  ========== */\n\n  /**\n   * @dev Converts a fixed point fraction to a denormalized weight.\n   * Multiply the fraction by the max weight and decode to an unsigned integer.\n   */\n  function _denormalizeFractionalWeight(FixedPoint.uq112x112 memory fraction)\n    internal\n    pure\n    returns (uint96)\n  {\n    return uint96(fraction.mul(WEIGHT_MULTIPLIER).decode144());\n  }\n}"
    },
    "@indexed-finance/proxies/contracts/SaltyLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\n\n/* ---  External Libraries  --- */\nimport { Create2 } from \"@openzeppelin/contracts/utils/Create2.sol\";\n\n/* ---  Proxy Contracts  --- */\nimport { CodeHashes } from \"./CodeHashes.sol\";\n\n\n/**\n * @dev Library for computing create2 salts and addresses for proxies\n * deployed by `DelegateCallProxyManager`.\n *\n * Because the proxy factory is meant to be used by multiple contracts,\n * we use a salt derivation pattern that includes the address of the\n * contract that requested the proxy deployment, a salt provided by that\n * contract and the implementation ID used (for many-to-one proxies only).\n */\nlibrary SaltyLib {\n/* ---  Salt Derivation  --- */\n\n  /**\n   * @dev Derives the create2 salt for a many-to-one proxy.\n   *\n   * Many different contracts in the Indexed framework may use the\n   * same implementation contract, and they all use the same init\n   * code, so we derive the actual create2 salt from a combination\n   * of the implementation ID, the address of the account requesting\n   * deployment and the user-supplied salt.\n   *\n   * @param originator Address of the account requesting deployment.\n   * @param implementationID The identifier for the contract implementation.\n   * @param suppliedSalt Salt provided by the account requesting deployment.\n   */\n  function deriveManyToOneSalt(\n    address originator,\n    bytes32 implementationID,\n    bytes32 suppliedSalt\n  )\n    internal\n    pure\n    returns (bytes32)\n  {\n    return keccak256(\n      abi.encodePacked(\n        originator,\n        implementationID,\n        suppliedSalt\n      )\n    );\n  }\n\n  /**\n   * @dev Derives the create2 salt for a one-to-one proxy.\n   *\n   * @param originator Address of the account requesting deployment.\n   * @param suppliedSalt Salt provided by the account requesting deployment.\n   */\n  function deriveOneToOneSalt(\n    address originator,\n    bytes32 suppliedSalt\n  )\n    internal\n    pure\n    returns (bytes32)\n  {\n    return keccak256(abi.encodePacked(originator, suppliedSalt));\n  }\n\n/* ---  Address Derivation  --- */\n\n  /**\n   * @dev Computes the create2 address for a one-to-one proxy deployed\n   * by `deployer` (the factory) when requested by `originator` using\n   * `suppliedSalt`.\n   *\n   * @param deployer Address of the proxy factory.\n   * @param originator Address of the account requesting deployment.\n   * @param suppliedSalt Salt provided by the account requesting deployment.\n   */\n  function computeProxyAddressOneToOne(\n    address deployer,\n    address originator,\n    bytes32 suppliedSalt\n  )\n    internal\n    pure\n    returns (address)\n  {\n    bytes32 salt = deriveOneToOneSalt(originator, suppliedSalt);\n    return Create2.computeAddress(salt, CodeHashes.ONE_TO_ONE_CODEHASH, deployer);\n  }\n\n  /**\n   * @dev Computes the create2 address for a many-to-one proxy for the\n   * implementation `implementationID` deployed by `deployer` (the factory)\n   * when requested by `originator` using `suppliedSalt`.\n   *\n   * @param deployer Address of the proxy factory.\n   * @param originator Address of the account requesting deployment.\n   * @param implementationID The identifier for the contract implementation.\n   * @param suppliedSalt Salt provided by the account requesting deployment.\n  */\n  function computeProxyAddressManyToOne(\n    address deployer,\n    address originator,\n    bytes32 implementationID,\n    bytes32 suppliedSalt\n  )\n    internal\n    pure\n    returns (address)\n  {\n    bytes32 salt = deriveManyToOneSalt(\n      originator,\n      implementationID,\n      suppliedSalt\n    );\n    return Create2.computeAddress(salt, CodeHashes.MANY_TO_ONE_CODEHASH, deployer);\n  }\n\n  /**\n   * @dev Computes the create2 address of the implementation holder\n   * for `implementationID`.\n   *\n   * @param deployer Address of the proxy factory.\n   * @param implementationID The identifier for the contract implementation.\n  */\n  function computeHolderAddressManyToOne(\n    address deployer,\n    bytes32 implementationID\n  )\n    internal\n    pure\n    returns (address)\n  {\n    return Create2.computeAddress(\n      implementationID,\n      CodeHashes.IMPLEMENTATION_HOLDER_CODEHASH,\n      deployer\n    );\n  }\n}"
    },
    "@openzeppelin/contracts/utils/Create2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\n * `CREATE2` can be used to compute in advance the address where a smart\n * contract will be deployed, which allows for interesting new mechanisms known\n * as 'counterfactual interactions'.\n *\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\n * information.\n */\nlibrary Create2 {\n    /**\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\n     * will be deployed can be known in advance via {computeAddress}.\n     *\n     * The bytecode for a contract can be obtained from Solidity with\n     * `type(contractName).creationCode`.\n     *\n     * Requirements:\n     *\n     * - `bytecode` must not be empty.\n     * - `salt` must have not been used for `bytecode` already.\n     * - the factory must have a balance of at least `amount`.\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\n     */\n    function deploy(uint256 amount, bytes32 salt, bytes memory bytecode) internal returns (address) {\n        address addr;\n        require(address(this).balance >= amount, \"Create2: insufficient balance\");\n        require(bytecode.length != 0, \"Create2: bytecode length is zero\");\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\n        }\n        require(addr != address(0), \"Create2: Failed on deploy\");\n        return addr;\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\n     * `bytecodeHash` or `salt` will result in a new destination address.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\n        return computeAddress(salt, bytecodeHash, address(this));\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer) internal pure returns (address) {\n        bytes32 _data = keccak256(\n            abi.encodePacked(bytes1(0xff), deployer, salt, bytecodeHash)\n        );\n        return address(uint256(_data));\n    }\n}\n"
    },
    "@indexed-finance/proxies/contracts/CodeHashes.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\n\n\n/**\n * @dev Because we use the code hashes of the proxy contracts for proxy address\n * derivation, it is important that other packages have access to the correct\n * values when they import the salt library.\n */\nlibrary CodeHashes {\n  bytes32 internal constant ONE_TO_ONE_CODEHASH = 0x63d9f7b5931b69188c8f6b806606f25892f1bb17b7f7e966fe3a32c04493aee4;\n  bytes32 internal constant MANY_TO_ONE_CODEHASH = 0xa035ad05a1663db5bfd455b99cd7c6ac6bd49269738458eda140e0b78ed53f79;\n  bytes32 internal constant IMPLEMENTATION_HOLDER_CODEHASH = 0x11c370493a726a0ffa93d42b399ad046f1b5a543b6e72f1a64f1488dc1c58f2c;\n}"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "useLiteralContent": false
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "id",
          "ast"
        ]
      }
    }
  }
}